<ul>
  <li>
    배치 추천/실시간 추천
  </li>
  <li>
    추천 시스템 설계 패턴
  </li>
  <li>
    다단계 추천이나 근사 최근접 탐색을 통한 노력
  </li>
  <li>
    로그 설계
  </li>
  <li>
    뉴스 서비스에서의 실제 사례
  </li>
</ul>

<br>

<h1>1. 시스템 개요</h1>
<h2>1-1. 배치 추천과 실시간 추천</h2>
<ul>
  <li>
    <strong>배치 추천</strong>은 모델 학습부터 예측까지 처리를 <strong>정해진 시간에 일괄적으로 수행</strong>한다. <strong>실시간 추천</strong>은 클릭 등의 <strong>트리거</strong>로 특징량 추출과 업데이트 및 추천을 실시간으로 처리한다.
  </li>
  <li>
    배치 추천과 실시간 추천은 <strong>정보 업데이트 요구(refreshness request)</strong> 수준에 따라 선택된다.
  </li>
    <ul>
      <li>
        정보 업데이트 요구란 새로운 아이템, 사용자 정보, 사용자 행동 데이터 등을 <strong>사용할 수 있게 된 시점부터 실제로 추천에 활용되기 까지의 시간차</strong>가 얼마나 <strong>짧게 요구</strong>되는가를 의미한다.
      </li>
    </ul>
  <li>
    업데이트 빈도가 낮고 요구 수준이 비교적 낮다면 배치 추천이 적합하다. 반대로 업데이트 빈도가 잦고 요구 수준이 높다면 실시간 추천이 적합하다.
  </li>
    <ul>
      <li>
        실시간 추천의 대표적인 경우는 <strong>개인화</strong>가 포함된다.
      </li>
    </ul>
</ul>

<br>

<h2>1-2. 대표적인 추천 시스템 개요</h2>
<h3>개요 추천</h3>
<ul>
  <li>
    <strong>신규순</strong>이나 <strong>인기순</strong>으로 아이템을 표시하는 것을 의미한다. 가장 간단하게는 DB에 신규순으로 아이템을 정렬하는 쿼리를 사용하는 방법이 있다.
  </li>
  <li>
    인기순으로 설계를 할 때에는 일반적으로 <strong>배치형 시스템</strong>을 구성한다. <strong>집계</strong>를 수행하고 <strong>DB에 저장</strong>하는 방식으로 동작한다.
  </li>
  <li>
    카테고리나 사용자 속성별로 인기도를 계산하고 결과를 DB에 저장하는 방식으로 정밀도를 높일 수 있다.
  </li>
</ul>

<h3>연관 아이템 추천</h3>
<ul>
  <li>
    대표적으로 사전에 <strong>유사도를 계산</strong>하고 <strong>비슷한 아이템군을 DB에 저장</strong>해 결과를 반환하는 방식이 있다.
  </li>
  <li>
    웹과 DB 사이에 <strong>추천 API를 경유</strong>하는 방식을 사용할 수도 있다.
  </li>
    <ul>
      <li>
        특정 사용자에게 보여서는 안되는 <strong>아이템을 제외</strong>하는 등의 처리를 추천 API에서 수행할 수 있다.
      </li>
      <li>
        혹은 <strong>고유 식별 user_id</strong> 등을 통해 사용자에 따라 유사도 <strong>산출 알고리즘을 바꾸는 A/B 테스트</strong>도 실행할 수 있다.
      </li>
    </ul>
</ul>

<h3>개인화 추천</h3>
<ul>
  <li>
    <strong>배치 유형</strong>의 개인화 추천에서는 각 사용자별로 추천하는 아이템을 <strong>미리 계산</strong>해서 DB에 저장한다.
  </li>
  <li>
    사용자의 프로필, 구입 이력 그리고 행동 로그 등을 활용할 수 있으며 각 개인화 알고리즘의 결과를 <strong>개별적으로 유지</strong>하면서 결과를 <strong>조합</strong>하여 사용자에게 제시할 수도 있다.
  </li>
  <li>
    웹과 DB 사이에 <strong>API</strong>를 통해 특정 아이템을 제외하는 로직을 추가하거나 A/B 테스트를 수행할 수도 있다.
  </li>
  <li>
    벡터화를 통한 개인화 추천 또한 최근 많이 활용되고 있다. 벡터화 방법으로는 ML과 DL 등 다양한 방법을 시도할 수 있다.
  </li>
</ul>

<br>

<h2>1-3. 다단계 추천</h2>
<ul>
  <li>
    사용자와 상품 모두 많은 경우 추천을 수행할 때 <strong>시스템 부하</strong>를 고려해 설계해야 한다. 
  </li>
  <li>
    시스템 부하는 낮게 유지하면서 정밀도가 높은 추천을 수행하기 위한 방법으로는 <strong>다단계 추천</strong>이 있다.
  </li>
    <ul>
      <li>
        다단계 추천으로는 후보 선택, 스코어링(scoring) 그리고 재순위(reranking)이 있다. 이때 단계는 <strong>후보 선택 → 스코어링/재순위</strong> 2 단계 추천(two-stage recommendation)로 구성된다.
      </li>
    </ul>
</ul>

<h3>1-3-1. 후보 선택</h3>
<ul>
  <li>
    막대한 아이템으로부터 <strong>추천 후보가 될 아이템</strong>을 추출한다. 이는 사용자 요청에 고속으로 아이템을 반환하기 위한 <strong>전처리</strong>에 해당한다.
  </li>
  <li>
    후보 선택 처리는 대규모 아이템을 대상으로 하기에 가벼워야 한다.
  </li>
  <li>
    후보 선택 로직은 한 가지일 필요는 없기에 여러 후보 선택 로직을 <strong>조합</strong>해 다양한 관점에서 후보 아이템을 추천할 수 있다.
  </li>
</ul>

<h3>1-3-2. 스코어링</h3>
<ul>
  <li>
    실제로 사용자에게 제시할 아이템을 선택하기 위해 아이템에 <strong>점수를 부여</strong>한다.
  </li>
  <li>
    이미 후보 선택을 통해 아이템이 줄어든 후이기에 보다 <strong>높은 정확도</strong>의 추론을 활용하는 경우가 많다.
  </li>
</ul>

<h3>1-3-3. 재순위</h3>
<ul>
  <li>
    재순위 처리에서는 스코어링에서 선택된 아이템을 <strong>나열</strong>하도록 처리한다. 나열할 때에는 비슷한 아이템을 피하도록 하거나 아이템 밀집도를 고려해 나열하도록 한다.
  </li>
</ul>

<br>

<h2>1-4. 근사 최근접 탐색</h2>
<ul>
  <li>
    <strong>근사 최근접 탐색</strong>은 최근접 탐색에서 계산 속도를 높이는 방법 중 하나이다. 근사라는 의미에 맞게 <strong>일부 정확성</strong>을 특징으로 하여 입력된 벡터에 가까운 벡터를 빠르게 찾는다.
  </li>
  <li>
    사용자에 대한 개인화 뿐만아니라 아이템으로부터 비슷한 아이템을 추출하는 <strong>연관 아이템 추천</strong>에도 활용할 수 있다.
  </li>
  <li>
    근사 최근접 탐색을 사용한 추천은 다음 두 단계로 이루어진다.
  </li>
    <ul>
      <li>
        아이템(사용자)의 벡터에 <strong>인덱스</strong>를 붙인다.
      </li>
      <li>
        해당 인덱스를 사용해 사용자에게 <strong>추천 아이템을 추천</strong>한다.
      </li>
    </ul>
  <li>
    <strong>벡터 공간을 분할</strong>하고 각 분할된 공간을 <strong>인덱스</strong>로하여 아이템에 부여한다. 이후 추천을 할 때에는 전체 아이템이 아니라 <strong>동일 인덱스(같은 벡터 공간)에 속하는 아이템</strong>을 추천으로 고려한다.
  </li>
</ul>

<h3>1-4-1. 아이템과 사용자 벡터 모두를 일 단위로 생성하는 경우</h3>
<ul>
  <li>
    <strong>일단위</strong>로 알고리즘 재학습을 시키면 일단위로 알고리즘 결과로 추천되는 아이템 또한 달라진다. 따라서 <strong>인덱스</strong>도 다음과 같이 <strong>갱신</strong>할 필요가 있다.
  </li>
    <ul>
      <li>
        아이템과 사용자의 <strong>벡터를 생성</strong>한다.
        <br>→ 아이템 벡터에 <strong>인덱스</strong>를 붙인다.
        <br>→ 인덱스를 사용해 사용자에게 추천 아이템을 <strong>추천</strong>한다.
      </li>
    </ul>
</ul>

<h3>1-4-2. 사용자 벡터만 일 단위로 생성하는 경우</h3>
<ul>
  <li>
    사용자와 아이템 모두 생성하는 것이 부담이 되는 경우 <strong>사용자 벡터</strong>만 일 단위로 생성할 수도 있다.
  </li>
  <li>
    <strong>주 단위로 아이템 벡터 처리</strong>
  </li>
    <ul>
      <li>
        <strong>아이템 벡터</strong>를 생성한다.
        <br>→ 아이템 벡터에 <strong>인덱스를 부여</strong>한다.
      </li>
    </ul>
  <li>
    일 단위로 사용자 벡터 처리
  </li>
    <ul>
      <li>
        <strong>사용자 벡터</strong>를 생성한다.
        <br>→ 인덱스를 사용해 사용자에게 <strong>추천 아이템을 추천</strong>한다.
      </li>
    </ul>
  <li>
    부하가 낮아지는 것은 맞지만 아이템 벡터가 주 단위로 생성되기에 새롭게 추가된 아이템은 다음 처리 때까지 추천되지 않는다는 문제가 있다.
  </li>
</ul>

<h3>1-4-3. 모델을 유지하고 일 단위로 벡터를 생성하는 경우</h3>
<ul>
  <li>
    가장 먼저 처리할 항목들
  </li>
    <ul>
      <li>
        아이템과 사용자 벡터를 생성하고 이때의 <strong>모델을 저장</strong>해둔다.
        <br>→ 아이템 벡터에 인덱스를 부여한다.
      </li>
    </ul>
  <li>
    일 단위로 다음을 처리한다.
  </li>
    <ul>
      <li>
        저장한 모델을 사용해 <strong>아이템과 사용자 벡터를 생성</strong>한다.
        <br>→ 신규 아이템 벡터에 인덱스를 붙인다.
        <br>→ 인덱스를 활용해 사용자아게 추천 아이템을 추천한다.
      </li>
    </ul>
  <li>
    모델을 업데이트하지 않기에 새롭게 들어온 아이템에만 인덱스를 붙이면 된다. 단, 계속해서 <strong>같은 인덱스</strong>를 보유하기에 <strong>정확도가 떨어질 우려</strong>가 존재한다.
  </li>
  <li>
    일반적으로 <strong>유사 이미지 검색</strong>이나 <strong>콘텐츠 기반 추천 시스템</strong>에서 많이 사용된다.
  </li>
  <li>
    근사 최근접 탐색 방법으로는 LSH, NMSLIB, Falss, Annoy가 있으며 도서에는 장표로 순서도와 성능에 대한 데이터가 있다.
  </li>
</ul>

<br><br>

<h1>2. 로그 설계</h1>
<ul>
  <li>
    추천 시스템에도 사용자가 직접 서비스에 접속하는 <strong>클라이언트 사이드 로그</strong>와 응답 데이터를 생성하는 <strong>서버 사이드에서 얻는 로그</strong>가 존재한다.
  </li>
</ul>
  
<br>

<h2>2-1. 클라이언트 사이드 로그</h2>
<h3>2-1-1. 사용자 행동</h3>
<ul>
  <li>
    사용자 행동 로그는 클라이언트 사이드 로그이면서 사용자가 서비스에서 한 <strong>행동</strong>을 기록한 로그이다.
  </li>
  <li>
    모델의 학습 외에도 서비스 제공자가 사용자에게 의도한 행동이 실제로 수행됐는지 확인할 때 사용할 수 있다.
  </li>
</ul>

<h3>2-1-2. 성능</h3>
<ul>
  <li>
    성능은 사용자가 요청한 페이지가 실제로 <strong>완전히 표시될 때까지 걸리는 시간</strong> 또는 <strong>조작이 가능해질 때까지의 시간</strong>을 의미한다.
  </li>
</ul>

<h3>2-1-3. 에러와 크래시</h3>
<ul>
  <li>
    필요에 따라서는 에러 수에 관한 경고를 설정하는 것이 좋다.
  </li>
</ul>

<br>

<h2>2-2. 서버 사이드 로그</h2>
<ul>
  <li>
    서버 사이드 로그는 <strong>클라이언트 뒤쪽의 시스템 동작</strong>을 기록한 로그이다.
  </li>
</ul>

<h3>2-2-1. 성능</h3>
<ul>
  <li>
    서버 사이드의 성능 로그는 <strong>클라이언트로부터의 요청에 응답하는 데 걸리는 시간</strong>을 기록한다.
  </li>
</ul>

<h3>2-2-2. 시스템 응답</h3>
<ul>
  <li>
    클라이언트로부터의 요청 수나 응답 수 또는 정상 응답 비율을 기록한다. 연관 아이템 요청에 대해 반환되는 연관 아이템이 존재하지 않는 경우 로그를 남겨 추천 범위를 나타내는 지표인 커버리지를 측정할 수 있다.
  </li>
</ul>

<h3>2-2-3. 시스템 처리 정보</h3>
<ul>
  <li>
    캐시 히트 비율, CPU 부하, 메모리 사용률, 에러나 예외 수 등 <strong>시스템 처리 정보</strong>를 기록한다.
  </li>
  <li>
    시스템 처리 정보는 실시간 추천의 응답이 느려지는 등의 상황에 <strong>문제를 추적</strong>하기 용이하다.
  </li>
</ul>

<br>

<h2>2-3. 사용자 행동 로그의 구체적인 예 (p204)</h2>
<ul>
  <li>
    로그에 대한 구체적인 예가 제시되어 있다.
  </li>
  <li>
    로그를 활용하는 방법은 다양하지만 <strong>목적이 모호한 로그</strong>가 쌓이면 부담이 될 수 있기에 로그 구현 개발자나 로그를 사용하는 사용자는 <strong>원하는 바를 명확히</strong>하는 것이 좋다.
  </li>
</ul>

<br><br>

<h1>3. 실제 시스템 예</h1>
<h2>3-1. 배치 추천</h2>
<ul>
  <li>
    대규모 뉴스 서비스에서 푸시 알림을 수행하는 사례
  </li>
  <li>
    후보 기사 선택에는 행동 로그를 사용해 클릭률이 높은 기사를 미리 DB에 저장한다.
  </li>
  <li>
    모델링 처리에는 사용자의 과거 행동에서 사용자 선호도를 학습한다.
  </li>
  <li>
    스코어링 처리에는 학습이 완료된 모델을 사용해 기사의 점수를 부여하고 점수가 높은 기사를 DB에 저장한다.
  </li>
  <li>
    마지막으로 추천 기사를 사용자에게 전송하는 처리를 푸시 전송 기능이 담당한다.
  </li>
</ul>

<h3>3-1-1. 후보 기사 선정</h3>
<ul>
  <li>
    추천 부호가 되는 기사를 선택한다.
  </li>
  <li>
    후보 기사 선청 처리는 30분마다 수행하며 최신성이 중요하기에 기사가 투고된 후 N일 이내의 기사만 후보로 필터링한다.
    <br>→ 중복된 아이템을 제거하기 위해 한 번이라도 과거에 푸시된 기사는 제거한다.
    <br>→ 푸시 기사 전송은 중요한 영역이기에 사내 전문자를 통해 해가될 기사는 제외한다.
    <br>→ 푸시 행동 로그를 이용해 기사의 클릭률이 높은대로 상위 K건을 전송 후보로 한다.
  </li>
</ul>

<h3>3-1-2. 모델링</h3>
<ul>
  <li>
    사용자 특징과 기사 특징을 활용해 사용자가 푸시 기사를 열람할 것인지를 예측하는 모델을 구축한다.
  </li>
  <li>
    모델 학습은 1일 1회, 기사의 신규 정송 수가 적은 야간에 수행하고, 학습한 모델을 저장한다.
  </li>
</ul>

<h3>3-1-3. 스코어링</h3>
<ul>
  <li>
    학습이 완료된 모델에 <strong>사용자 특징량과 기사 특징량을 입력</strong>고 각 사용자의 <strong>각 후보 기사에 대한 점수를 계산</strong>한 후 점수를 DB에 저장한다.
  </li>
</ul>

<h3>3-1-4. 푸시 전송</h3>
<ul>
  <li>
    사용자가 설정한 시간에 맞추어 전송 처리를 수행한다.
  </li>
</ul>

<br>

<h2>3-2. 실시간 추천</h2>
<ul>
  <li>
    후보 기사 선정에는 행동 로그나 기사 정보를 사용해 클릭률이 높은 기사를 미리 DB에 저장한다.
    <br>→ 모델링 처리에는 사용자의 과거 행동에서 사용자의 선호도를 학습한다.
    <br>→ 스코어링과 재순위 처리에서는 기사 특징량과 사용자 특징량의 유사도를 계산하고 사용자에게 기사를 전송한다.
  </li>
  <li>
    사용자 특징량은 사용자가 <strong>기사를 클릭할 때마다</strong> 특징량을 업데이트한다.
  </li>
</ul>

<h3>3-2-1. 스코어링과 재순위</h3>
<ul>
  <li>
    스코어링에서는 사용자 특징량과 기사 특징량을 <strong>DB에서 읽은 후</strong> 요청한 사용자에 대한 <strong>후보 기사 점수를 산출</strong>한다. 단, 응답 시간을 고려해야 한다.
  </li>
    <ul>
      <li>
        스코어링은 사용자에 대해 각 기사에서 독립적으로 계산할 수 있기에 <strong>병렬 계산</strong>이 가능하다.
      </li>
    </ul>
  <li>
    <strong>캐시</strong>를 도입하는 방법 또한 응답 시간을 줄일 수 있다. DB 접근 결과를 캐시할   수도 있고 사용자 특징량을 캐시할 수도 있다. 단, 사용자 특징량의 경우 추천 정확도를 위해 주기 관리가 중요하다.
  </li>
  <li>
    재순위 처리에서는 사용자가 과거에 <strong>명시적으로 수행한 피드백</strong>과 입고 시간에 대한 기사의 <strong>최신성</strong>을 고려해 기사를 나열한다.
  </li>
</ul>

<h3>3-2-2. 특징량 업데이트</h3>
<ul>
  <li>
    데이터에 따라 다르지만 흥미나 관심이 단기간에 변하는 서비스의 경우 특징량 업데이트는 사용자의 행동을 바로 반영하여 업데이트한다.
  </li>
</ul>