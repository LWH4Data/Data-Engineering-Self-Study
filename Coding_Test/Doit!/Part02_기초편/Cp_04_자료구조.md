<h1>1. 배열과 리스트</h1>
<h2>1-1. 배열과 리스트의 핵심 이론</h2>
<ul>
  <li>
    일반적으로 컴퓨터 공학에서는 배열과 리스트를 명확하게 구분하지만 <strong>파이썬은 리스트의 특징과 배열의 특징을 모두 갖는다</strong>.
  </li>
</ul>

<h3>1-1-1. 배열</h3>
<ul>
  <li>
    배열은 <strong>메모리의 연속 공간</strong>에 값이 채워져 있는 형태의 자료구조이다.
  </li>
  <li>
    배열의 값은 <strong>인덱스</strong>를 통해 참조할 수 있으며, <strong>선언한 자료형의 값</strong>만 저장할 수 있다.
  </li>
  <li>
    배열의 특징 
  </li>
    <ul>
      <li>
        <strong>인덱스</strong>를 사용하여 값에 바로 접근할 수 있다.
      </li>
      <li>
        새로운 값을 삽입하거나 특정 인덱스에 있는 값을 삭제하기 어렵다. 값을 삽입하거나 삭제하려면 해당 <strong>인덱스 주변에 있는 값을 이동</strong>시키는 과정이 필요하다.
      </li>
      <li>
        <strong>배열의 크기</strong>는 선언할 때 지정할 수 있으며, 한 번 선언하면 <strong>크기를 늘리거나 줄일 수 없다</strong>.
      </li>
      <li>
        구조가 간단하기에 코딩 테스트에서 많이 사용한다.
      </li>
    </ul>
</ul>

<h3>1-1-2. 리스트</h3>
<ul>
  <li>
    리스트는 <strong>값과 포인터를 묶은 노드</strong>라는 것을 <strong>포인터로 연결</strong>한 자료구조이다.
  </li>
  <li>
    리스트의 특징
  </li>
    <ul>
      <li>
        인덱스가 없기에 값에 접근하려면 <strong>Head 포인터부터 순서대로</strong> 접근해야 한다. 즉, 값에 접근하는 속도가 <strong>느리다</strong>.
      </li>
      <li>
        포인터로 연결되어 있어 데이터를 <strong>삽입</strong>하거나 <strong>삭제</strong>하는 <strong>연산 속도가 빠르다</strong>.
      </li>
      <li>
        선언할 때 별도의 크기를 지정하지 않는다. 즉, 크기가 정해져 있지 않아 크기가 <strong>가변적인 데이터</strong>를 다룰 때 적절하다.
      </li>
      <li>
        <strong>포인터를 저장할 공간</strong>이 필요하기에 배열보다 구조가 복잡하다.
      </li>
    </ul>
</ul>

```python
# 도서 풀이: 숫자의 합 구하기
#   ● 내 풀이는 git 코딩 테스트에 포함.
n = input()
numbers = list(input())
sum = 0

for i in numbers:
    sum = sum + int(i)

print(sum)
```

```python
# 2. 도서 풀이: 평균 구하기
#   ● 내 풀이는 git 코딩 테스트에 포함.
n = input()
mylist = list(map(int, input().split()))
mymax = max(mylist)
sum = sum(mylist)

# 한 과목과 관련된 수식을 총합과 관련된 수식으로 변환해 로직 간단화
print(sum * 100 / mymax / int(n))
```

<br><br>

<h1>2. 구간 합</h1>
<ul>
  <li>
    구간 합은 <strong>합 배열</strong>을 이용하여 시간 복잡도를 더 줄이기 위해 사용하는 특수한 목적의 알고리즘이다.
  </li>
</ul>

<br>

<h2>2-1. 구간 합의 핵심 이론</h2>
<h3>2-1-1. 합 배열 S 정의</h3>
<ul>
  <li>
    S[i] = A[0] + A[1] + A[2] + ... + A[i-1] + A[i]
  </li>
  <li>
    합 배열을 미리 구해두면 기존 리스트의 일정 범위 합을 구하는 시간 복잡도가 O(N)에서 O(1)로 감소한다.
  </li>
</ul>

<h3>2-1-2. 합 배열 S를 만드는 공식</h3>
<ul>
  <li>
    S[i] = S[i-1] + A[i]
  </li>
</ul>

<h3>2-1-3. 구간 합을 구하는 공식</h3>
<ul>
  <li>
    S[j] = S[i-1]
  </li>
</ul>

<h3>2-1-4. A[2] ~ A[5] 구간 합을 합 배열로 구하는 과정</h3>
<ul>
  <li>
    S[5] = A[0] + A[1] + A[2] + A[3] + A[4] + A[5]
  </li>
  <li>
    S[1] = A[0] + A[1]
  </li>
  <li>
    S[5] - S[1] = A[2] + A[3] + A[4] + A[5]
  </li>
</ul>

```python
# 구간 합 구하기 1: 11659
import sys
input = sys.stdin.readline
suNo, quizNo = map(int, input().split())
numbers = list(map(int, input().split()))

# 0 번째 수는 없기에 더미로 생성.
prefix_sum = [0]
temp = 0

for i in numbers:
    temp = temp + i
    # append를 통해 누적합을 원소로 추가하면서 진행
    prefix_sum.append(temp)

for i in range(quizNo):
    s, e = map(int, input().split())
    print(prefix_sum[e] - prefix_sum[s-1])
```

```python
# 2. 구간 합 구하기 2: 11660
#   ● 핵심은 두 영역을 빼고, 중복 차감된 부분을 더한다는 거 같긴한데...
import sys
input = sys.stdin.readline
n, m = map(int, input().split())
A = [[0] * (n + 1)]
D = [[0] * (n + 1) for _ in range(n + 1)]

# 합 배열 구하기
#   ● A[i][j]를 제외한 영역의 합을 구하고
#   ● 마지막에 A[i][j]를 더한다.
for i in range(1, n + 1):
    for j in range(1, n + 1):
        D[i][j] = D[i][j-1] + D[i-1][j] - D[i-1][j-1] + A[i][j]

# 구간 합 계산
#   ● 전체 구간 합에서 두 번 겹치는 영역을 제거
#     → 두 번 제거된 영역을 합한다.
for _ in range(m):
    x1, y1, x2, y2 = map(int, input().split())
    result = D[x2][y2] - D[x1-1][y2] - D[x2][y1-1] + D[x1-1][y1-1]
```

```python
# 3. 나머지 합 구하기.
import sys
input = sys.stdin.readline
n, m = map(int, input().split())
A = list(map(int, input().split()))
S = [0] * n
C = [0] * m
S[0] = A[0]
answer = 0

# 합 배열 구하기.
for i in range(1, n):
    S[i] = S[i-1] + A[i]

# 전체를 대상으로 나머지르 구한다.
for i in range(n):
    # 나머지 연산
    remainder = S[i] % m

    # 나머지가 0이라면 answer += 1
    if remainder == 0:
        answer += 1

    # 나머지가 0이 아닌 경우
    #   ● 나머지를 index로 하여 같은 나머지를 갖는 경우를 value로 저장한다.
    C[remainder] += 1

# 왜 나머지가 같은 두 누적합의 구간합은 나머지가 0일까? (나머지 1가정)
#   ● S[j] = jM + 1 / S[i] = iM + 1 (j > i)
#     → S[j] - S[i] = (j-i)M
#     → 즉, M으로 나눈 나머지는 0이 된다.
for i in range(m):
    # 나머지가 같은 수 중에서 두 개의 수를 뽑는 경우의 수를 더한다.
    if C[i] > 1:
        answer += (C[i] * (C[i] - 1) // 2)
```

<br><br>

<h1>3. 투 포인터</h1>
<ul>
  <li>
    두 개의 포인터로 알고리즘의 시간 복잡도를 최적화한다.
  </li>
</ul>

```python
# 1. 2018
#   ● 슬라이딩 윈도우 방식이 섞여 두 포인터로 된 영역을 밀면서 탐색.
n = int(input())
count = 1
start_index = 1
end_index = 1
sum = 1

while end_index != n:
    if sum == n:
        count += 1
        end_index += 1
        sum += end_index
    elif sum > n:
        sum -= start_index
        start_index += 1
    else:
        end_index += 1
        sum += end_index

print(count)
```

```python
# 2. 주몽의 명령/1940
#   ● 정렬 + 투 포인터를 활용한다.
#   ● 브루트포스는 P(N^2)인데 반하여 정렬은 O(nlogn)이다.
import sys
input = sys.stdin.readline
N = int(input())
M = int(input())
A = list(map(int, input().split()))

# 오름차순 정렬
A.sort()

count = 0
i = 0
j = N - 1

# 투 포인터를 이동 원칙에 따라 포인터를 이동하며 처리.
while i < j:
    if A[i] + A[j] < M:
        i += 1
      else A[i] + A[k] > M:
        j -= 1
      else:
        count += 1
        i += 1
        j -= 1  

print(count)
```

```python
# 3. '좋은 수' 구하기 - 1253
#   ● 두 수의 합 중에 자기자신 보다 클 수는 없다.
#     → 항상 오른쪽 포인터는 '찾는 수 -1'이 된다.
import sys
input = sys.stdin.readline
N = int(input())
Result = 0
A = list(map(int, input().split()))
A.sort()

for k in range(N):
    find = A[k]
    i = 0
    j = N - 1
    
    # 투 포인터 알고리즘
    while i < j:

        # find가 서로 다른 두 수의 합인지 체크
        if A[i] + A[j] == find:
            if i != k and j != k:
                Result += 1
                break
            elif i == k:
                i += 1
            elif j == k:
                j -= 1
        elif A[i] + A[j] < find:
            i += 1
        else:
            j -= 1

print(Result)
```

<br><br>

<h1>4. 슬라이딩 윈도우</h1>
<ul>
  <li>
    슬라이딩 윈도우 알고리즘은 두 개의 포인터로 <strong>범위(window)</strong>를 지정한 뒤 범위범위(window)를 유지한 채 이동하며 문제를 해결한다.
  </li>
</ul>

```python
# 1. DNA 비밀번호 - 12891
#   ● 나의 경우 >=을 사용했는데 풀이는 ==으로 모든 처리.

# 변수 초기화
checkList = [0] * 4  # 비밇번호 체크 리스트
myList = [0] * 4`    # 현재 상태 리스트
checkSecret = 0      # 몇 개의 문자가 조건을 충종 했는지

# 함수 정의
# 새로 들어온 문자를 처리하는 함수
def myadd(c):
    global checkList, myList, checkSecret

    # A가 들어온 경우 A 업데이트
    if c == 'A':
        myList[0] += 1
        if myList[0] == checkList[0]:
            checkSecret += 1
    
    # C가 들어온 경우 C 업데이트
    elif c == 'C':
        myList[1] += 1
        if myList[1] == checkList[1]:
            checkSecret += 1
    
    # G가 들어온 경우 G 업데이트
    elif c == 'G':
        myList[2] += 1
        if myList[2] == checkList[2]:
            checkSecret += 1

    # T가 들어온 경우 T 업데이트
    elif c == 'T':
        myList[3] += 1
        if myList[3] == checkList[3]:
            checkSecret += 1

# 제거되는 문자를 처리하는 함수
def myremove(c):

    # 전역 변수 설정.
    global checkList, myList, checkSecret
    
    # A가 제거되는 경우
    if c == 'A':
        if myList[0] == checkList[0]:
            checkSecret -= 1
        myList[0] -= 1
    
    # C가 제거되는 경우.
    if c == 'C':
        if myList[1] == checkList[1]:
            checkSecret -= 1
        myList[1] -= 1
    
    # G가 제거되는 경우
    if c == 'G':
        if mylist[2] == checkList[2]:
            checkSecret -= 1
        myList[2] -= 1
    
    # T가 제거되는 경우.
    if c == 'T':
        if mylist[3] == checkList[3]:
            checkSecret -= 1
        myList[3] -= 1

# 입력값 받기
S, P = map(int, input().split())
Result = 0
A = list(input())
checkList = list(map(int, input().split()))

# 현재 상태 저장
for i in range(4):
    if checkList[i] == 0:
        checkSecret += 1

# 초기 P 부분 문자열 처리 부분
for i in range(P):
    myadd(A[i])

# 네 종류 문자의 개수 조건을 모두 충족하면 유효한 비밀번호
if checkSecret == 4:
    Result += 1

for i in range(P, S):
    j = i - P
    myadd(A[i])
    myremove(A[j])
    if checkSecret == 4:
        Result += 1

print(Result)
```

```python
# 2. 최솟값 찾기 - 11003
# deque로 슬라이딩 윈도우를 구현하는 풀이.
from collections import deque
N, L = map(int, input().split())
mydeque = deque()
now = list(map(int, input().split()))

# 새로운 값이 들어올 때마다 정렬 대신 현재 수보다 큰 값을 deque()에서
# 제거하여 시간 복잡도를 줄인다.
for i in range(N):
    while mydeque and mydeque[-1][0] > now[i]:
        mydeque.pop()
    mydeque.append((now[i], i))
    # 범위에서 벗어난 값은 deque에서 제거
    if mydeque[0][1] <= i - L: 
        mydeque.popleft()
    print(mydeque[0][0], end=' ')
```

<br><br>

<h1>5. 스택과 큐</h1>
<ul>
  <li>
    스택과 큐는 리스트에서 조금 더 발전한 형태의 자료 구조이다.
  </li>
</ul>

<br>

<h2>5-1. 스택과 큐의 핵심 이론</h2>
<h3>5-1-1. 스택</h3>
<ul>
  <li>
    <strong>스택(stack)</strong>은 삽입과 삭제 연산이 <strong>후입선출(LIFO, Last-in First-out)</strong>으로 이루어진 자료구조이다.
  </li>
  <li>
    후입선출은 삽입과 삭제가 <strong>한 쪽</strong>에서만 일어나는 특징이 있다.
  </li>
  <li>
    파이썬에서는 <strong>리스트</strong>를 통해 쉽게 스택을 구현할 수 있다.
  </li>
</ul>

<h4>파이썬의 스택</h4>
<ul>
  <li>
    위치
  </li>
    <ul>
      <li>
        <strong>top</strong>: 삽입과 삭제가 일어나는 위치를 의미한다.
      </li>
    </ul>
  <li>
    연산(리스트 이름이 s 일 때)
  </li>
    <ul>
      <li>
        <strong>s.append(data)</strong>: top 위치에 새로운 데이터를 삽입한다.
      </li>
      <li>
        <strong>s.pop()</strong>: top 위치에 현재 있는 데이터를 삭제하고 <strong>확인</strong>한다.
      </li>
      <li>
        <strong>s[-1]</strong>: top 위치에 현재 있는 데이터를 <strong>단순 확인</strong>한다.
      </li>
    </ul>
  <li>
    <strong>깊이 우선 탐색(DFS, Depth First Search)</strong>과 <strong>백트래킹</strong> 종류의 코딩 테스트에 효과적이다.
  </li>
  <li>
    후입선출은 개념 자체가 <strong>재귀 함수 알고리즘</strong> 원리와 일맥상통한다.
  </li>
</ul>

<h3>5-1-2. 큐</h3>
<ul>
  <li>
    <strong>큐(queue)</strong>는 삽입과 삭제 연산이 <strong>선입선출(FIFO, First-in First-out)</strong>으로 이루어진 자료구조이다.
  </li>
  <li>
    삽입과 삭제가 <strong>양방향</strong>에서 이루어진다.
  </li>
  <li>
    파이썬에서는 일반적으로 <strong>deque</strong>를 이용해서 큐를 구현한다.
  </li>
</ul>

<h4>파이썬의 큐</h4>
<ul>
  <li>
    위치
  </li>
    <ul>
      <li>
        <strong>rear</strong>: 큐에서 가장 끝 데이터를 가리키는 영역
      </li>
      <li>
        <strong>front</strong>: 큐에서 가장 앞의 데이터를 가리키는 영역
      </li>
    </ul>
  <li>
    연산(리스트 이름이 s일 때)
  </li>
    <ul>
      <li>
        <strong>s.append(data)</strong>: rear 부분에 새로운 데이터를 삽입하는 연산
      </li>
      <li>
        <strong>s.popleft()</strong>: front 부분에 있는 데이터를 삭제하고 확인하는 연산
      </li>
      <li>
        <strong>s[0]</strong>: 큐의 맨 앞(front)에 있는 데이터를 확인할 때 사용하는 연산.
      </li>
    </ul>
  <li>
    큐는 <strong>너비 우선 탐색(BFS: Breadth First Search)</strong>에서 자주 사용하기에 알아 두어야 한다.
  </li>
</ul>

```python
# 스택으로 수열 만들기 - 1874
N = int(input())
A = [0] * N

for i in range(N):
    A[i] = int(input())
  
stack = []
num = 1
result = True
answer = []

for i in range(N):
    su = A[i]
    
    # 현재 수열값 >= 오름차순 자연수 - 값이 같아질 때까지 append() 수행
    if su >= num:
        while su >= num:
            stack.append(num)
            num += 1
            answer.append('+')
        stack.pop()
        answer.append('-')
    # 현재 수열값 < 오름차순 자연수: pop()을 수행해 수열 원소를 꺼냄
    else:
        n = stack.pop()
        # 스택의 가장 위의 수가 만들어야 하는 수열의 수보다 크면 수열을 출력할 수 없다.
        if n > su:
            print("NO")
            result = False
            break
        else:
            answer.append('-')

if result:
    for i in answer:
        print(i)
```