<h1>1. 그리디 알고리즘</h1>
<ul>
  <li>
    <strong>그리디(greedy) 알고리즘</strong>은 <strong>현재 상태</strong>에서 보는 선택지 중 최선의 선택지가 전체 선택지 중의 최선의 선택지라 가정하는 알고리즘이다.
  </li>
</ul>

<br>

<h2>1-1. 그리디 알고리즘의 핵심 이론</h2>
<ul>
  <li>
    그리디 알고리즘 수행 과정
  </li>
    <ul>
      <li>
        1. 해 선택: 현재 상태에서 가장 최선이라 생각되는 해를 선택한다.
        <br>→ 2. 적절성 검사: 현재 선택한 해가 전체 문제의 제약 조건에 벗어나지 않는지 검사한다.
        <br>→ 3. 해 검사: 현재까지 선택한 해 집합이 전체 문제를 해결할 수 있는지 검사한다.
        <br>→ 4. 전체 문제를 해결하지 못한다면 1번으로 돌아가 반복한다.
      </li>
    </ul>
</ul>

```python
# 동전 개수의 최솟값 구하기 - 11047
N, K =  map(int, input().split())
A = [0] * N

for i in range(N):
    A[i] = int(input())

count = 0

for i in range(N - 1, -1, -1):
    # 현재 동전의 가치가 K보다 작거나 같으면 구성에 추가
    if A[i] <= K:
        count += int(K / A[i])
        # K를 현재 동전을 사용하고 남은 급액으로 갱신
        K = K % A[i]

print(count)
```

<br>

<h2>1-2. 그리디 알고리즘에서 자주 사용하는 자료구조 우선순위 큐</h2>
<ul>
  <li>
    파이썬에서는 <strong>우선순위 큐</strong> 자료구조를 <strong>PriorityQueue</strong> 혹은 <strong>heapq</strong>로 구현한다.
  </li>
  <li>
    <strong>PriorityQueue</strong>는 <strong>객체 자체</strong>를 우선순위 큐로 만들어 사용하는 반면, <strong>heapq</strong>는 기본적인 list 객체를 대상으로 <strong>함수</strong>를 통해 우선순위 큐를 구현한다.
  </li>
</ul>

```python
# 1. PriorityQueue-----------------------------
from queue import PriorityQueue

# myque를 우선순위 큐로 생성.
myque = PriorityQueue()

# 기본 함수
put(data)        # 원소 추가
get()            # 큐에서 데이터 꺼내기
qsize()          # 큐 사이즈 가져오기
empty()          # 큐가 비어 있는지 확인

# 2. heapq-------------------------------------
import heapq

# heapq 생성
mylist = [] # 리스트 생성
heapq.heappush(mylist, 1) # 리스트에 데이터를 넣을 때 heapq를 이용해 저장.

# 기본 함수
heappush(mylist, data)    # data를 list(heap 자료구조) 형태로 저장
heappop(mylist)           # list(heap 자료구조)에서 데이터 꺼내기
heapify(mylist)           # 일반적인 list를 heap 자료구조로 변환
```

```python
# 카드 정렬하기 - 1715
from queue import PriorityQueue
N = int(input())
pq = PriorityQueue()

for _ in range(N):
    data = int(input())
    pq.put(data)

data1 = 0
data2 = 0
sum = 0

while pq.qsize() > 1:
    data1 = pq.get()
    data2 = pq.get()
    temp = data1 + data2
    sum += temp
    pq.put(temp)

print(sum)
```

```python
# 수를 묶어서 최댓값 만들기 - 1744
import heapq

# 입력값 받기
N = int(sys.stdin.readline())
# 각 원소를 영역 별로 분할하여 저장한다.
num_pos = []
num_neg = []
one = 0
zero = 0

for i in range(N):
    data = int(sys.stdin.readline())

    # 1보다 큰 양수 원소인 경우
    #   - heapq는 오름차순 정렬이기에 -1을 곱해 가장 큰 양의 수가 첫 번째 원소가 되게 한다.
    if data > 1:
        heapq.heappush(num_pos, data * -1)

    # 1인 원소의 수를 저장한다.
    elif data == 1:
        one += 1
    
    # 0인 원소의 수를 저장한다.
    elif data == 0:
        zero += 1
    
    # 위의 경우가 아닌 경우는 음수이기에 음의 리스트에 입력한다.
    else:
        heapq.heappush(num_neg, data)

# 누적합 변수 초기화
sum = 0

# 양수 처리
while len(num_pos) > 1:
    first = heappop(num_pos) * -1
    second = heappop(num_pos) * -1
    sum += first * second

# 모두 처리하고 하나가 남은 경우 그대로 더해준다.
#   - 1 초과의 양수는 '음수, -1, 0, 1' 어떤 것과도 곱해질 수 없다.
if len(num_pos) > 0:
    sum += heapq.heappop(num_pos) * -1

# 음수 처리
while len(num_neg) > 1:
    first = heapq.heappop(num_neg)
    second = heapq.heappop(num_neg)
    sum += first * second

# 마찬가지로 음수가 남았다면 다음을 처리한다.
if len(num_neg) > 1:
    # 0이 없는 경우 음수가 상쇄되지 않기에 더한다.
    if zero == 0:
        sum += heapq.heappop(num_neg)

# 마지막으로 1의 개수를 더한다.
sum += one

print(sum)
```

```python
# 회의실 배정하기 - 1931
#   - 나는 start와 end의 차이 즉, 가장 회의 시간이 적은 것이 우선이라 생각.
#     → 풀이는 end 시간을 기준으로 오름차순 정렬.
N = int(input())
# A의 sample
#   [[0, 0],
#    [0, 0],
#     .... ,
#           ]
A = [[0] * 2 for _ in range(N)]

# 시작점과 끝점 받기
for i in range(N):
    S, E = map(int, input().split())
    # 종료 시각이 우선 정렬이기에 
    A[i][0] = E
    A[i][1] = S

# 종료점([i][0]) 먼저 정렬 후 시작점([i][1])으로 정렬
A.sort()
count = 0
end = -1

# 전체를 순회하면서 회의 횟수 체크
for i in range(N):
    # 겹치지 않는 다음 회의가 나온 경우
    if A[i][1] >= end:
        # 종료 시각을 업데이트
        end = A[i][0]
        count += 1

print(count)
```

```python
# 최솟값을 만드는 괄호 배치 찾기 - 1541

```