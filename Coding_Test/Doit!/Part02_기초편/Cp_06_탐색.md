<h1>1. 깊이 우선 탐색</h1>
<ul>
  <li>
    <strong>깊이 우선 탐색(depth-first search, DFS)</strong>은 그래프 완전 탐색 기법 중 하나입니다.
  </li>
  <li>
    깊이 우선 탐색은 그래프의 시작 노드에서 출발하여 탐색할 한 쪽 분기를 정하여 <strong>최대 깊이</strong>까지 탐색을 마친 후 다른 쪽 분기로 이동하여 다시 탐색을 진행하는 알고리즘이다.
  </li>
  <li>
    깊이 우선 탐색의 노드의 수를 V, 에지의 수를 E로 표현하는 경우 시간 복잡도는 O(V + E) 이다.
  </li>
  <li>
    DFS는 <strong>재귀 함수</strong> 혹은 <strong>스택 자료구조</strong>로 구현한다.
  </li>
    <ul>
      <li>
        구현 시에 재귀 함수를 사용할 경우 스택 오버플로(stack overflow)를 유의해야 한다.
      </li>
    </ul>
  <li>
    DFS를 사용해 풀 수 있는 문제로는 단절점 찾기, 단절선 찾기, 사이클 찾기, 위상 정렬 등이 있다.
  </li>
</ul>

<br>

<h2>1-1. 깊이 우선 탐색의 핵심 이론</h2>
<ul>
  <li>
    DFS는 한 번 방문한 노드를 다시 방문하면 안 되기에 <strong>노드 방문 여부</strong>를 체크할 리스트가 필요하다.
  </li>
  <li>
    DFS는 <strong>후입선출</strong> 특성을 가지므로 스택을 사용하여 설명한다.
  </li>
  <li>
    1. DFS를 시작할 노드를 정한 후 사용할 자료구조 초기화
    <br>→ 2. 스택에서 노드를 꺼낸 후 꺼낸 노드의 인접 노드를 다시 스택에 삽입.
    <br>→ 3. 스택 자료구조에 값이 없을 때까지 반복한다.
  </li>
</ul>

```python
# 연결 요소의 개수 구하기 - 11724
# 변수 초기화
import sys
sys.setrecursionlimit(10000)
input = sys.stdin.readline
n, m = map(int, input().split())
A = [[] for _ in range(n+1)]
visited = [False] * (n+1)

# DFS 로직
def DFS(v):
    
    # 현재 방문한  node 체크
    visited[v] = True

    # 해당 노드 v의 자식 노드를 순회하며 DFS를 수행.
    for i in A[v]:
        if not visited[i]:
            DFS(i)

# 양방향 그래프 구현
for _ in range(m):
    s, e = map(int, input().split())
    A[s].append(e)
    A[e].append(s)

count = 0

# 연결 노드 중 방문하지 않은 노드만 탐색.
for i in range(1, n + 1):
    if not visited[i]:
        count += 1
        DFS(i)

print(count)
```

```python
# 신기한 소수 찾기 - 2023
#   - 보통 소수를 찾는 문제에 `에라토스테네스의 체`를 사용하지만 현재 문제에는 
#     해당하지 않는다.
import sys
sys.setrecursionlimit(10000)
input = sys.stdin.readline
N = int(input())

# 소수 확인 함수
def isPrime(num):
    # 2 이상 자기 자신의 1/2이하의 수를 직접 확인
    #   - num / 2 보다 큰 수는 2 이상을 곱해서 만들 수 없음.
    for i in range(2, int(num / 2 + 1)):
        if num % i == 0:
            return False
    return True

# DFS 함수
#   - 첫 번째 숫자만 주어진다.
#   - 이후 뒤에 수를 붙여 나가면서 확인하는 방식. 
def DFS(number):
    if len(str(number)) == N:
        print(number)
    else:
        for i in range(1, 10):
            
            # 짝수는 소수가 아니기에 skip
            if i % 2 == 0:
                continue

            # 소수 확인
            #   - 나의 경우 네 자리수 몫을 사용
            #     → 풀이에서는 미리 몫을 만들고 더하는 방식 활용.
            #     → 내 풀이는 index 관리가 어려웠기에 풀이가 더 나은 것 같다.
            if isPrime(number * 10 + i):
                DFS(number * 10 + i)

# 일의 자리가 소수인 수만 탐색
DFS(2)
DFS(3)
DFS(5)
DFS(7)
```

```python
# 친구 관계 파악하기 - 13023
import sys
sys.setrecursionlimit(10000)
input = sys.stdin.readline
N, M = map(int, input().split())
arrive = False
A = [[] for _ in range(N + 1)]
visited = [False] * (N + 1)

def DFS(now, depth):
    global arrive

    # 깊이가 5가 되면 더이상 탐색 불필요
    if depth == 5:
        # 찾는 그래프임을 표시
        arrive = True
        return
    
    # 방문 체크
    visited[now] = True

    # 자식 노드 탐색
    for i in A[now]:
        
        # 방문 안한 자식이라면 DFS
        if not visited[i]:
            DFS(i, depth + 1)
    
    # 특정 노드의 탐색이 끝났다면 방문 해제
    #   - 다음 노드의 탐색을 위해.
    visited[now] = False

# 양방향 그래프 구현
for _ in range(M):
    s, e = map(int, input().split())
    A[s].append(e)
    A[e].append(s)

# 모든 노드에 대해 DFS 탐색 시작
for i in range(N):
    DFS[i, 1]
    # 이미 패턴 발견했다면 종료
    if arrive:
        break

# 출력부 구현
# 찾는 그래프라면 1을,
if arrive:
    print(1)
# 아니라면 0을 출력.
else:
    print(0)
```

<br><br>

<h1>2. 백트래킹</h1>
<ul>
  <li>
    백트래킹(backtracking)은 문제를 해결하는 탐색 기법이다. 문제를 해결할 수 있는 <strong>모든 경로</strong>를 탐색하며 선택한 경로가 <strong>유효하지 않거나 조건에 만족하는 해를 찾지 못할 경우</strong> 이전 단계로 돌아가 다른 경로를 탐색한다.
  </li>
  <li>
    백트래킹은 일반적으로 <strong>재귀 함수</strong> 형태로 구현하며 DFS와 개념과 구현 방식이 매우 유사하다.
  </li>
  <li>
    가장 큰 특징은 <strong>가치치기(pruning)</strong>로 유효하지 않은 경로를 조기에 배제하여 탐색 범위를 줄이고 성능을 높일 수 있다.
  </li>
    <ul>
      <li>
        굳이 차이를 두면 DFS는 모든 노드 탐색을, 백트래킹은 조건에 만족하는 해를 찾는 것을 목표로 한다.
      </li>
    </ul>
  <li>
    시간 복잡도는 <strong>O(N^d)</strong>이다.
  </li>
    <ul>
      <li>
        <strong>N</strong>: 분기 수
      </li>
      <li>
        <strong>d</strong>: 탐색 깊이
      </li>
    </ul>
  <li>
    백트래킹을 활용하는 대표적인 문제로는 조합, 순열, N-Queens 문제 등이 있다.
  </li>
</ul>

<br>

<h2>2-1. 백트래킹 핵심 이론</h2>
<ul>
  <li>
    1. 가능한 선택지 탐색하기.
    <br>→ 2. 유효성 검사 및 가지치기
    <br>→ 3. 해답 도출하기.
  </li>
</ul>

```python
# N과 M - 15649
N, M = map(int, input().split())
# 수열을 저장할 리스트
S = [0] * M
# 숫자 사용 여부 저장 리스트
visited = [False] * N

def backtrack(length):
    if length == M:
        print(' '.join(str(x + 1) for x in S))
        return

    for i in range(N):
        if not visited[i]:
            visited[i] = True
            S[length] = i
            backtrack(length + 1)
            # 백 트래킹 수 반납
            visited[i] = False

bracktrack(0)
```

```python
# N-Queen - 9663
import sys
input = sys.stdin.read
sys.setrecursionlimit(10**6)

N = int(input())
cnt = 0

# 열 충돌 체크
cols = [False] * N
# 위 대각선 체크
diag1 = [False] * (2 * N - 1)
# 아래 대각선 체크
diag2 = [False] * (2 * N - 1)

def backtrack(row):
    global cnt
    if row == N:
        cnt += 1
        return
    for col in range(N):
        # row + col과 row - col + N - 1은 각각 대각선의 번호
        if not cols[col] and not diag1[row + col] and not diag2[row - col + N - 1]:
            col[col] = diag[row + col] = diag2[row - col + N - 1] = True
            backtrack(row + 1)
            cols[col] = diag1[row + col] = diag2[row - col + N - 1] = False

backtrack(0)
print(cnt)
```

```python
import sys
input = sys.stdin.readline
sys.setrecursion(10**6)

# 종이 데이터 입력받기
M = [list(map(int, input().split())) for _ in range(10)]

# 색종이 수(크기 1 ~ 5 각각 최대 5장)
S = [0, 5, 5, 5, 5, 5]
result = float('inf')

def fill(x, y, size, value):
    for i in range(y, y + size):
        for j in range(x, x + size):
            M[i][j] = value

def check(x, y, size):
    if x + size > 10 or y + size > 10:
        return False
    for i in range(y, y + size):
        for j in range(x, x + size):
            if M[i][j] != 1:
                return False
    return True

def backtrack(pos, used):
    global result
    if pos == 100:
        result = min(result, used)
        return
    if used >= result:
        return
    # x: 열, y: 행
    x, y = divmod(pos, 10)
    if M[y][x] == 1:
        for size in range(5, 0, -1):
            if S[size] > 0 and check(x, y, size):
                S[size] -= 1
                fill(x, y, size, 0)
                backtrack(pos + 1, used + 1)
                fill(x, y, size, 1)
                S[size] += 1
    else:
        backtrack(pos + 1, used)

backtrack(0, 0)
print(result if result != float('inf') else -1)
```

<br><br>

<h1>3. 너비 우선 탐색</h1>
<ul>
  <li>
    <strong>너비 우선 탐색(breadth-first search, BFS)</strong>도 완전 탐색 방법 중 하나로 시작 노드에서 출발해 <strong>가까운 노드를 먼저 방문</strong>하면서 탐색하는 알고리즘이다.
  </li>
  <li>
    너비 우선 탐색은 <strong>선입선출(FIFO)</strong> 방식으로 탐색하며 <strong>큐(Queue)</strong>를 이용해 구현한다.
  </li>
  <li>
    시작 노드와 가까운 노드를 우선 탐색하기에 목표 노드에 도착하는 경로가 여러 개일 때 <strong>최단 경로</strong>를 보장한다.
  </li>
</ul>

<br>

<h2>3-1. 너비 우선 탐색의 핵심 이론</h2>
<ul>
  <li>
    1. BFS를 시작할 노드를 정한 후 사용할 자료구조 초기화
    <br>→ 큐에서 노드를 꺼낸 후 꺼낸 노드의 인접 노드를 다시 큐에 삽입한다.
    <br>→ 큐 자료구조에 값이 없을 때까지 반복한다.
  </li>
</ul>

```python
# DFS와 BFS - 1260
from collections import deque
N, M, Start = map(int, lnput().split())
A = [[] for _ in range(N + 1)]

# 양방향 graph 구현
for _ in range(M):
    s, e = map(int, input().split())
    A[s].append(e)
    A[e].append(s)

# 작은 번호부터 탐색하기 위해 정렬
for i in range(N + 1):
    A[i].sot()

def DFS(v):
    print(v, end=' ')
    visited[v] = True
    for i in A[v]:
        if not visited[i]:
            DFS(i)

visited = [False] * (N + 1)
DFS(Start)

def BFS(v):
    queue = deque()
    queue.append(v)
    visited[v] = True
    while queue:
        now_Node = queue.popleft()
        print(now_Node, end=' ')
        for i in A[now_Node]:
            visited[i] = True
            queue.append(i)

print()
# 방문 리스트 초기화
visited = [False] * (N + 1)
BFS(start)
```

```python
# 미로 탐색하기 - 2178
from collections import deque

# 델타탐색
dx = [0, 1, 0, -1]
dy = [1, 0, -1, 0]
N, M = map(int, input().split())
A = [[0] * M for _ in range(N)]
visited = [[False] * M for _ in range(N)]

for i in range(N):
    numbers = list(input())
    for j in range(M):
        A[i][j] = int(numbers[j])

def BFS(i, j):
    queue = deque()
    queue.append((i, j))
    visited[i][j] = True

    while queue:
        now = queue.popleft()
        for j in range(4):
            x = now[0] + dx[k]
            y = now[1] + dy[k]
            # 좌표 유효성 검사
            if x >= 0 and y >= 0 and x < N and y < M:
                if A[x][y] != 0 and not visited[x][y]:
                    # visited에 누적 거리를 계산하여 관리
                    visited[x][y] = True
                    A[x][y] = A[now[0]][now[1]] + 1
                    queue.append((x, y))

BFS(0, 0)
print(A[N - 1][M - 1])
```