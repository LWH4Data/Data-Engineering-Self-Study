<h1>1. 깊이 우선 탐색</h1>
<ul>
  <li>
    <strong>깊이 우선 탐색(depth-first search, DFS)</strong>은 그래프 완전 탐색 기법 중 하나입니다.
  </li>
  <li>
    깊이 우선 탐색은 그래프의 시작 노드에서 출발하여 탐색할 한 쪽 분기를 정하여 <strong>최대 깊이</strong>까지 탐색을 마친 후 다른 쪽 분기로 이동하여 다시 탐색을 진행하는 알고리즘이다.
  </li>
  <li>
    깊이 우선 탐색의 노드의 수를 V, 에지의 수를 E로 표현하는 경우 시간 복잡도는 O(V + E) 이다.
  </li>
  <li>
    DFS는 <strong>재귀 함수</strong> 혹은 <strong>스택 자료구조</strong>로 구현한다.
  </li>
    <ul>
      <li>
        구현 시에 재귀 함수를 사용할 경우 스택 오버플로(stack overflow)를 유의해야 한다.
      </li>
    </ul>
  <li>
    DFS를 사용해 풀 수 있는 문제로는 단절점 찾기, 단절선 찾기, 사이클 찾기, 위상 정렬 등이 있다.
  </li>
</ul>

<br>

<h2>1-1. 깊이 우선 탐색의 핵심 이론</h2>
<ul>
  <li>
    DFS는 한 번 방문한 노드를 다시 방문하면 안 되기에 <strong>노드 방문 여부</strong>를 체크할 리스트가 필요하다.
  </li>
  <li>
    DFS는 <strong>후입선출</strong> 특성을 가지므로 스택을 사용하여 설명한다.
  </li>
  <li>
    1. DFS를 시작할 노드를 정한 후 사용할 자료구조 초기화
    <br>→ 2. 스택에서 노드를 꺼낸 후 꺼낸 노드의 인접 노드를 다시 스택에 삽입.
    <br>→ 3. 스택 자료구조에 값이 없을 때까지 반복한다.
  </li>
</ul>

```python
# 연결 요소의 개수 구하기 - 11724
# 변수 초기화
import sys
sys.setrecursionlimit(10000)
input = sys.stdin.readline
n, m = map(int, input().split())
A = [[] for _ in range(n+1)]
visited = [False] * (n+1)

# DFS 로직
def DFS(v):
    
    # 현재 방문한  node 체크
    visited[v] = True

    # 해당 노드 v의 자식 노드를 순회하며 DFS를 수행.
    for i in A[v]:
        if not visited[i]:
            DFS(i)

# 양방향 그래프 구현
for _ in range(m):
    s, e = map(int, input().split())
    A[s].append(e)
    A[e].append(s)

count = 0

# 연결 노드 중 방문하지 않은 노드만 탐색.
for i in range(1, n + 1):
    if not visited[i]:
        count += 1
        DFS(i)

print(count)
```

```python
# 신기한 소수 찾기 - 2023
#   - 보통 소수를 찾는 문제에 `에라토스테네스의 체`를 사용하지만 현재 문제에는 
#     해당하지 않는다.
import sys
sys.setrecursionlimit(10000)
input = sys.stdin.readline
N = int(input())

# 소수 확인 함수
def isPrime(num):
    # 2 이상 자기 자신의 1/2이하의 수를 직접 확인
    #   - num / 2 보다 큰 수는 2 이상을 곱해서 만들 수 없음.
    for i in range(2, int(num / 2 + 1)):
        if num % i == 0:
            return False
    return True

# DFS 함수
#   - 첫 번째 숫자만 주어진다.
#   - 이후 뒤에 수를 붙여 나가면서 확인하는 방식. 
def DFS(number):
    if len(str(number)) == N:
        print(number)
    else:
        for i in range(1, 10):
            
            # 짝수는 소수가 아니기에 skip
            if i % 2 == 0:
                continue

            # 소수 확인
            #   - 나의 경우 네 자리수 몫을 사용
            #     → 풀이에서는 미리 몫을 만들고 더하는 방식 활용.
            #     → 내 풀이는 index 관리가 어려웠기에 풀이가 더 나은 것 같다.
            if isPrime(number * 10 + i):
                DFS(number * 10 + i)

# 일의 자리가 소수인 수만 탐색
DFS(2)
DFS(3)
DFS(5)
DFS(7)
```