<h1>1. 깊이 우선 탐색</h1>
<ul>
  <li>
    <strong>깊이 우선 탐색(depth-first search, DFS)</strong>은 그래프 완전 탐색 기법 중 하나입니다.
  </li>
  <li>
    깊이 우선 탐색은 그래프의 시작 노드에서 출발하여 탐색할 한 쪽 분기를 정하여 <strong>최대 깊이</strong>까지 탐색을 마친 후 다른 쪽 분기로 이동하여 다시 탐색을 진행하는 알고리즘이다.
  </li>
  <li>
    깊이 우선 탐색의 노드의 수를 V, 에지의 수를 E로 표현하는 경우 시간 복잡도는 O(V + E) 이다.
  </li>
  <li>
    DFS는 <strong>재귀 함수</strong> 혹은 <strong>스택 자료구조</strong>로 구현한다.
  </li>
    <ul>
      <li>
        구현 시에 재귀 함수를 사용할 경우 스택 오버플로(stack overflow)를 유의해야 한다.
      </li>
    </ul>
  <li>
    DFS를 사용해 풀 수 있는 문제로는 단절점 찾기, 단절선 찾기, 사이클 찾기, 위상 정렬 등이 있다.
  </li>
</ul>

<br>

<h2>1-1. 깊이 우선 탐색의 핵심 이론</h2>
<ul>
  <li>
    DFS는 한 번 방문한 노드를 다시 방문하면 안 되기에 <strong>노드 방문 여부</strong>를 체크할 리스트가 필요하다.
  </li>
  <li>
    DFS는 <strong>후입선출</strong> 특성을 가지므로 스택을 사용하여 설명한다.
  </li>
  <li>
    1. DFS를 시작할 노드를 정한 후 사용할 자료구조 초기화
    <br>→ 2. 스택에서 노드를 꺼낸 후 꺼낸 노드의 인접 노드를 다시 스택에 삽입.
    <br>→ 3. 스택 자료구조에 값이 없을 때까지 반복한다.
  </li>
</ul>

```python
# 연결 요소의 개수 구하기 - 11724
# 변수 초기화
import sys
sys.setrecursionlimit(10000)
input = sys.stdin.readline
n, m = map(int, input().split())
A = [[] for _ in range(n+1)]
visited = [False] * (n+1)

# DFS 로직
def DFS(v):
    
    # 현재 방문한  node 체크
    visited[v] = True

    # 해당 노드 v의 자식 노드를 순회하며 DFS를 수행.
    for i in A[v]:
        if not visited[i]:
            DFS(i)

# 양방향 그래프 구현
for _ in range(m):
    s, e = map(int, input().split())
    A[s].append(e)
    A[e].append(s)

count = 0

# 연결 노드 중 방문하지 않은 노드만 탐색.
for i in range(1, n + 1):
    if not visited[i]:
        count += 1
        DFS(i)

print(count)
```

```python
# 신기한 소수 찾기 - 2023
#   - 보통 소수를 찾는 문제에 `에라토스테네스의 체`를 사용하지만 현재 문제에는 
#     해당하지 않는다.
import sys
sys.setrecursionlimit(10000)
input = sys.stdin.readline
N = int(input())

# 소수 확인 함수
def isPrime(num):
    # 2 이상 자기 자신의 1/2이하의 수를 직접 확인
    #   - num / 2 보다 큰 수는 2 이상을 곱해서 만들 수 없음.
    for i in range(2, int(num / 2 + 1)):
        if num % i == 0:
            return False
    return True

# DFS 함수
#   - 첫 번째 숫자만 주어진다.
#   - 이후 뒤에 수를 붙여 나가면서 확인하는 방식. 
def DFS(number):
    if len(str(number)) == N:
        print(number)
    else:
        for i in range(1, 10):
            
            # 짝수는 소수가 아니기에 skip
            if i % 2 == 0:
                continue

            # 소수 확인
            #   - 나의 경우 네 자리수 몫을 사용
            #     → 풀이에서는 미리 몫을 만들고 더하는 방식 활용.
            #     → 내 풀이는 index 관리가 어려웠기에 풀이가 더 나은 것 같다.
            if isPrime(number * 10 + i):
                DFS(number * 10 + i)

# 일의 자리가 소수인 수만 탐색
DFS(2)
DFS(3)
DFS(5)
DFS(7)
```

```python
# 친구 관계 파악하기 - 13023
import sys
sys.setrecursionlimit(10000)
input = sys.stdin.readline
N, M = map(int, input().split())
arrive = False
A = [[] for _ in range(N + 1)]
visited = [False] * (N + 1)

def DFS(now, depth):
    global arrive

    # 깊이가 5가 되면 더이상 탐색 불필요
    if depth == 5:
        # 찾는 그래프임을 표시
        arrive = True
        return
    
    # 방문 체크
    visited[now] = True

    # 자식 노드 탐색
    for i in A[now]:
        
        # 방문 안한 자식이라면 DFS
        if not visited[i]:
            DFS(i, depth + 1)
    
    # 특정 노드의 탐색이 끝났다면 방문 해제
    #   - 다음 노드의 탐색을 위해.
    visited[now] = False

# 양방향 그래프 구현
for _ in range(M):
    s, e = map(int, input().split())
    A[s].append(e)
    A[e].append(s)

# 모든 노드에 대해 DFS 탐색 시작
for i in range(N):
    DFS[i, 1]
    # 이미 패턴 발견했다면 종료
    if arrive:
        break

# 출력부 구현
# 찾는 그래프라면 1을,
if arrive:
    print(1)
# 아니라면 0을 출력.
else:
    print(0)
```

<br><br>

<h1>2. 백트래킹</h1>
<ul>
  <li>
    백트래킹(backtracking)은 문제를 해결하는 탐색 기법이다. 문제를 해결할 수 있는 <strong>모든 경로</strong>를 탐색하며 선택한 경로가 <strong>유효하지 않거나 조건에 만족하는 해를 찾지 못할 경우</strong> 이전 단계로 돌아가 다른 경로를 탐색한다.
  </li>
  <li>
    백트래킹은 일반적으로 <strong>재귀 함수</strong> 형태로 구현하며 DFS와 개념과 구현 방식이 매우 유사하다.
  </li>
  <li>
    가장 큰 특징은 <strong>가치치기(pruning)</strong>로 유효하지 않은 경로를 조기에 배제하여 탐색 범위를 줄이고 성능을 높일 수 있다.
  </li>
    <ul>
      <li>
        굳이 차이를 두면 DFS는 모든 노드 탐색을, 백트래킹은 조건에 만족하는 해를 찾는 것을 목표로 한다.
      </li>
    </ul>
  <li>
    시간 복잡도는 <strong>O(N^d)</strong>이다.
  </li>
    <ul>
      <li>
        <strong>N</strong>: 분기 수
      </li>
      <li>
        <strong>d</strong>: 탐색 깊이
      </li>
    </ul>
  <li>
    백트래킹을 활용하는 대표적인 문제로는 조합, 순열, N-Queens 문제 등이 있다.
  </li>
</ul>

<br>

<h2>2-1. 백트래킹 핵심 이론</h2>
<ul>
  <li>
    1. 가능한 선택지 탐색하기.
    <br>→ 2. 유효성 검사 및 가지치기
    <br>→ 3. 해답 도출하기.
  </li>
</ul>

```python
# N과 M - 15649
N, M = map(int, input().split())
# 수열을 저장할 리스트
S = [0] * M
# 숫자 사용 여부 저장 리스트
visited = [False] * N

def backtrack(length):
    if length == M:
        print(' '.join(str(x + 1) for x in S))
        return

    for i in range(N):
        if not visited[i]:
            visited[i] = True
            S[length] = i
            backtrack(length + 1)
            # 백 트래킹 수 반납
            visited[i] = False

bracktrack(0)
```

```python
# N-Queen - 9663
import sys
input = sys.stdin.read
sys.setrecursionlimit(10**6)

N = int(input())
cnt = 0

# 열 충돌 체크
cols = [False] * N
# 위 대각선 체크
diag1 = [False] * (2 * N - 1)
# 아래 대각선 체크
diag2 = [False] * (2 * N - 1)

def backtrack(row):
    global cnt
    if row == N:
        cnt += 1
        return
    for col in range(N):
        # row + col과 row - col + N - 1은 각각 대각선의 번호
        if not cols[col] and not diag1[row + col] and not diag2[row - col + N - 1]:
            col[col] = diag[row + col] = diag2[row - col + N - 1] = True
            backtrack(row + 1)
            cols[col] = diag1[row + col] = diag2[row - col + N - 1] = False

backtrack(0)
print(cnt)
```

```python
import sys
input = sys.stdin.readline
sys.setrecursion(10**6)

# 종이 데이터 입력받기
M = [list(map(int, input().split())) for _ in range(10)]

# 색종이 수(크기 1 ~ 5 각각 최대 5장)
S = [0, 5, 5, 5, 5, 5]
result = float('inf')

def fill(x, y, size, value):
    for i in range(y, y + size):
        for j in range(x, x + size):
            M[i][j] = value

def check(x, y, size):
    if x + size > 10 or y + size > 10:
        return False
    for i in range(y, y + size):
        for j in range(x, x + size):
            if M[i][j] != 1:
                return False
    return True

def backtrack(pos, used):
    global result
    if pos == 100:
        result = min(result, used)
        return
    if used >= result:
        return
    # x: 열, y: 행
    x, y = divmod(pos, 10)
    if M[y][x] == 1:
        for size in range(5, 0, -1):
            if S[size] > 0 and check(x, y, size):
                S[size] -= 1
                fill(x, y, size, 0)
                backtrack(pos + 1, used + 1)
                fill(x, y, size, 1)
                S[size] += 1
    else:
        backtrack(pos + 1, used)

backtrack(0, 0)
print(result if result != float('inf') else -1)
```

<br><br>

<h1>3. 너비 우선 탐색</h1>
<ul>
  <li>
    <strong>너비 우선 탐색(breadth-first search, BFS)</strong>도 완전 탐색 방법 중 하나로 시작 노드에서 출발해 <strong>가까운 노드를 먼저 방문</strong>하면서 탐색하는 알고리즘이다.
  </li>
  <li>
    너비 우선 탐색은 <strong>선입선출(FIFO)</strong> 방식으로 탐색하며 <strong>큐(Queue)</strong>를 이용해 구현한다.
  </li>
  <li>
    시작 노드와 가까운 노드를 우선 탐색하기에 목표 노드에 도착하는 경로가 여러 개일 때 <strong>최단 경로</strong>를 보장한다.
  </li>
</ul>

<br>

<h2>3-1. 너비 우선 탐색의 핵심 이론</h2>
<ul>
  <li>
    1. BFS를 시작할 노드를 정한 후 사용할 자료구조 초기화
    <br>→ 큐에서 노드를 꺼낸 후 꺼낸 노드의 인접 노드를 다시 큐에 삽입한다.
    <br>→ 큐 자료구조에 값이 없을 때까지 반복한다.
  </li>
</ul>

```python
# DFS와 BFS - 1260
from collections import deque
N, M, Start = map(int, lnput().split())
A = [[] for _ in range(N + 1)]

# 양방향 graph 구현
for _ in range(M):
    s, e = map(int, input().split())
    A[s].append(e)
    A[e].append(s)

# 작은 번호부터 탐색하기 위해 정렬
for i in range(N + 1):
    A[i].sot()

def DFS(v):
    print(v, end=' ')
    visited[v] = True
    for i in A[v]:
        if not visited[i]:
            DFS(i)

visited = [False] * (N + 1)
DFS(Start)

def BFS(v):
    queue = deque()
    queue.append(v)
    visited[v] = True
    while queue:
        now_Node = queue.popleft()
        print(now_Node, end=' ')
        for i in A[now_Node]:
            visited[i] = True
            queue.append(i)

print()
# 방문 리스트 초기화
visited = [False] * (N + 1)
BFS(start)
```

```python
# 미로 탐색하기 - 2178
from collections import deque

# 델타탐색
dx = [0, 1, 0, -1]
dy = [1, 0, -1, 0]
N, M = map(int, input().split())
A = [[0] * M for _ in range(N)]
visited = [[False] * M for _ in range(N)]

for i in range(N):
    numbers = list(input())
    for j in range(M):
        A[i][j] = int(numbers[j])

def BFS(i, j):
    queue = deque()
    queue.append((i, j))
    visited[i][j] = True

    while queue:
        now = queue.popleft()
        for j in range(4):
            x = now[0] + dx[k]
            y = now[1] + dy[k]
            # 좌표 유효성 검사
            if x >= 0 and y >= 0 and x < N and y < M:
                if A[x][y] != 0 and not visited[x][y]:
                    # visited에 누적 거리를 계산하여 관리
                    visited[x][y] = True
                    A[x][y] = A[now[0]][now[1]] + 1
                    queue.append((x, y))

BFS(0, 0)
print(A[N - 1][M - 1])
```

```python
# 트리의 지름 구하기 - 1167
from collections import deque

N = int(input())
A = [[] for _ in range(N + 1)]

for _ in range(N):
    Data = list(map(int, input().split()))
    index = 0
    S = Data[index]
    index += 1
    while True:
        E = Data[index]
        if E == -1:
            break
        V = Data[index + 1]
        A[S].append((E, V))
        index += 2

distance = [0] * (N + 1)
visited = [False] * (N + 1)

def BFS(v):
    queue = deque()
    queue.append(v)
    visited[v] = True
    while queue:
        now_Node - queue.popleft()
        for _ in A[now_Node]:
            if not visited[i[0]]:
                visited[i[0]] = True
                queue.append(i[0])
                distance[i[0]] = distance[now_Node] + i[1]

BFS(1)
Max = 1

for i in range(2, N + 1):
    if distance[Max] < distance[i]:
        Max = i

distance = [0] * (N + 1)
visited = [False] * (N + 1)
BFS(Max)
distance.sort()
print(distance[N])
```

<br><br>

<h1>4. 이진 탐색</h1>
<ul>
  <li>
    <strong>이진 탐색(binary search)</strong>은 데이터가 <strong>정렬돼 있는 상태</strong>에서 <strong>중앙값과 찾고자 하는 값</strong>을 비교해 데이터의 크기를 <strong>절반씩</strong> 줄이면서 탐색하는 방법이다.
  </li>
  <li>
    시간 복잡도는 <strong>O(logN)</strong>이다.
  </li>
  <li>
    정렬 데이터에서 원하는 데이터를 탐색할 떄 사용하는 가장 일반적인 알고리즘이다.
  </li>
</ul>

<br>

<h2>4-1. 이진 탐색의 핵심 이론</h2>
<ul>
  <li>
    1. 현재 데이터셋의 <strong>중앙값(median)</strong>을 선택한다.
    <br>→ 2. <strong>중앙값 > 타깃 데이터(target data)</strong>일 때 중앙값 기준 <strong>왼쪽 데이터셋</strong>을 선택한다.
    <br>→ 3. <strong>중앙값 < 타깃 데이터</strong>일 때 중앙값 기준 <strong>오른쪽 데이터셋</strong>을 선택한다.
    <br>→ 4. 과정 1 ~ 3을 반복하다가 <strong>중앙값 == 타깃 데이터</strong>일 때 탐색을 종료한다.
  </li>
</ul>

```python
# 원하는 정수 찾기 - 1920
N = int(input())
A = list(map(int, input().split()))
A.sort()
M = int(input())
target_list = list(map(int, input().split()))

# 모든 M의 원소에 대해 적용.
for i in range(M):

    # flag를 활용하여 출력을 조정한다.
    find = False
    target = target_list[i]

    # 이진 탐색 시작
    start = 0
    end = len(A) - 1
    while start <= end:
        midi = int((start + end) / 2)
        midv = A[midi]

        # 이 부분에서 start + 1과 end - 1로 업데이트 해야
        # while문에 start <= end를 조건으로 사용할 수 있다.
        # 그냥 start = midi와 end = midi로 업데이트하면 
        # start가 end보다 커지지 않아 종료 조건을 줄 수 없다.
        if midv > target:
            end = midi - 1
        elif midv < target:
            start = midi + 1
        else:
            find = True
            break
    
    if find:
        print(1)
    else:
        print(0)
```

```python
# 블루레이 만들기 - 2343
#   - 블루레이 개수만 맞다면 안의 크기가 0이어도 된다.
#     → 즉, 아무 원소도 할당 되지 않은 빈 리스트도 가능.
#   - 가장 큰 원소가 가장 작은 블루레이 크기이다.
#   - 가장 큰 원소를 제외한 나머지 원소들의 합이 가장 큰 블루레이 크기이다.
#   - 따라서 탐색하고자 하는 블루레이의 크기(9 ~ 45)를 기준으로 이진 탐색한다.

N, M = map(int, input().split())
A = list(map(int, input().split()))
start = 0
end = 0

# 앞서 설명한 로직에 따라 시작 및 끝 인덱스 설정
for i in A:
    # 가장 큰 최댓값을 시작 인덱스로 한다.
    if start < i:
        start = i
    # 최댓값을 뺀 나머지 원소의 합을 끝 인덱스로 한다.
    end += i

# 이진 탐색 시작
while start <= end:

    # 필요한 변수들 초기화
    middle = int((start + end) / 2)
    sum = 0
    count = 0

    # 1. 누적 합이 블루레이 크기를 넘는 경우.
    # 중앙값으로 모든 레슨을 저장할 수 있는지 확인
    for i in range(N):
        # 누적합이 블루레이 크기의 중앙값 보다 큰 경우
        if sum + A[i] > middle:
            # 블루레이 수 증가.
            count += 1
            # 누적합 초기 상태로 초기화
            sum = 0
        # 중앙값보다 크지 않다면 누적합 지속.
        sum += A[i]
    
    # 2. 누적합이 블루레이 크기를 넘지 않는 경우.
    # 분기는 항상 블루레이의 수(M)을 기준으로.
    # 블루레이 중앙값보다 크지 않게 누적값이 마무리 된다면
    # 0이 아닌 경우 일단 블루레이 개수 추가.
    if sum != 0:
        count += 1
    
    # 블루레이의 수가 지정된 수 M 개를 넘는다면 인덱스 초기화
    # M을 넘는 경우 start를 증가.
    if count > M:
        start = middle + 1
    
    # 아닌 경우 end를 감소
    else:
        end = middle - 1

print(start)     
```

```python
# K 번째 수 - 1300
N = int(input())
K = int(input())

# 이차원 배열의 한 행은 해당 행의 배수이다.
#   → B[k]는 절대 k를 넘을 수 없다.
#   → start는 1, end는 k가 된다.
start = 1
end = K
ans = 0

# 이진 탐색 수행
while start <= end:
    middle = int((start + end) / 2)
    cnt = 0

    # 중앙값보다 작은 수 계산
    # 문제의 조건에 따라 1부터 시작한다.
    for i in range(1, N + 1):
        # 몫이 N보다 클 수 없다(N X N 행렬이기 때문).
        cnt += min(int(middle / i), N)
    
    # 조건에 따라 업데이트
    # 총 갯수가 K보다 작은 경우
    if cnt < K:
        start = middle + 1

    # 총 갯수가 K 보다 큰 경우
    else:
        # 이번이 마지막 일 수 있기에 미리 답을 초기화한다.
        ans = middle
        end = middle - 1

print(ans)
```