<h1>1. 깊이 우선 탐색</h1>
<ul>
  <li>
    <strong>깊이 우선 탐색(depth-first search, DFS)</strong>은 그래프 완전 탐색 기법 중 하나입니다.
  </li>
  <li>
    깊이 우선 탐색은 그래프의 시작 노드에서 출발하여 탐색할 한 쪽 분기를 정하여 <strong>최대 깊이</strong>까지 탐색을 마친 후 다른 쪽 분기로 이동하여 다시 탐색을 진행하는 알고리즘이다.
  </li>
  <li>
    깊이 우선 탐색의 노드의 수를 V, 에지의 수를 E로 표현하는 경우 시간 복잡도는 O(V + E) 이다.
  </li>
  <li>
    DFS는 <strong>재귀 함수</strong> 혹은 <strong>스택 자료구조</strong>로 구현한다.
  </li>
    <ul>
      <li>
        구현 시에 재귀 함수를 사용할 경우 스택 오버플로(stack overflow)를 유의해야 한다.
      </li>
    </ul>
  <li>
    DFS를 사용해 풀 수 있는 문제로는 단절점 찾기, 단절선 찾기, 사이클 찾기, 위상 정렬 등이 있다.
  </li>
</ul>

<br>

<h2>1-1. 깊이 우선 탐색의 핵심 이론</h2>
<ul>
  <li>
    DFS는 한 번 방문한 노드를 다시 방문하면 안 되기에 <strong>노드 방문 여부</strong>를 체크할 리스트가 필요하다.
  </li>
  <li>
    DFS는 <strong>후입선출</strong> 특성을 가지므로 스택을 사용하여 설명한다.
  </li>
  <li>
    1. DFS를 시작할 노드를 정한 후 사용할 자료구조 초기화
    <br>→ 2. 스택에서 노드를 꺼낸 후 꺼낸 노드의 인접 노드를 다시 스택에 삽입.
    <br>→ 3. 스택 자료구조에 값이 없을 때까지 반복한다.
  </li>
</ul>

```python
# 연결 요소의 개수 구하기 - 11724
# 변수 초기화
import sys
sys.setrecursionlimit(10000)
input = sys.stdin.readline
n, m = map(int, input().split())
A = [[] for _ in range(n+1)]
visited = [False] * (n+1)

# DFS 로직
def DFS(v):
    
    # 현재 방문한  node 체크
    visited[v] = True

    # 해당 노드 v의 자식 노드를 순회하며 DFS를 수행.
    for i in A[v]:
        if not visited[i]:
            DFS(i)

# 양방향 그래프 구현
for _ in range(m):
    s, e = map(int, input().split())
    A[s].append(e)
    A[e].append(s)

count = 0

# 연결 노드 중 방문하지 않은 노드만 탐색.
for i in range(1, n + 1):
    if not visited[i]:
        count += 1
        DFS(i)

print(count)
```

```python
# 신기한 소수 찾기 - 2023
#   - 보통 소수를 찾는 문제에 `에라토스테네스의 체`를 사용하지만 현재 문제에는 
#     해당하지 않는다.
import sys
sys.setrecursionlimit(10000)
input = sys.stdin.readline
N = int(input())

# 소수 확인 함수
def isPrime(num):
    # 2 이상 자기 자신의 1/2이하의 수를 직접 확인
    #   - num / 2 보다 큰 수는 2 이상을 곱해서 만들 수 없음.
    for i in range(2, int(num / 2 + 1)):
        if num % i == 0:
            return False
    return True

# DFS 함수
#   - 첫 번째 숫자만 주어진다.
#   - 이후 뒤에 수를 붙여 나가면서 확인하는 방식. 
def DFS(number):
    if len(str(number)) == N:
        print(number)
    else:
        for i in range(1, 10):
            
            # 짝수는 소수가 아니기에 skip
            if i % 2 == 0:
                continue

            # 소수 확인
            #   - 나의 경우 네 자리수 몫을 사용
            #     → 풀이에서는 미리 몫을 만들고 더하는 방식 활용.
            #     → 내 풀이는 index 관리가 어려웠기에 풀이가 더 나은 것 같다.
            if isPrime(number * 10 + i):
                DFS(number * 10 + i)

# 일의 자리가 소수인 수만 탐색
DFS(2)
DFS(3)
DFS(5)
DFS(7)
```

```python
# 친구 관계 파악하기 - 13023
import sys
sys.setrecursionlimit(10000)
input = sys.stdin.readline
N, M = map(int, input().split())
arrive = False
A = [[] for _ in range(N + 1)]
visited = [False] * (N + 1)

def DFS(now, depth):
    global arrive

    # 깊이가 5가 되면 더이상 탐색 불필요
    if depth == 5:
        # 찾는 그래프임을 표시
        arrive = True
        return
    
    # 방문 체크
    visited[now] = True

    # 자식 노드 탐색
    for i in A[now]:
        
        # 방문 안한 자식이라면 DFS
        if not visited[i]:
            DFS(i, depth + 1)
    
    # 특정 노드의 탐색이 끝났다면 방문 해제
    #   - 다음 노드의 탐색을 위해.
    visited[now] = False

# 양방향 그래프 구현
for _ in range(M):
    s, e = map(int, input().split())
    A[s].append(e)
    A[e].append(s)

# 모든 노드에 대해 DFS 탐색 시작
for i in range(N):
    DFS[i, 1]
    # 이미 패턴 발견했다면 종료
    if arrive:
        break

# 출력부 구현
# 찾는 그래프라면 1을,
if arrive:
    print(1)
# 아니라면 0을 출력.
else:
    print(0)
```

<br><br>

<h1>2. 백트래킹</h1>
<ul>
  <li>
    백트래킹(backtracking)은 문제를 해결하는 탐색 기법이다. 문제를 해결할 수 있는 <strong>모든 경로</strong>를 탐색하며 선택한 경로가 <strong>유효하지 않거나 조건에 만족하는 해를 찾지 못할 경우</strong> 이전 단계로 돌아가 다른 경로를 탐색한다.
  </li>
  <li>
    백트래킹은 일반적으로 <strong>재귀 함수</strong> 형태로 구현하며 DFS와 개념과 구현 방식이 매우 유사하다.
  </li>
  <li>
    가장 큰 특징은 <strong>가치치기(pruning)</strong>로 유효하지 않은 경로를 조기에 배제하여 탐색 범위를 줄이고 성능을 높일 수 있다.
  </li>
    <ul>
      <li>
        굳이 차이를 두면 DFS는 모든 노드 탐색을, 백트래킹은 조건에 만족하는 해를 찾는 것을 목표로 한다.
      </li>
    </ul>
  <li>
    시간 복잡도는 <strong>O(N^d)</strong>이다.
  </li>
    <ul>
      <li>
        <strong>N</strong>: 분기 수
      </li>
      <li>
        <strong>d</strong>: 탐색 깊이
      </li>
    </ul>
  <li>
    백트래킹을 활용하는 대표적인 문제로는 조합, 순열, N-Queens 문제 등이 있다.
  </li>
</ul>

<br>

<h2>2-1. 백트래킹 핵심 이론</h2>
<ul>
  <li>
    1. 가능한 선택지 탐색하기.
    <br>→ 2. 유효성 검사 및 가지치기
    <br>→ 3. 해답 도출하기.
  </li>
</ul>

```python
# N과 M - 15649
N, M = map(int, input().split())
# 수열을 저장할 리스트
S = [0] * M
# 숫자 사용 여부 저장 리스트
visited = [False] * N

def backtrack(length):
    if length == M:
        print(' '.join(str(x + 1) for x in S))
        return

    for i in range(N):
        if not visited[i]:
            visited[i] = True
            S[length] = i
            backtrack(length + 1)
            # 백 트래킹 수 반납
            visited[i] = False

bracktrack(0)
```