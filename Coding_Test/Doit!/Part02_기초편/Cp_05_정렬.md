<h1>1. 버블 정렬</h1>
<h2>1-1. 버블 정렬의 핵심 이론</h2>
<ul>
  <li>
    <strong>버블 정렬(bubble sort)</strong>는 <strong>두 인접한 데이터의 크기</strong>를 비교해 정렬하는 방법이다.
  </li>
  <li>
    간단하게 구현할 수 있지만 <strong>시간 복잡도는 O(N^2)</strong>이기에 다른 정렬 알고리즘보다 느린 편이다.
  </li>
  <li>
    버블 정렬 과정
  </li>
    <ul>
      <li>
        1. 비교 연산이 필요한 루프 범위를 설정
        <br>→ 2. 인접한 데이터 값을 비교한다.
        <br>→ 3. swap 조건에 부하밯면 swap 연산을 수행한다.
        <br>→ loop 범위가 끝날 때까지 2 ~ 3을 반복한다.
        <br>→ 정렬된 영역을 설정한다. 다음 loop 실행 때에 해당 영역을 제외한다.
        <br>→ 비교 대상이 없을 때까지 1 ~ 5를 반복한다. 
      </li>
    </ul>
</ul>

```python
# 수 정렬하기 1 - 2750
#   - 파이썬에서는 sort() 함수를 이용해 쉽게 풀 수 있다.
#   - 도서에서는 버블 정렬을 직접 구현한다.
N = int(input())
A = [0] * N

for i in range(N):
    A[i] = int(input())

for i in range(N-1):
    for j in range(N-1-i):
        if A[j] > A[j + 1]:
            temp = A[j]
            A[j] A[j + 1]
            A[j + 1] = temp

for i in range(N):
    print(A[i])
```

```python
# 버블 정렬 프로그램 1 - 1377
#   - 출력: for loop이 몇 번 수행 됐는지
import sys
input = sys.stdin.readline

N = int(input())
A = []

for i in range(N):
    # 정렬 기준을 고려하여 데이터와 index 순서로 저장
    A.append((int(input()), i))

Max = 0
sorted_A = sorted(A)

for i in range(N):
    # 정렬 전 index - 정렬 후 index 계산의 최댓값 저장
    #   - 두 index 차이가 가장 큰 원소가 최대 for loop 수행 횟수이다.
    if Max < sorted_A[i][1] - i:
        Max = sorted_A[i][1] - i

# swap이 일어나지 않는 것을 확인하는 마지막 for loop이 1회 있기에 더해준다.
print(Max + 1)
```

<br><br>

<h1>2. 선택 정렬</h1>
<ul>
  <li>
    <strong>선택 정렬(selection sort)</strong>은 대상 데이터에서 최대나 최소 데이터를 데이터가 <strong>나열된 순</strong>으로 찾아가며 선택하는 방법이다.
  </li>
  <li>
    시간 복잡도가 O(N^2)로 효율적이지는 않아 자주 사용하지는 않는다.
  </li>
</ul>

<br>

<h2>2-1. 선택 정렬의 핵심 이론</h2>
<ul>
  <li>
    최솟값 또는 최댓값을 찾고, 남은 정렬 부분의 <strong>가장 앞에 있는 데이터</strong>와 swap하는 것이 핵심이다.
  </li>
  <li>
    선택 정렬 과정
  </li>
    <ul>
      <li>
        1. 남은 정렬 부분에서 최솟값 또는 최댓값을 찾는다.
        <br>→ 2. 남은 정렬 부분에서 가장 앞에 있는 데이터와 선택된 데이터를 swap한다.
        <br>→ 3. 가장 앞에 있는 데이터의 위치를 변경해(index++) 남은 정렬 부분의 범위를 축소한다.
        <br>→ 4. 전체 데이터 크기만큼 index가 커질 때까지, 즉 남은 정렬 부분이 없을 때까지 반복한다.
      </li>
    </ul>
  <li>
    선택 정렬 자체를 묻는 문제는 자주 나오지 않지만, 원리를 응용하는 문제는 대비할 수 있어야 한다.
  </li>
</ul>

```python
# 내림차순으로 자릿수 정렬하기 - 1427
#   - 도서에서는 선택 정렬 사용
import sys
print = sys.stdout.write
A = list(input())

# 전체 배열을 순회
for i in range(len(A)):
    
    # 현재 값을 최댓값으로 지정
    Max = i

    # 전체 순회하면서 더 큰 수가 있다면 최댓값 업데이트
    for j in range(i + 1, len(A)):
        if A[j] > A[Max]:
            Max = j
    
    # 최댓값을 찾은 뒤 현재(가장 앞의 값)값이 더 작다면 swap
    if A[i] < A[Max]:
        temp = A[i]
        A[i] = A[Max]
        A[Max] = temp

# 결과 출력
for i in range(len(A)):
    print(A[i])
```