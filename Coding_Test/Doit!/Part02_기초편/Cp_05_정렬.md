<h1>1. 버블 정렬</h1>
<h2>1-1. 버블 정렬의 핵심 이론</h2>
<ul>
  <li>
    <strong>버블 정렬(bubble sort)</strong>는 <strong>두 인접한 데이터의 크기</strong>를 비교해 정렬하는 방법이다.
  </li>
  <li>
    간단하게 구현할 수 있지만 <strong>시간 복잡도는 O(N^2)</strong>이기에 다른 정렬 알고리즘보다 느린 편이다.
  </li>
  <li>
    버블 정렬 과정
  </li>
    <ul>
      <li>
        1. 비교 연산이 필요한 루프 범위를 설정
        <br>→ 2. 인접한 데이터 값을 비교한다.
        <br>→ 3. swap 조건에 부하밯면 swap 연산을 수행한다.
        <br>→ loop 범위가 끝날 때까지 2 ~ 3을 반복한다.
        <br>→ 정렬된 영역을 설정한다. 다음 loop 실행 때에 해당 영역을 제외한다.
        <br>→ 비교 대상이 없을 때까지 1 ~ 5를 반복한다. 
      </li>
    </ul>
</ul>

```python
# 수 정렬하기 1 - 2750
#   - 파이썬에서는 sort() 함수를 이용해 쉽게 풀 수 있다.
#   - 도서에서는 버블 정렬을 직접 구현한다.
N = int(input())
A = [0] * N

for i in range(N):
    A[i] = int(input())

for i in range(N-1):
    for j in range(N-1-i):
        if A[j] > A[j + 1]:
            temp = A[j]
            A[j] A[j + 1]
            A[j + 1] = temp

for i in range(N):
    print(A[i])
```

```python
# 버블 정렬 프로그램 1 - 1377
#   - 출력: for loop이 몇 번 수행 됐는지
import sys
input = sys.stdin.readline

N = int(input())
A = []

for i in range(N):
    # 정렬 기준을 고려하여 데이터와 index 순서로 저장
    A.append((int(input()), i))

Max = 0
sorted_A = sorted(A)

for i in range(N):
    # 정렬 전 index - 정렬 후 index 계산의 최댓값 저장
    #   - 두 index 차이가 가장 큰 원소가 최대 for loop 수행 횟수이다.
    if Max < sorted_A[i][1] - i:
        Max = sorted_A[i][1] - i

# swap이 일어나지 않는 것을 확인하는 마지막 for loop이 1회 있기에 더해준다.
print(Max + 1)
```

<br><br>

<h1>2. 선택 정렬</h1>
<ul>
  <li>
    <strong>선택 정렬(selection sort)</strong>은 대상 데이터에서 최대나 최소 데이터를 데이터가 <strong>나열된 순</strong>으로 찾아가며 선택하는 방법이다.
  </li>
  <li>
    시간 복잡도가 O(N^2)로 효율적이지는 않아 자주 사용하지는 않는다.
  </li>
</ul>

<br>

<h2>2-1. 선택 정렬의 핵심 이론</h2>
<ul>
  <li>
    최솟값 또는 최댓값을 찾고, 남은 정렬 부분의 <strong>가장 앞에 있는 데이터</strong>와 swap하는 것이 핵심이다.
  </li>
  <li>
    선택 정렬 과정
  </li>
    <ul>
      <li>
        1. 남은 정렬 부분에서 최솟값 또는 최댓값을 찾는다.
        <br>→ 2. 남은 정렬 부분에서 가장 앞에 있는 데이터와 선택된 데이터를 swap한다.
        <br>→ 3. 가장 앞에 있는 데이터의 위치를 변경해(index++) 남은 정렬 부분의 범위를 축소한다.
        <br>→ 4. 전체 데이터 크기만큼 index가 커질 때까지, 즉 남은 정렬 부분이 없을 때까지 반복한다.
      </li>
    </ul>
  <li>
    선택 정렬 자체를 묻는 문제는 자주 나오지 않지만, 원리를 응용하는 문제는 대비할 수 있어야 한다.
  </li>
</ul>

```python
# 내림차순으로 자릿수 정렬하기 - 1427
#   - 도서에서는 선택 정렬 사용
import sys
print = sys.stdout.write
A = list(input())

# 전체 배열을 순회
for i in range(len(A)):
    
    # 현재 값을 최댓값으로 지정
    Max = i

    # 전체 순회하면서 더 큰 수가 있다면 최댓값 업데이트
    for j in range(i + 1, len(A)):
        if A[j] > A[Max]:
            Max = j
    
    # 최댓값을 찾은 뒤 현재(가장 앞의 값)값이 더 작다면 swap
    if A[i] < A[Max]:
        temp = A[i]
        A[i] = A[Max]
        A[Max] = temp

# 결과 출력
for i in range(len(A)):
    print(A[i])
```

<br><br>

<h1>3. 삽입 정렬</h1>
<ul>
  <li>
    <strong>삽입 정렬(insertion sort)</strong>은 이미 정렬된 데이터 범위에 정렬되지 않은 데이터를 적절한 위치에 <strong>삽입</strong>시켜 정렬하는 방식이다.
  </li>
  <li>
    시간 복잡도는 O(n^2)로 느린 편이지만 구현하기가 쉽다.
  </li>
</ul>

<h2>3-1. 삽입 정렬 수행 방식</h2>
<ul>
  <li>
    1. 현재 index에 있는 데이터 값을 선택한다.
    <br>→ 2. 현재 선택한 데이터가 정렬된 데이터 범위에 삽입될 위치를 탐색한다.
    <br>→ 3. 삽입 위치부터 index에 있는 위치까지 shift 연산을 수행한다.
    <br>→ 4. 삽입 위치에 현재 선택한 데이터를 삽입하고 index++ 연산을 수행한다.
    <br>→ 5. 전체 데이터 크기만큼 index가 커질 때까지, 즉 선택할 데이터가 없을 때까지 반복한다.
  </li>
</ul>

```python
# ATM 인출 시간 계산하기 - 11399
N = int(input())
A = list(map(int, input().split()))
S = [0] * N

# 삽입 정렬
for i in range(1, N):
    insert_point = i
    insert_value = A[i]

    # 전체 배열 순회
    for j in range(i - 1, -1, -1):
        
        # 정렬 범위를 좌측으로 이동하며 탐색하다 더 작은 값을 찾는다면 '해당 탐색 위치(j) + 1'이
        # 삽입될 위치가 된다.
        if A[j] < A[i]:
            insert_point = j + 1
            break
        # 만약 j == 0 인 경우 끝지점이기에 첫 번째 원소인 index = 0이 삽입 위치가 된다.
        if j == 0:
            insert_point = 0
    
    # 한 칸씩 이동시킨다.
    for j in range(i, insert_point -1):
        A[j] = A[j-1]
    
    # 이동을 완료한 후 탐색한 값을 삽입할 위치에 삽입한다.
    A[insert_point] = inser_value

# 합 배열을 만들기 전 처음값 처리.
S[0] = A[0]

# 합 배열 만들기
for i in range(1, N):
    S[i] = S[i-1] + A[i]

sum = 0

# 합 배열 총합 구하기
for i in range(0, N):
    sum += S[i]

print(sum)
```

<br><br>

<h1>5. 병합 정렬</h1>
<ul>
  <li>
    <strong>병합 정렬(merge sort)</strong>은 <strong>분할 정복(divide and conquer) 방식</strong>을 사용해 데이터를 분할하고 분할한 집합을 정렬하며 합치는 알고리즘이다.
  </li>
  <li>
    병합 정렬 시간 복잡도는 <strong>O(nlogn)</strong>이다.
  </li>
</ul>

<br>

<h2>5-1. 병합 정렬 수행 방식</h2>
<ul>
  <li>
    병합 정렬은 코딩 테스트의 정렬 관련 문제에 자주 등장하며 특히 <strong>두 개의 그룹을 병합</strong>하는 원리를 숙지해야 한다.
  </li>
</ul>

<br>

<h2>5-2. 두 개의 그룹을 병합하는 과정</h2>
<ul>
  <li>
    투 포인터를 통해 두 개의 그룹의 첫 번째 원소부터 이동하면서 더 작은 수를 새로운 배에 삽입저장한다.
  </li>
</ul>

```python
# 수 정렬하기 2 - 2751
import sys
input = sys.stdin.readline
print = sys.stdout.write

# 병합 정렬 수행
def merge_sort(s, e):
    
    # end가 start와 같거나 작다면 종료
    if e - s < 1: 
        return
    
    # 정렬하는 범위의 중간값 찾기
    #   - e - s는 현재 구간의 길이
    #   - s와 더하고 2로 나누면 현재 구간의 중간값
    m = int(s + (e - s) / 2)

    # 앞 그룹 (start ~ m)
    merge_sort(s, m)

    # 뒷 그룹 (m ~ end)
    merge_sort(m + 1, e)

    # 배열 tmp에 배열 A를 복사
    for i in range(s, e + 1):
        tmp[i] = A[i]
    k = s             # A 배열에 넣을 index
    index1 = s        # 좌측 그룹 index
    index2 = m + 1    # 우측 그룹 index

    # 두 그룹을 병합하는 로직
    #   - 가장 작은 그룹부터 두 그룹을 병합을 반복하면 정렬이 된다.
    # 두 그룹을 확인하며 병합
    while index1 <= m and index2 <= e:
        if tmp[index1] > tmp[index2]:
            A[k] = tmp[index2]
            k += 1
            index2 += 1
        else:
            A[k] = tmp[index1]
            k += 1
            index1 += 1

    # 한쪽 그룹이 모두 선택된 후 남아 있는 값 처리.
    # 와측 그룹이 남은 경우
    while index1 <= m:
        A[k] = tmp[index1]
        k += 1
        index1 += 1

    # 우측 그룹이 남은 경우
    while index2 <= e:
        A[k] += tmp[index2]
        k += 1
        index2 += 1

N = int(input())
A = [0] * int(N + 1)
tmp = [0] * int(N + 1)

for i in range(1, N + 1):
    A[i] = int(input())

merge_sort(1, N)

for i in range(1, N + 1):
    print(str(A[i]) + '\n')
```

```python
# 버블 정렬 프로그램 2 - 1517
#   - 병합 정렬을 수행할 때마다 큰 수가 이동하게 되는 index가 버블 정렬의 swap임.
#     → 병합 정렬에서 총 이동한 index를 계산하면 전체 swap의 수를 알 수 있다.
import sys
input = sys.stdin.readline
result = 0

def merge_sort(s, e):
    global result
    if e - s < 1:
        return
    m = int(s + (e - s) / 2)
    merge_sort(s, m)
    merge_sort(m + 1, e)
    for i in range(s, e + 1):
        tmp[i] = A[i]
        k = s
        index1 = s
        index = m + 1
        # 두 그릅을 병합하는 로직
        while index1 <= m and index2 x <=  e:
            if tmp[index1] > tmp[index2]:
                A[k] = tmp[index2]
                # 뒤쪽 데이터값이 더 작다면 결괏값 업데이트
                #   - 원래 있던 위치(index2)에서 병합 후 들어갈 위치(k)를 차감하여 
                #     index의 이동 거리를 연산한다.
                result = result + index2 - k
                k += 1
                index2 += 1
            else:
                A[k] = tmp[index1]
                k += 1
                index1 += 1
        while index1 <= m:
            A[k] = tmp[index1]
            k += 1
            index1 += 1
        while index2 <= e:
            A[k] = tmp[index2]
            k += 1
            index2 += 1
        
N = int(input())
A = list(map(int, input().split()))
A.insert(0, 0)
tmp = [0] * int(N + 1)
merge_sort(1, N)
print(result)
```