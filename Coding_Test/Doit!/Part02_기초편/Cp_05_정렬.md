<h1>1. 버블 정렬</h1>
<h2>1-1. 버블 정렬의 핵심 이론</h2>
<ul>
  <li>
    <strong>버블 정렬(bubble sort)</strong>는 <strong>두 인접한 데이터의 크기</strong>를 비교해 정렬하는 방법이다.
  </li>
  <li>
    간단하게 구현할 수 있지만 <strong>시간 복잡도는 O(N^2)</strong>이기에 다른 정렬 알고리즘보다 느린 편이다.
  </li>
  <li>
    버블 정렬 과정
  </li>
    <ul>
      <li>
        1. 비교 연산이 필요한 루프 범위를 설정
        <br>→ 2. 인접한 데이터 값을 비교한다.
        <br>→ 3. swap 조건에 부하밯면 swap 연산을 수행한다.
        <br>→ loop 범위가 끝날 때까지 2 ~ 3을 반복한다.
        <br>→ 정렬된 영역을 설정한다. 다음 loop 실행 때에 해당 영역을 제외한다.
        <br>→ 비교 대상이 없을 때까지 1 ~ 5를 반복한다. 
      </li>
    </ul>
</ul>

```python
# 수 정렬하기 1 - 2750
#   - 파이썬에서는 sort() 함수를 이용해 쉽게 풀 수 있다.
#   - 도서에서는 버블 정렬을 직접 구현한다.
N = int(input())
A = [0] * N

for i in range(N):
    A[i] = int(input())

for i in range(N-1):
    for j in range(N-1-i):
        if A[j] > A[j + 1]:
            temp = A[j]
            A[j] A[j + 1]
            A[j + 1] = temp

for i in range(N):
    print(A[i])
```

```python
# 버블 정렬 프로그램 1 - 1377
#   - 출력: for loop이 몇 번 수행 됐는지
import sys
input = sys.stdin.readline

N = int(input())
A = []

for i in range(N):
    # 정렬 기준을 고려하여 데이터와 index 순서로 저장
    A.append((int(input()), i))

Max = 0
sorted_A = sorted(A)

for i in range(N):
    # 정렬 전 index - 정렬 후 index 계산의 최댓값 저장
    #   - 두 index 차이가 가장 큰 원소가 최대 for loop 수행 횟수이다.
    if Max < sorted_A[i][1] - i:
        Max = sorted_A[i][1] - i

# swap이 일어나지 않는 것을 확인하는 마지막 for loop이 1회 있기에 더해준다.
print(Max + 1)
```

<br><br>

<h1>2. 선택 정렬</h1>
<ul>
  <li>
    <strong>선택 정렬(selection sort)</strong>은 대상 데이터에서 최대나 최소 데이터를 데이터가 <strong>나열된 순</strong>으로 찾아가며 선택하는 방법이다.
  </li>
  <li>
    시간 복잡도가 O(N^2)로 효율적이지는 않아 자주 사용하지는 않는다.
  </li>
</ul>

<br>

<h2>2-1. 선택 정렬의 핵심 이론</h2>
<ul>
  <li>
    최솟값 또는 최댓값을 찾고, 남은 정렬 부분의 <strong>가장 앞에 있는 데이터</strong>와 swap하는 것이 핵심이다.
  </li>
  <li>
    선택 정렬 과정
  </li>
    <ul>
      <li>
        1. 남은 정렬 부분에서 최솟값 또는 최댓값을 찾는다.
        <br>→ 2. 남은 정렬 부분에서 가장 앞에 있는 데이터와 선택된 데이터를 swap한다.
        <br>→ 3. 가장 앞에 있는 데이터의 위치를 변경해(index++) 남은 정렬 부분의 범위를 축소한다.
        <br>→ 4. 전체 데이터 크기만큼 index가 커질 때까지, 즉 남은 정렬 부분이 없을 때까지 반복한다.
      </li>
    </ul>
  <li>
    선택 정렬 자체를 묻는 문제는 자주 나오지 않지만, 원리를 응용하는 문제는 대비할 수 있어야 한다.
  </li>
</ul>

```python
# 내림차순으로 자릿수 정렬하기 - 1427
#   - 도서에서는 선택 정렬 사용
import sys
print = sys.stdout.write
A = list(input())

# 전체 배열을 순회
for i in range(len(A)):
    
    # 현재 값을 최댓값으로 지정
    Max = i

    # 전체 순회하면서 더 큰 수가 있다면 최댓값 업데이트
    for j in range(i + 1, len(A)):
        if A[j] > A[Max]:
            Max = j
    
    # 최댓값을 찾은 뒤 현재(가장 앞의 값)값이 더 작다면 swap
    if A[i] < A[Max]:
        temp = A[i]
        A[i] = A[Max]
        A[Max] = temp

# 결과 출력
for i in range(len(A)):
    print(A[i])
```

<br><br>

<h1>3. 삽입 정렬</h1>
<ul>
  <li>
    <strong>삽입 정렬(insertion sort)</strong>은 이미 정렬된 데이터 범위에 정렬되지 않은 데이터를 적절한 위치에 <strong>삽입</strong>시켜 정렬하는 방식이다.
  </li>
  <li>
    시간 복잡도는 O(n^2)로 느린 편이지만 구현하기가 쉽다.
  </li>
</ul>

<h2>3-1. 삽입 정렬 수행 방식</h2>
<ul>
  <li>
    1. 현재 index에 있는 데이터 값을 선택한다.
    <br>→ 2. 현재 선택한 데이터가 정렬된 데이터 범위에 삽입될 위치를 탐색한다.
    <br>→ 3. 삽입 위치부터 index에 있는 위치까지 shift 연산을 수행한다.
    <br>→ 4. 삽입 위치에 현재 선택한 데이터를 삽입하고 index++ 연산을 수행한다.
    <br>→ 5. 전체 데이터 크기만큼 index가 커질 때까지, 즉 선택할 데이터가 없을 때까지 반복한다.
  </li>
</ul>

```python
# ATM 인출 시간 계산하기 - 11399
N = int(input())
A = list(map(int, input().split()))
S = [0] * N

# 삽입 정렬
for i in range(1, N):
    insert_point = i
    insert_value = A[i]

    # 전체 배열 순회
    for j in range(i - 1, -1, -1):
        
        # 정렬 범위를 좌측으로 이동하며 탐색하다 더 작은 값을 찾는다면 '해당 탐색 위치(j) + 1'이
        # 삽입될 위치가 된다.
        if A[j] < A[i]:
            insert_point = j + 1
            break
        # 만약 j == 0 인 경우 끝지점이기에 첫 번째 원소인 index = 0이 삽입 위치가 된다.
        if j == 0:
            insert_point = 0
    
    # 한 칸씩 이동시킨다.
    for j in range(i, insert_point -1):
        A[j] = A[j-1]
    
    # 이동을 완료한 후 탐색한 값을 삽입할 위치에 삽입한다.
    A[insert_point] = inser_value

# 합 배열을 만들기 전 처음값 처리.
S[0] = A[0]

# 합 배열 만들기
for i in range(1, N):
    S[i] = S[i-1] + A[i]

sum = 0

# 합 배열 총합 구하기
for i in range(0, N):
    sum += S[i]

print(sum)
```