<h1>1. 시간 초과의 원인을 찾아 해결하기</h1>
<ul>
  <li>
    시간 초과 문제를 마주치는 경우 <strong>입력과 출력 방식</strong>부터 최적화할 수 있는지 점검하는 것이 좋다.
  </li>
  <li>
    시간 초과가 발생한다면 다음 두 가지를 확인한다.
  </li>
  <ul>
    <li>
      <strong>풀이 로직 시간 복잡도</strong>를 점검한다. 시간 복잡도가 너무 높다면 풀이 로직 자체를 변경하여야 한다.
    </li>
    <li>
      input()과 print()의 입출력 방식을 <strong>sys.stdin.readline()</strong>과 <strong>sys.stdout.write()</strong>으로 변경한다.
    </li>
    <ul>
      <li>
        <strong>input()</strong>은 <strong>호출될 때마다 한 줄</strong>을 읽어 끝의 개행 문자 전체를 제거한 문자열을 반환한다. 반면 <strong>sys.stdin.readline()</strong>은 <strong>입력 버퍼에서 한 줄 전체</strong>를 읽어 대량 입력에 더 빠르다.
      </li>
      <li>
        <strong>print()</strong>는 기본적으로 출력 내용을 <strong>버퍼에 모았다 상황에 따라 비우지만</strong> 반복 호출이 많으면 작은 단위의 찾은 쓰기로 성능이 저하된다. 반면 <strong>sys.stdout.write()</strong>은 <strong>개행 문자를 자동으로 붙이지 않아</strong> 여러 출력을 보아 한 번에 출력할 수 있다.
      </li>
    </ul>
  </ul>
</ul>

```python
# 1. 입출력 예시

# 일반적인 입출력====================================================
a = int(input())
print(a)

# 빠른 입출력=======================================================
import sys
b = int(sys.stdin.readline())
# sys.stdout.write()은 문자열만 출력 가능하기에 str()로 변환하여 출력한다.
sys.stdout.write(str(b) + '\n') 
```

<br><br>

<h1>2. 인덱스에 의미 부여하여 풀어 보기</h1>
<ul>
  <li>
    인덱스를 순서가 아니라 <strong>해당 숫잣값 자체에 의미를 부여</strong>하는 상황을 가장 자주 사용한다. <strong>A[1]</strong>을 다음과 같이 해석할 수 있다.
  </li>
  <ul>
    <li>
      <strong>순서</strong>: 첫 번째 데이터를 저장한다.
    </li>
    <li>
      <strong>의미가 있는 수</strong>: 1이라는 값이 몇 개 있는지를 저장한다.
    </li>
  </ul>
</ul>

```python
# 1. 인덱스에 의미를 부여한 계수 정렬
import sys

N = int(sys.stdin.readline())
count = [0] * 1001
numbers = list(map(int, sys.stdin.readline().split()))

for number in numbers:
    # 인덱스에 숫잣값으로 의미를 부여하여 데이터 저장
    count[number] += 1

for i in range(1001):
    if count(i) != 0:
        for _ in range(count[i]):
            sys.stdout.write(str(i) + ' ')
```

<br><br>

<h1>3. 나머지 연산의 중요성 알아보기</h1>
<ul>
  <li>
    나머지 연산 문제는 큰 수의 연산을 효율적으로 처리하고, 나머지 연산의 수학적 성질을 확인하려는 의도가 담겨 있다.
  </li>
  <li>
    나머지 연산은 나눗셈을 제외한 <strong>덧셈</strong>, <strong>뺄셈</strong>, <strong>곱셉</strong>의 분배 법칙이 성립한다.
  </li>
  <li>
    큰 수의 나머지 연산은 시간이 오래 걸리기 때문에 <strong>중간 과정마다 나머지 연산을 적용</strong>하는 습관이 중요하다.
  </li>
</ul>

```python
# 1. 마지막에 나머지 연산 (오래 걸림)
import time

answer = 1
start = time.time()

for i in range(1, 100001):
    answer *= i

result = answer % 1000000007
end = time.time()
print("결과: ", result)
print("수행 시간: {:.6f}초".format(end-start))

# 결과:  457992974
# 수행 시간: 2.276593초
```

```python
# 2. 중간에 나머지 연산 수행 (빠름)
import time

MOD = 1000000007
answer = 1
start = time.time()

for i in range(1, 100001):
    answer = (answer * i) % MOD

end = time.time()
print("결과: ", answer)
print("수행 시간: {:.6f}초".format(end-start))

# 결과:  457992974
# 수행 시간: 0.013629초
```

<br><br>

<h1>4. 정렬 기초 다지기</h1>
<ul>
  <li>
    정렬은 거의 모든 알고리즘의 출발점이자 기반이 되는 핵심 요소이다.
  </li>
</ul>

<br>

<h2>4-1. 오름차순 정렬</h2>
<ul>
  <li>
    sort() 혹은 sorted() 함수를 사용해 오름차순 정렬를 매우 간단하게 구현할 수 있다.
  </li>
</ul>

```python
# 1. 오름차순 정렬
# 원본 리스트 선언
A = [5, 3, 2, 4, 1]

# 방법 1: list_sort() - 라스트 자체를 정렬(in-place)
A.sort()
print("sort() 결과: ", A)

# 원본 리스트 다시 초기화
A = [5, 3, 2, 4, 1]

# 방법 2: sorted() - 정렬된 복사본을 반환(원본 유지)
B = sorted(A)
print("원본 리스트: ", A)
print("sorted() 결과:", B)

# sort() 결과: [1, 2, 3, 4, 5]
# 원본 리스트: [5, 3, 2, 4, 1]
# sorted() 결과: [1, 2, 3, 4, 5]
```

<br>

<h2>4-2. 내림차순 정렬</h2>
<ul>
  <li>
    reverse=True 옵션을 사용하여 내림차순 정렬을 쉽게 구현할 수 있다.
  </li>
</ul>

```python
# 1. 내림차순 정렬
A = [5, 3, 2, 4, 1]

# 리스트 자체를 내림차순 정렬
A.sort(reverse=True)
print("내림차순 결과:", A)

# 정렬된 복사본 반환(원본은 유지)
B = sorted(A, reverse=True)
print("내림차순 복사본:", B)

# 내림차순 결과: [5, 4, 3, 2, 1]
# 내림차순 복사본: [5, 4, 3, 2, 1]
```

```python
# 3. 부호를 통한 내림차순 정렬
A = [5, 3, 2, 4, 1]

# 부호를 반전시키고 오름차순으로 정렬한 후, 다시 부호 되돌리기
A = [-x for x in A]
A.sort()
A = [-x for x in A]

print("부호 반전 내림차순:", A)
# 부호 반전 내림차순: [5, 4, 3, 2, 1]
```

<br><br>

<h1>5. 다중 조건 정렬 익히기</h1>
<ul>
  <li>
    여러 기준으로의 정렬이 필요한 경우 <strong>튜플</strong>과 <strong>딕셔너리</strong>를 활용할 수 있다.
  </li>
</ul>

<br>

<h2>5-1. 튜플 기반 정렬</h2>
<ul>
  <li>
    가장 자주 사용하는 방식은 데이터를 <strong>(기준1, 기준2, ...) 형태의 튜플</strong>로 구성한 뒤, sort() 또는 sorted() 함수의 <strong>key 인자</strong>에 <strong>lambda</strong>를 통해 정렬 기준을 지정하는 것이다.
  </li>
</ul>

```python
# 1. 튜플 기반 다중 조건 정렬
# 영어, 수학 순서로 튜플데이터 저장.
scores = [
    (80, 100),
    (100, 50),
    (70, 100),
    (80, 90)
]

# 영어 ↓, 영어가 같으면 수학 ↓
scores.sort(key=lambda x: (-x[0], -x[1]))

for s in scores:
    print(f"english={s[0]}, math={s[1]}")

# english=100, math=50
# english=80, math=100
# english=80, math=90
# english=70, math=100
```

<br>

<h2>5-2. 딕셔너리 기반 정렬</h2>
<ul>
  <li>
    일반적으로는 튜플 기반 정렬을 사용하나 <strong>필드명이 있는 복잡한 데이터 처리</strong>에는 딕셔너리가 적합하다.
  </li>
</ul>

```python
# 1. 딕셔너리 기반 다중 조건 정렬
scores = [
    {'english': 80, 'math': 100},
    {'english': 100, 'math': 50},
    {'english': 70, 'math': 100},
    {'english': 80, 'math': 90}
]

# 수학 ↓, 수학이 같으면 영어 ↓
scores.sort(key=lambda x: (-x['math'], -x['english']))

for s in scores:
    print(s)

# {'english': 80, 'math': 100}
# {'english': 70, 'math': 100}
# {'english': 80, 'math': 90}
# {'english': 100, 'math': 50}
```

<br><br>

<h1>6. 이차원 리스트 제대로 다루기</h1>
<ul>
  <li>
    이차원 리스트는 <strong>그래프</strong>를 표현하는 데 많이 사용한다. 
  </li>
</ul>

<br>

<h2>6-1. 이차원 리스트를 이용한 그래프 구현</h2>
<h4>이차원 리스트 선언과 초기화</h4>
<ul>
  <li>
    파이썬에서는 <strong>리스트 안에 또 다른 리스트</strong>를 넣어 이차원 리스트를 구성한다.
  </li>
  <li>
    보통 노드는 1번부터 시작하기에 <strong>인덱스 0</strong>은 사용하지 않고 <strong>N+1 크기</strong>로 리스트를 초기화 한다.
  </li>
</ul>

```python
# 1. 정점이 3개 있다고 가정(1~3번 사용)
#   ● graph[1], graph[2], graph[3] 각 정점의 인접 리스트 역할을 한다.
N = 3
graph = [[] for _ in range(N + 1)]
```

<br>

<h4>그래프 데이터 저장하기</h4>
<ul>
  <li>
    연결 정보는 <strong>(도착 노드, 가중치)</strong> 형태의 <strong>튜플</strong>로 저장한다.
  </li>
</ul>

```python
# 2. 정점 수와 간선 수 입력
N, E = map(int, input().split())

# 간선 정보를 입력받아 저장.
for _ in range(E):
    s, e, w = map(int, input().split())
    graph[s].append((e, w))
```

<br>

<h4>그래프 데이터 가져오기</h4>

```python
# 3. 그래프에서 데이터를 가져온다.
for nextNode, weight in graph[1]:
    print(f"next Node {nextNode}, weight = {weight}")
```