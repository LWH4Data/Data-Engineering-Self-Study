<h1>1. 소수 구하기</h1>
<ul>
  <li>
    <strong>소수(prime number)</strong>는 <strong>1</strong>과 <strong>자기 자신</strong> 외에 약수가 존재하지 않는 수를 의미한다.
  </li>
</ul>

<h2>1-2. 소수 구하기의 핵심 이론</h2>
<ul>
  <li>
    <strong>에라토스테네스의 체</strong>로 <strong>소수의 수</strong>를 구하는 법
  </li>
    <ul>
      <li>
        1. 구하고자 하는 <strong>소수의 범위</strong> 만큼 1차원 리스트를 생성한다.
        <br>→ 2. 2부터 시작해서 선택한 숫자가 지워지지 않은 수인 경우 해당 수의 배수에 해당하는 수를 리스트의 끝까지 탐색하며 지운다. (단, 처음 선택한 수는 지우지 않는다).
        <br>→ 3. 리스트의 끝까지 2를 반복 후 리스트에 남은 모든 수를 출력한다.
      </li>
    </ul>
  <li>
    이중 for loop을 통해 구현하기에 O(N^2)의 시간 복잡도를 갖는다. 단, 사실상 제외되는 수들이 있기에 일반적으로는 <strong>O(Nlog(logN))</strong>이 된다.
  </li>
</ul>

```python
# 소수구하기 - 1929
import math
M, N = map(int, input().split())

# 구현을 할 때에는 모든 수를 구현한다.
A = [0] * (N + 1)

# 해당되는 수의 index에만 값을 대입한다.
for i in range(2, N + 1):
    A[i] = i

# N이하의 두 수의 곱은 N^2를 초과할 수 없다.
for i in range(2, int(math.sqrt(N)) + 1):

    # 0인 경우는 해당 수가 없는 것이기에 skip
    if A[i] == 0:
        continue
      
    # i를 계속 더해나가는 방식으로 곱셈을 구현한다.
    for j in range(i + i, N + 1, i):
        A[j] = 0

# 결과 출력
for i in range(M, N + 1):
    if A[i] != 0:
        print(A[i])
```

```python
# 거의 소수 구하기 - 1456
import math
Min, Max = map(int, input().split())
# 최대가 10**14이기에 해당 수의 제곱근인 10**7로 리스트 생성.
#   - 제곱수를 찾는 것이기에 해당 범위의 소수는 필요 없다.
A = [0] * (10000001)

# 에라토스테네스의 체를 활용하기 위해 모든 수를 대입
for i in range(2, len(A)):
    A[i] = i

# A내의 합성 수만 제거하면 되기에 sqrt(len(A)) + 1 까지를 대상으로 한다.
for i in range(2, int(math.sqrt(len(A)) + 1)):

    # 0과 1의 배수를 제외하기 위해 예외처리.
    if A[i] == 0:
        continue
    # 나머지 수들에 대해서는 배수를 처리하여 에라테스테네스의 체 구현.
    for j in range(i + i, len(A), i):
        A[j] = 0

count = 0

for i in range(2, 10000001):
    if A[i] != 0:
        temp = A[i]
        while A[i] <= Max / temp:
            if A[i] >= Min / temp:
                count += 1
            temp = temp * A[i]

print(count)
```

```python
# 소수 & 팰린드롬 수 중에서 최솟값 찾기 - 1747
import math

N = int(input())
# 주어진 범위(N < 10^6) 보다 하나의 지수가 더 큰 10^7로 한다. 
A = [0] * (10000001)

# 에라토스테네스의 체 구현을 위해 1제외 모든 수를 채운다.
for i in range(2, len(A)):
    A[i] = i

# 합성수를 제거하여 소수만 남긴다.
for i in range(2, int(math.sqrt(len(A)) + 1)):
    if A[i] == 0:
        continue
    for j in range(i + 1, len(A), i):
        A[j] = 0

# 펠린드롬 체크 함수
#   ● 투 포인터를 활용하여 확인.
def isPalindrome(target):
    temp = list(str(target))
    s = 0
    e = len(temp) - 1
    while (s < e):
        if temp[s] != temp[e]:
            return False
        s += 1
        e -= 1
    return True

i = N

while True:
    if A[i] != 0:
        result = A[i]
        if (isPalindrome(result)):
            print(result)
            break
    
    i += 1
```

```python
# 제곱이 아닌 수 찾기 - 1016
#   - 에라토스테네스의 체의 곱셈 버전.
#   - 구간 에라토스테네스의 체.
import math

# 입력값 받기
Min, Max = map(int, input().split())
# [Min, Max] 구간만 체크하여 공간 복잡도 최적화
Check = [False] * (Max - Min + 1)

# 제곱수의 배수가 Min과 Max사이에 위치하도록 조정한다.
# 제곱수는 Max를 넘을 수없기에 sqrt를 취한다.
for i in range(2, int(math.sqrt(Max) + 1)):
    # 현재 제곱수를 구한다.
    pow = i * i
    # Min을 포함한 범위를 찾아야 하기에 몫을 구한다.
    start_index = int(Min / pow)
    # int는 버림을 하기에 나머지가 0인 경우 start_index + 1을 하여 
    # 제곱근의 곱이 Min보다 크게 한다.
    if Min % pow != 0:
        start_index += 1
    # int(Max / pow)로 제곱근의 곱이 Max 범위를 넘지 않도록 한다.
    for j in range(start_index, int(Max / pow) + 1):
        Check[int((j * pow) - Min)] = True

count = 0

# 배수가 아닌 경우를 count 한다.
for i in range(0, Max - Min + 1):
    if not Check[i]:
        count += 1

print(count)
```

<br><br>

<h1>2. 오일러 피</h1>
<ul>
  <li>
    오일러 피 함수 P[N]의 정의는 1부터 N까지의 범위에서 <strong>N과 서로소인 자연수의 개수</strong>를 의미한다.
  </li>
</ul>

<br>

<h2>2-1. 오일러 피의 핵심 이론</h2>
<ul>
  <li>
    오일러 피 함수의 원리
  </li>
    <ul>
      <li>
        1. 구하고자 하는 오일러 피의 범위만큼 리스트를 자기 자신의 인덱스 값으로 초기화한다.
        <br>→ 2. 2부터 시작해 현재 리스트의 값과 인덱스가 같으면(= 소수일 때) 현재 선택된 숫자(K)의 배수에 해당하는 수를 리스트 끝까지 탐색하며 <strong>P[i] - P[i]/K</strong> 연산을 수행한다. (i는 K의 배수).
        <br>→ 리스트의 끝까지 2를 반복하며 오일러 피 함수를 완성한다.
      </li>
    </ul>
</ul>

```python
# 오일러 피 함수 구현하기 - 11689
import math
N = int(input())
result = N

for p in range(2, int(math.sqrt(N)) + 1):
    if N % p == 0:
        result -= result / p

        # 이미 처리한 소인수는 재처리하지 않기 위해
        # 대상(N)에서 소인수를 제거
        while N % p == 0:
            N /= p

# 위에서 p로 나누어 N에서 소인수를 제거하지만 가장 큰 소인수가 남는다.
# 따라서 1초과인 경우 마지막 소인수를 제거한다.
if N > 1:
    result -= result / N

print(int(result))
```

<br>

<h1>3. 유클리드 호제법</h1>
<ul>
  <li>
    <strong>유클리드 호제법(euclidean-algorithm)</strong>은 두 수의 <strong>최대 공약수</strong>를 구하는 알고리즘이다.
  </li>
</ul>

<br>

<h2>3-1. 유클리드 호제법의 핵심 이론</h2>
<ul>
  <li>
    <strong>MOD 연산</strong>을 활용한다.
  </li>
    <ul>
      <li>
        MOD란 두 값을 나눈 <strong>나머지</strong>를 구하는 연산을 의미한다.
      </li>
    </ul>
  <li>
    MOD 연산으로 구현하는 유클리드 호제법
  </li>
    <ul>
      <li>
        1. 큰 수를 작은 수로 나누는 <strong>MOD 연산</strong>을 수행한다.
        <br>→ 2. 앞 단계에서의 작은 수와 MOD 연산 <strong>결괏값(나머지)</strong>으로 MOD 연산을 수행한다.
        <br>→ 3. 단계 2를 반복하다 <strong>나머지가 0</strong>이 되는 순간의 작은 수를 최대 공약수로 선택한다.
      </li>
    </ul>
</ul>

```python
# 최소 공배수 구하기 - 1934
#   - 최소 공배수 = 두 수의 곱 / 최대 공약수
def gcd(a ,b):
    if b == 0:
        return a
    # 재귀로 유클리드 호제법 구현
    else:
        return gcd(b, a % b)

t = int(input())

for i in range(t):
    a, b = map(int, input().split())
    result = a * b / gcd(a, b)
    print(int((result)))
```

```python
# 최대 공약수 구하기 - 1850
#   - 마지막 출력부에서 시간 복잡도가 터져서 풀지 못함.
#     → 풀이에서는 단순히 붙여서 출력하는 방법으로 처리.
def gcd(a, b):
    if b == 0:
        return a
    else:
        return gcd(b, a % b)

a, b = map(int, input().split())
result = gcd(a, b)

while result > 0:
    print(1, end='')
    result -= 1
```

```python
# 칵테일 만들기 - 1033
# < 비율 트리 문제 >
# ● 그래프 + 수학(GCD/LCM) + 비율 전파
# ● 로직
#   ● 각 간선 비율(p:q)에서 분모가 생기지 않도록 공배수(시작값)를 만든다.
#     → DFS로 비율을 전파해 각 노드의 공배수(D[i])를 계산한다.
#     → 모든 공배수(D[i])를 최대공약수(mgcd)로 나눠 최소 정수 비율로 정규화한다.

N = int(input())
# 트리 구조를 위한 이중리스트
A = [[] for _ in range(N)]
visited = [False] * (N)
# 각 노드의 간선의 비율을 만족하는 공배수리스트
D = [0] * (N)
# D리스트에 입력될 각 노드 간선 비율의 공백수 변수
lcm = 1

# 최대공약수를 구하는 유클리드 호제법 함수.
def gcd(a, b):
    if b == 0:
        return a
    else:
        return gcd(b, a % b)

# 탐색을 위한 DFS 함수 구현
def DFS(v):
    visited[v] = True
    for i in A[v]:
        next = i[0]
        if not visited[next]:
            D[next] = D[v] * i[2] // i[1]
            DFS(next)

# 각 비율을 이중리스트로 트리구조를 구현한다.
for i in range(N - 1):
    a, b, p, q = map(int, input().split())
    A[a].append((b, p, q))
    A[b].append((a, q, p))
    # 각 간선 비율의 최소공배수를 누적곱 하여 공배수를 구한다.
    #   - 각 간선들의 입장에서는 최소공배수이나 
    #   - 이를 통해 각 비율의 분모를 제거할 수 있다.
    lcm *= (p * q // gcd(p, q))

# 0번 노드의 정보만 초기화하고, 나머지 노드는 DFS와 for loop을 통해 처리한다.
D[0] = lcm
# 0부터 노드를 탐색하며 모든 노드의 간선 비율 공배수 리스트(D)를 완성
DFS(0)
mgcd = D[0]

# 나머지 노드를 순회하며 각 노드별 정보를 초기화한다.
# 각 노드별 최대공약수를 연산하며 전체 노드의 최대공약수를 구한다.
for i in range(1, N):
    mgcd = gcd(mgcd, D[i])

# 답을 출력
for i in range(N):
    print(int(D[i] // mgcd), end = ' ')
```