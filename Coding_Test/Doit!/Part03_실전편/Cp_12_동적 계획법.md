<h1>1. 동적 계획법 알아보기</h1>
<ul>
  <li>
    <strong>동적 계획법(dynamic programming)</strong>은 복잡한 문제를 <strong>여러 개의 간단한 문제</strong>로 분리하여 해결하는 방법을 의미한다.
  </li>
</ul>

<br>

<h2>1-1. 동적 계획법의 핵심 이론</h2>
<ul>
  <li>
    동적 계획법의 원리와 구현 방식
  </li>
    <ul>
      <li>
        1. 큰 문제를 작은 문제로 나눌 수 있어야 한다.
      </li>
      <li>
        2. 작은 문제들이 반복돼 나타나고 사용되며 이 작은 문제들의 결괏값은 항상 같아야 한다.
      </li>
      <li>
        3. 모든 작은 문제들은 한 번만 계산해 DP 테이블에 저장하며 추후 재사용할 때는 만들어 둔 DP 테이블을 이용한다. 이를 메모이제이션(memoization) 기법이라 한다.
      </li>
      <li>
        4. 동적 계획법은 톱-다운 방식(top-down)과 바텀-업 방식(bottom-up)으로 구현할 수 있다.
      </li>
    </ul>
  <li>
    피보나치 수열 공식
  </li>
    <ul>
      <li>
        D[N] = D[N - 1] + D[N - 2]
      </li>
    </ul>
</ul>

<br>

<h2>1-2. 동적 계획법 풀이 순서</h2>
<ul>
  <li>
    1. 동적 계획법으로 풀수 있는지 확인한다.
  </li>
    <ul>
      <li>
        n번째의 결과가 n-1번째와 n-2번째의 결과로 구할 수 있는지 확인한다.
      </li>
    </ul>
  <li>
    2. 점화식 세우기
  </li>
    <ul>
      <li>
        논리적으로 전체 문제를 나눈다.
      </li>
      <li>
        전체 문자와 부분 문제 간의 인과 관계를 파악하는 훈련이 필요하며 이는 다양한 실전 문제를 풀면서 자연스럽게 훈련된다.
      </li>
    </ul>
  <li>
    3. 메모이제이션 원리 이해하기
  </li>
    <ul>
      <li>
        메모이제이션이란 부분 문제를 풀 때 DP 테이블에 저장을 해 두고 같은 문제가 나올 때 재사용하는 것을 의미한다.
      </li>
    </ul>
  <li>
    구현 방식은 하단의 코드 블록을 활용한다.
  </li>
</ul>

```python
# 1. top-down 구현 방식
#   ● 위에서부터 문제를 파악하며 내려온다.
#   ● 주로 재귀 함수로 구현한다.
#   ● 코드의 가독성이 좋고, 이해하기 편하다.
#   ● recursion limit이 걱정 될 수 있지만 실제 코딩테스트에서 이를 넘는 경우는 거의 없다.
import sys
input = sys.stdin.readline
N = int(input())
D = [-1] * (N + 1)
D[0] = 0
D[1] = 1

def fibo(n):
    # 가존에 계산한 적이 있다면
    if D[n] != -1:
        # 해당 값을 반환한다. (재계산 X).
        return D[n]
    
    # 메모이제이션
    # 일단 DP 테이블에 값을 저장한 뒤
    D[n] = fibo(n - 2) + fibo(n - 1)

    # DP 테이블에 저장을 하였다면 값을 반환한다.
    return D[n]

fibo(N)
print(D[N])
```

```python
# 2. botton-up 구현 방식
#   ● 가장 작은 문제부터 점점 큰 문제로 확장하는 방식.
#   ● 주로 반복문의 형태로 구현한다.
import sys
input = sys.stdin.readline
N = int(input())
D = [-1] * (N + 1)
D[0] = 0
D[1] = 1

for i in range(2, N + 1):
    D[i] = D[i - 2] + D[i - 1]

print(D[N])
```

```python
# 정수를 1로 만들기 - 1463
```