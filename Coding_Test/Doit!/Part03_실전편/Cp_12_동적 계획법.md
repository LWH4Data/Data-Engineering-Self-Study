<h1>1. 동적 계획법 알아보기</h1>
<ul>
  <li>
    <strong>동적 계획법(dynamic programming)</strong>은 복잡한 문제를 <strong>여러 개의 간단한 문제</strong>로 분리하여 해결하는 방법을 의미한다.
  </li>
</ul>

<br>

<h2>1-1. 동적 계획법의 핵심 이론</h2>
<ul>
  <li>
    동적 계획법의 원리와 구현 방식
  </li>
    <ul>
      <li>
        1. 큰 문제를 작은 문제로 나눌 수 있어야 한다.
      </li>
      <li>
        2. 작은 문제들이 반복돼 나타나고 사용되며 이 작은 문제들의 결괏값은 항상 같아야 한다.
      </li>
      <li>
        3. 모든 작은 문제들은 한 번만 계산해 DP 테이블에 저장하며 추후 재사용할 때는 만들어 둔 DP 테이블을 이용한다. 이를 메모이제이션(memoization) 기법이라 한다.
      </li>
      <li>
        4. 동적 계획법은 톱-다운 방식(top-down)과 바텀-업 방식(bottom-up)으로 구현할 수 있다.
      </li>
    </ul>
  <li>
    피보나치 수열 공식
  </li>
    <ul>
      <li>
        D[N] = D[N - 1] + D[N - 2]
      </li>
    </ul>
</ul>

<br>

<h2>1-2. 동적 계획법 풀이 순서</h2>
<ul>
  <li>
    1. 동적 계획법으로 풀수 있는지 확인한다.
  </li>
    <ul>
      <li>
        n번째의 결과가 n-1번째와 n-2번째의 결과로 구할 수 있는지 확인한다.
      </li>
    </ul>
  <li>
    2. 점화식 세우기
  </li>
    <ul>
      <li>
        논리적으로 전체 문제를 나눈다.
      </li>
      <li>
        전체 문자와 부분 문제 간의 인과 관계를 파악하는 훈련이 필요하며 이는 다양한 실전 문제를 풀면서 자연스럽게 훈련된다.
      </li>
    </ul>
  <li>
    3. 메모이제이션 원리 이해하기
  </li>
    <ul>
      <li>
        메모이제이션이란 부분 문제를 풀 때 DP 테이블에 저장을 해 두고 같은 문제가 나올 때 재사용하는 것을 의미한다.
      </li>
    </ul>
  <li>
    구현 방식은 하단의 코드 블록을 활용한다.
  </li>
</ul>

```python
# 1. top-down 구현 방식
#   ● 위에서부터 문제를 파악하며 내려온다.
#   ● 주로 재귀 함수로 구현한다.
#   ● 코드의 가독성이 좋고, 이해하기 편하다.
#   ● recursion limit이 걱정 될 수 있지만 실제 코딩테스트에서 이를 넘는 경우는 거의 없다.
import sys
input = sys.stdin.readline
N = int(input())
D = [-1] * (N + 1)
D[0] = 0
D[1] = 1

def fibo(n):
    # 가존에 계산한 적이 있다면
    if D[n] != -1:
        # 해당 값을 반환한다. (재계산 X).
        return D[n]
    
    # 메모이제이션
    # 일단 DP 테이블에 값을 저장한 뒤
    D[n] = fibo(n - 2) + fibo(n - 1)

    # DP 테이블에 저장을 하였다면 값을 반환한다.
    return D[n]

fibo(N)
print(D[N])
```

```python
# 2. botton-up 구현 방식
#   ● 가장 작은 문제부터 점점 큰 문제로 확장하는 방식.
#   ● 주로 반복문의 형태로 구현한다.
import sys
input = sys.stdin.readline
N = int(input())
D = [-1] * (N + 1)
D[0] = 0
D[1] = 1

for i in range(2, N + 1):
    D[i] = D[i - 2] + D[i - 1]

print(D[N])
```

```python
# 정수를 1로 만들기 - 1463
import sys
input= sys.stdin.readline
N = int(input())
D = [0] * (N + 1)
D[1] = 0

for i in range(2, N + 1):
    # 우선 1을 뺀 연산을 가정.
    D[i] = D[i - 1] + 1

    # 2로 나눠 진다면 1을 뺀 연산과 2로 나누는 연산 중 더 작은 값을 선택
    if i % 2 == 0:
        # 이전 배수보다는 큰 수이기에 + 1을 해준다.
        D[i] = min(D[i], D[i // 2] + 1)

    # 3으로 나눠 진다면 1을 뺀 연산과 3으로 나누는 연산 중 더 작은 값을 선택
    if i % 3 == 0:
        # 이전 배수보다는 큰 수이기에 + 1을 해준다.
        D[i] = min(D[i], D[i // 3] + 1)
```

```python
# 퇴사 준비하기 - 14501
import sys
input = sys.stdin.readline
N = int(input())
D = [0] * (N + 2)  # 오늘부터 퇴사까지 벌 수 있는 최대 수익: 퇴사는 7일까지 근무를 마치고 난 후 8일 부터이기에 +2
T = [0] * (N + 1)  # 상담에 필요한 일수
P = [0] * (N + 1)  # 상담 완료 시 수입

# 상딤 일수(T)와 상담 완료 시 수입(P)를 초기화,
for i in range(1, N + 1):
    T[i], P[i] = map(int, input().split())

# 끝에서 부터 역으로 연산
#   ● 1일부터 점화식을 세울 수도 있다.
#   ● D[i + 1]은 당일 상담을 안 했을 때(혹은 하루 걸리는 상담을 했을 때)의 최대 수익이다.
for i in range(N, 0, -1):
    # 퇴사날 보다 일 수가 크다면
    if 1 + T[i] > N + 1:
        # 애초에 상담을 진행하지 못하기에 다음날과 오늘의 수익이 동일하다.
        D[i] = D[i + 1]
    # 퇴사날 보다 일 수가 적다면
    else:
        # 상담을 하는 경우(P[i] + D[i + T[i]])와 상담을 하지 않는 경우(D[i + 1])에 대해서 더 큰 수익을 선택한다.
        #   ● P[i] + D[i + T[i]]에서 T[i - 1]이 아닌 이유는 T[i]가 상담 진행 선택권(진행 O / 진행 X)이 있는 분기점이기 때문이다. 
        D[i] = max(D[i + 1], P[i] + D[i + T[i]])
```

```python
# 이친수 구하기 - 2193
import sys
iuput = sys.stdin.readline
N = int(input())
D = [[0] * 2 for _ in range(N + 1)]

# 1자리 이진수는 1 한 가지만 있음.
D[1][1] = 1
D[1][0] = 0

# 점화식으로 DP 리스트 채우기
for i in range(2, N + 1):
    D[i][0] = D[i - 1][1] + D[i - 1][0]
    D[i][1] = D[i - 1][0]

# 결과 출력  
print(D[N][0] + D[N][1])
```

```python
# 2*N 타일 채우기 - 11726
mod = 10007
N = int(input())
D = [0] * 1001
D[1] = 1
D[2] = 2

for i in range(3, N + 1):
    D[i] = (D[i - 1] + D[i - 2]) % mod

print(D[N])
```

```python
# 계단 수 구하기 - 10844
import sys
input = sys.stdin.readline
mod = 1000000000
N = int(input())
D = [[0] * 11 for _ in range(N + 1)]

# 첫 번째 계단의 경우 자기자신만 해당하기에 모든 경우를 1로 초기화
#   ● 단, 시작이 0인 경우는 없기에 D[1][0]은 그대로 0으로 초기화 한다.
for i in range(1, 10):
    D[1][i] = 1

# 계단을 하나씩 오르는 점화식
for i in range(2, N + 1):
    
    # 0인 경우는 뒤에 1밖에 오지 못함.
    #   ● 단일값 → 이전 연산에서 mod 처리됨.
    D[i][0] = D[i - 1][1] 

    # 마찬가지로 9인 경우도 뒤에 8밖에 오지 못함.
    #   ● 단일값 → 이전 연산에서 mod 처리됨.
    D[i][9] = D[i - 1][8]

    # 나머지의 경우 한 칸 위와 한 칸 아래 두 가지 경우를 count한다.
    #   ● 0과 9는 위에서 처리하였기에 1 ~ 8까지를 처리한다.
    #   ● 두 값이 더해지며 mod를 초과할 수 있기에 다시 연산을 한다.
    for j in range(1, 9):
        D[i][j] = D([i - 1][j - 1] + D[i - 1][j + 1]) % mod
    
# 정답을 구하는 연산
sum = 0
for i in range(10):
    # 정답을 구하는 과정에서도 나머지 연산을 수행.
    #   ● 덧셈을 하는 과정에서 mod를 초과할 수 있기에 다시 연산을 수행한다.
    sum = (sum + D[N][i] % mod)

# 정답 출력
print(sum)
```

```python
# 연속된 정수의 합 구하기 - 13398
N = int(input())
A = list(map(int, input().splikt()))

# 왼쪽 → 오른쪽으로 진행하며 최대 연속 합을 구함.
L = [0] * N
L[0] = A[0]
result = L[0]

for i in range(1, N):
    # 지금까지의 구간합과 다시 구간을 시작하는 것을 비교해 더 큰 값을 초기화한다.
    L[i] = max(A[i], L[i - 1] + A[i])
    # 특정 값을 제거하지 않은 경우의 최댓값을 저장한다.
    result = max(result, L[i])

# 오른쪽 → 왼쪽으로 진행하며 최대 연속 합을 구한다.
R = [0] * N
# 첫 번째 항 초기화
R[N - 1] = A[N - 1]

for i in range(N - 2, -1, -1):
    # 지금까지의 구간합과 다시 구간을 시작하는 것을 비교해 더 큰 값을 초기화
    R[i] = max(A[i], R[i + 1] + A[i])

# L[i - 1] + R[i + 1] 두 개의 구간 합 리스트를 더하면 i번째 값을 제거한 효과를 얻음.
for i in range(1, N - 1):
    temp = L[i - 1] + [i + 1]
    
    # 앞서 저장한 특정 값을 제거하지 않은 경우의 최대값과 비교해 정답을 연산.
    result = max(result, temp)

# 정답 출력
print(result)
```

```python
# 최장 공통 부분 수열 찾기 - 9252
import sys
sys.setrecursionlimit(10000)
input = sys.stdin.readline
A = list(input())
A.pop()    # \n 문자열 제거
B = list(input())
B.pop()    # \n 문자열 제거

# DP 테이블 생성.
DP = [[0] * (len(B) + 1) for i in range(len(A) + 1)]
for i in range(1, len(A) + 1):
    for j in range(1, len(B) + 1):
        
        # 같은 문자열인 경우 
        if A[i - 1] == B[j - 1]:
            # 해당 문자는 부분 문자열에 포함되기에 +1
            DP[i][j] = DP[i - 1][j - 1] + 1
        
        # 같은 문자열이 아닌 경우 
        else:
            # 부분 문자열로 추가하지 않고 A와 B 중 더 큰 부분 문자열로 초기화
            DP[i][j] = max(DP[i - 1][j], DP[i][j - 1])

# 최대 부분 문자열 출력 (첫 번째 정답)
print(DP[len(A)][len(B)])

# 두 번째 정답인 문자열 출력을 위한 LCS 함수 정의
# 출력할 문자열을 담을 리스트 초기화
Path = []

def getText(r, c):
    
    # 가로와 세로 모두 끝까지 갔다면 return
    if r == 0 or c == 0:
        return
    
    # 두 값이 같은 경우 부분 문자열이기에 추가.
    if A[r - 1] == B[c - 1]:
        Path.append(A[r - 1])
        # 다시 더 위로 탐색 시작
        getText(r - 1, c - 1)
    
    # 값이 다른 경우 더 큰 쪽으로 이동
    else:
        # 위쪽이 더 크다면 위로 이동
        if DP[r - 1][c] > DP[r][c - 1]:
            getText[r - 1, c]
        
        # 왼쪽이 더 크다면 왼쪽으로 이동
        else:
            getText(r, c - 1)

# DFS를 통해 문자열 찾기
getText(len(A), len(B))

for i in range(len(Path) - 1, -1, -1):
    print(Path.pop(i), end='')

# 제거했던 \n을 다시 붙여줌.
print()
```

```python
# 가장 큰 정사각형 찾기 - 1915

```