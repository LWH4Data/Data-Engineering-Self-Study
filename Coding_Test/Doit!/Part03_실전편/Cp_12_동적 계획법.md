<h1>1. 동적 계획법 알아보기</h1>
<ul>
  <li>
    <strong>동적 계획법(dynamic programming)</strong>은 복잡한 문제를 <strong>여러 개의 간단한 문제</strong>로 분리하여 해결하는 방법을 의미한다.
  </li>
</ul>

<br>

<h2>1-1. 동적 계획법의 핵심 이론</h2>
<ul>
  <li>
    동적 계획법의 원리와 구현 방식
  </li>
    <ul>
      <li>
        1. 큰 문제를 작은 문제로 나눌 수 있어야 한다.
      </li>
      <li>
        2. 작은 문제들이 반복돼 나타나고 사용되며 이 작은 문제들의 결괏값은 항상 같아야 한다.
      </li>
      <li>
        3. 모든 작은 문제들은 한 번만 계산해 DP 테이블에 저장하며 추후 재사용할 때는 만들어 둔 DP 테이블을 이용한다. 이를 메모이제이션(memoization) 기법이라 한다.
      </li>
      <li>
        4. 동적 계획법은 톱-다운 방식(top-down)과 바텀-업 방식(bottom-up)으로 구현할 수 있다.
      </li>
    </ul>
  <li>
    피보나치 수열 공식
  </li>
    <ul>
      <li>
        D[N] = D[N - 1] + D[N - 2]
      </li>
    </ul>
</ul>

<br>

<h2>1-2. 동적 계획법 풀이 순서</h2>
<ul>
  <li>
    1. 동적 계획법으로 풀수 있는지 확인한다.
  </li>
    <ul>
      <li>
        n번째의 결과가 n-1번째와 n-2번째의 결과로 구할 수 있는지 확인한다.
      </li>
    </ul>
  <li>
    2. 점화식 세우기
  </li>
    <ul>
      <li>
        논리적으로 전체 문제를 나눈다.
      </li>
      <li>
        전체 문자와 부분 문제 간의 인과 관계를 파악하는 훈련이 필요하며 이는 다양한 실전 문제를 풀면서 자연스럽게 훈련된다.
      </li>
    </ul>
  <li>
    3. 메모이제이션 원리 이해하기
  </li>
    <ul>
      <li>
        메모이제이션이란 부분 문제를 풀 때 DP 테이블에 저장을 해 두고 같은 문제가 나올 때 재사용하는 것을 의미한다.
      </li>
    </ul>
  <li>
    구현 방식은 하단의 코드 블록을 활용한다.
  </li>
</ul>

```python
# 1. top-down 구현 방식
#   ● 위에서부터 문제를 파악하며 내려온다.
#   ● 주로 재귀 함수로 구현한다.
#   ● 코드의 가독성이 좋고, 이해하기 편하다.
#   ● recursion limit이 걱정 될 수 있지만 실제 코딩테스트에서 이를 넘는 경우는 거의 없다.
import sys
input = sys.stdin.readline
N = int(input())
D = [-1] * (N + 1)
D[0] = 0
D[1] = 1

def fibo(n):
    # 가존에 계산한 적이 있다면
    if D[n] != -1:
        # 해당 값을 반환한다. (재계산 X).
        return D[n]
    
    # 메모이제이션
    # 일단 DP 테이블에 값을 저장한 뒤
    D[n] = fibo(n - 2) + fibo(n - 1)

    # DP 테이블에 저장을 하였다면 값을 반환한다.
    return D[n]

fibo(N)
print(D[N])
```

```python
# 2. botton-up 구현 방식
#   ● 가장 작은 문제부터 점점 큰 문제로 확장하는 방식.
#   ● 주로 반복문의 형태로 구현한다.
import sys
input = sys.stdin.readline
N = int(input())
D = [-1] * (N + 1)
D[0] = 0
D[1] = 1

for i in range(2, N + 1):
    D[i] = D[i - 2] + D[i - 1]

print(D[N])
```

```python
# 정수를 1로 만들기 - 1463
import sys
input= sys.stdin.readline
N = int(input())
D = [0] * (N + 1)
D[1] = 0

for i in range(2, N + 1):
    # 우선 1을 뺀 연산을 가정.
    D[i] = D[i - 1] + 1

    # 2로 나눠 진다면 1을 뺀 연산과 2로 나누는 연산 중 더 작은 값을 선택
    if i % 2 == 0:
        # 이전 배수보다는 큰 수이기에 + 1을 해준다.
        D[i] = min(D[i], D[i // 2] + 1)

    # 3으로 나눠 진다면 1을 뺀 연산과 3으로 나누는 연산 중 더 작은 값을 선택
    if i % 3 == 0:
        # 이전 배수보다는 큰 수이기에 + 1을 해준다.
        D[i] = min(D[i], D[i // 3] + 1)
```

```python
# 퇴사 준비하기 - 14501
import sys
input = sys.stdin.readline
N = int(input())
D = [0] * (N + 2)  # 오늘부터 퇴사까지 벌 수 있는 최대 수익: 퇴사는 7일까지 근무를 마치고 난 후 8일 부터이기에 +2
T = [0] * (N + 1)  # 상담에 필요한 일수
P = [0] * (N + 1)  # 상담 완료 시 수입

# 상딤 일수(T)와 상담 완료 시 수입(P)를 초기화,
for i in range(1, N + 1):
    T[i], P[i] = map(int, input().split())

# 끝에서 부터 역으로 연산
#   ● 1일부터 점화식을 세울 수도 있다.
#   ● D[i + 1]은 당일 상담을 안 했을 때(혹은 하루 걸리는 상담을 했을 때)의 최대 수익이다.
for i in range(N, 0, -1):
    # 퇴사날 보다 일 수가 크다면
    if 1 + T[i] > N + 1:
        # 애초에 상담을 진행하지 못하기에 다음날과 오늘의 수익이 동일하다.
        D[i] = D[i + 1]
    # 퇴사날 보다 일 수가 적다면
    else:
        # 상담을 하는 경우(P[i] + D[i + T[i]])와 상담을 하지 않는 경우(D[i + 1])에 대해서 더 큰 수익을 선택한다.
        #   ● P[i] + D[i + T[i]]에서 T[i - 1]이 아닌 이유는 T[i]가 상담 진행 선택권(진행 O / 진행 X)이 있는 분기점이기 때문이다. 
        D[i] = max(D[i + 1], P[i] + D[i + T[i]])

```