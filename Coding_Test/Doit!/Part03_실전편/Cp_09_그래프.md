<h1>1. 그래프의 표현</h1>

```python
# 2차원 리스트 생성
# a) 추천 방법==========================================
A = [[0 for col in range(4)] for row in range(3)]

# b) 얕은 복사==========================================
#   ● 얕은 복사로 인해 각 행이 독립적이지 않고 같은 객체를 참조하는 문제가 있다.
A = [[0] * 4] * 3 
```

<br>

<h2>1-1. 에지 리스트</h2>
<ul>
  <li>
    <strong>에지 리스트(edge list)</strong>는 <strong>에지</strong>를 중심으로 그래프를 표현한다.
  </li>
  <li>
    에지 리스트는 리스트에 <strong>출발 노드</strong>와 <strong>도착 노드</strong>를 저장하여 에지를 표현한다.
  </li>
    <ul>
      <li>
        <strong>가중치</strong>가 있는 경우에는 출발 노드, 도착 노드 그리고 가중치를 저장하여 가중치가 있는 에지를 표현한다.
      </li>
    </ul>
</ul>

<h3>1-1-1. 에지 리스트로 가중치 없는 그래프 구현하기</h3>
<ul>
  <li>
    가중치가 없는 그래프는 <strong>출발 노드</strong>와 <strong>도착 노드</strong>만 표현하면 되기에 <strong>리스트의 열은 두 개</strong>로 충분하다.
  </li>
  <li>
    1에서 2로 뻗는 에지는 <strong>[1, 2]</strong>로, 4에서 5로 뻗는 에지는 [4, 5]로 표현한다.
  </li>
    <ul>
      <li>
        방향이 있는 에지는 그래프의 순서에 맞게 노드를 저장한다.
      </li>
    </ul>
  <li>
    노드를 리스트에 저장하여 에지를 표현하기 때문에 에지 리스트라 한다.
  </li>
</ul>

<br>

<h2>1-2. 에지 리스트로 가중치 있는 그래프 표현하기</h2>
<ul>
  <li>
    가중치가 있는 그래프는 <strong>열을 세 개</strong>로 늘려 <strong>세 번째 열</strong>에 가중치를 저장하면 된다.
  </li>
  <li>
    1에서 2로 향하는 가중치가 8인 에지는 <strong>[1, 2, 8]</strong>로 표현한다.
  </li>
  <li>
    가중치가 있는 에지 리스트는 <strong>특정 노드</strong>와 관련된 에지를 탐색하지 쉽지 않다.
  </li>
    <ul>
      <li>
        따라서 가중치 에지 리스트는 <strong>노드 사이의 최단 거리</strong>를 구하는 벨만-포드나 최소 신장 트리를 찾는 클루스칼 알고리즘에 사용한다.
      </li>
      <li>
        반면 노드 중심 알고리즘에는 잘 사용하지 않는다.
      </li>
    </ul>
</ul>

<br><br>

<h2>1-3. 인접 행렬</h2>
<ul>
  <li>
    <strong>인접 행렬(adjacency matrix)</strong>은 <strong>2차원 리스트</strong>를 자료구조로 이용하여 그래프를 표현한다.
  </li>
  <li>
    인접 행렬은 에지 리스트와 다르게 <strong>노드 중심</strong>으로 그래프를 표현한다.
  </li>
</ul>

<h3>1-3-1. 인접 행렬로 가중치 없는 그래프 표현하기</h3>
<ul>
  <li>
    노드 1에서 노드 2로 향하는 에지는 인접 행렬에서 <strong>1행 2열</strong>에 1을 저장하는 방식으로 표현한다.
  </li>
    <ul>
      <li>
        value로 1을 저장하는 이유는 가중치가 없기 때문이다.
      </li>
    </ul>
</ul>

<h3>1-3-2. 인접 행렬로 가중치 있는 그래프 표현하기</h3>
<ul>
  <li>
    가중치가 있는 그래프는 2차원 배열의 value에 <strong>1대신 가중치를 저장</strong>한다.
  </li>
  <li>
    두 노드를 연결하는 에지의 여부와 가중치를 리스트에 직접 접근하면 바로 확인할 수 있다는 장점이 있다.
  </li>
    <ul>
      <li>
        그러나 <strong>노드와 관련된 에지</strong>를 탐색하려면 N번 접근해야 하기에 <strong>시간 복잡도</strong>가 인접 리스트에 비해 느리다.
      </li>
      <li>
        또 노드 개수에 비해 에지가 적을 때에는 <strong>공간 효율성</strong>이 떨어진다. (희소 행렬).
      </li>
    </ul>
</ul>

<br>

<h2>1-4. 인접 리스트</h2>
<ul>
  <li>
    <strong>인접 리스트(adjaccency list)</strong>는 <strong>파이썬의 리스트</strong>를 이용해 그래프를 표현한다.
  </li>
  <li>
    <strong>노드 개수</strong>만큼 리스트를 선언한다.
  </li>
  <li>
    리스트의 <strong>input data 형태</strong>는 문제의 <strong>조건에 맞게</strong> 설정한다.
  </li>
</ul>

<h3>1-4-1. 인접 리스트로 가중치 없는 그래프 표현하기</h3>
<ul>
  <li>
    가중치가 없는 경우 인접 리스트 N번 노드와 연결된 노드들은 리스트의 <strong>index N</strong>에 연결된 노드 개수만큼 <strong>리스트에 append</strong>하는 방식으로 표현한다.
  </li>
    <ul>
      <li>
        1번 노드에 2, 3번 노드가 연결돼 있다면 A[1]에 [2, 3]을 연결한다.
      </li>
    </ul>
</ul>

<h3>1-4-2. 인접 리스트로 가중치 있는 그래프 표현하기</h3>
<ul>
  <li>
    가중치가 있는 경우 input data를 <strong>2개(도착 노드, 가중치)</strong>로 사용한다. 또한 아래의 장점들로 실제 코딩 테스트에서 많이 활용된다.
  </li>
  <li>
    노드와 연결된 에지를 탐색하는 <strong>시간</strong>이 매우 뛰어나다.
  </li>
  <li>
    노드 개수가 커져도 공간 효율성이 좋아 <strong>메모리</strong> 초과 에러도 발생하지 않는다.
  </li>
</ul>

```python
# 특정 거리의 도시 찾기 - 18352
import sys
from collections import deque
input = sys.stdin.readline

N, M, K, X = map(int, input().split())
A = [[] for _ in range(N + 1)]
answer = []
# visited로 거리를 관리할 것이기에 -1을 기본값으로 한다.
visited = [-1] * (N + 1)

def BFS(v):
    queue = deque()
    queue.append(v)
    visited[v] += 1
    while queue:
        now_Node = queue.popleft()
        for i in A[now_Node]:
            if visited[i] == -1:
                visited[i] = visited[now_Node] + 1
                queue.append(i)

for _ in range(M):
    S, E = map(int, input().split())
    A[S].append(E)

BFS(X)

for i in range(N + 1):
    if visited[i] == K:
        answer.append(i)

if not answer:
    print(-1)
else:
    answer.sort()
    for i in answer:
        print(i)
```

```python
# 효율적으로 해킹하기 - 1325
import syt
from collections import deque
input = sys.stdin.readline
N, M = map(int, input().split())
A = [[] for _ in range(N + 1)]
answer = [0] * (N + 1)

def BFS(v):
    visited = [False] * (N + 1)
    queue = deque()
    queue.append(v)
    visited[v] = True
    while queue:
        now_Node = queue.popleft()
        for i in A[now_Node]:
            if not visited[i]:
                visited[i] = True
                # 신규 노드 인덱스의 정답 리스트값을 증가.
                answer[i] += 1
                queue.append(i)

for i in range(M):
    S, E = map(int, input().split())
    A[S].append(E)

# 모든 노드에서 BFS 시행
for i in range(1, N + 1):
    BFS(i)

maxVal = max(answer)
for i in range(1, N + 1):
    if maxVal == answer[i]:
        print(i, end=' ')
```

```python
# 이분 그래프 판별하기 - 1707
#   ● 홀수 길이 사이클이 없는 모든 그래프가 이분 그래프이다.
import sys
sys.setrecursionlimit(10**6)
input = sys.stdin.readline
N = int(input())
IsEven = True

def DFS(node):
    global IsEven
    visited[node] = True
    for i in A[node]:
        if not visited[i]:
            # 인접 노드는 같은 집합이 될 수 없기에 다른 집합으로 처리
            check[i] = (check[node] + 1) % 2
            DFS(i)
        # 이미 방문한 노드가 현재 내 노드와 같은 집합이면 이분 그래프가 아님.
        elif check[node] == check[i]:
            IsEven = False

for _ in range(N):
    V, E = map(int, input().split())
    A = [[] for _ in range(V + 1)]
    visited = [False] * (V + 1)
    check = [0] * (V + 1)
    IsEven = True

    # 인접 리스트로 그래프 저장
    for i in range(E):
        Start, End = map(int, input().split())
        A[Start].append(End)
        A[End].append(Start)
    
    # 주어진 그래프가 항상 1개가 아니므로 모든 노드에서 수행
    for i in range(1, V + 1):
        if IsEven:
            DFS(i)
        else:
            break
    
    if IsEven:
        print("YES")
    else:
        print("NO")
```

```python
# 물의 양 구하기 - 2251
#   ● 두 리스트를 활용하여 A, B, C에서 발생할 수 있는 6개의 이동 케이스를 정의한다.
#   ● 각 간선을 탐색하며 동적으로 변하는 그래프를 BFS로 탐색한다.
from collections import deque

# 간선 구현 (0: A, 1: B, 2: C)
# 보내는 노드
Sender = [0, 0, 1, 1, 2, 2] # 0 → 1 = A → B
# 받는 노드
Receiver = [1, 2, 0, 2, 0, 1]
# A, B, C의 입력을 받는다.
now = list(map(int, input().split()))
# 방문 그래프(A와 B 모두 1 ≤ A, B ≤ 200의 범위이기에 201 × 201의 크기를 이용).
visited = [[False for j in range(201)] for _ in range(201)]
# C 또한 1 ≤ A, B ≤ 200 범위이기에 A와 B에 따른 결과를 201 길이의 배열에 저장한다.
answer = [False] * 201

# 탐색 BFS
def BFS():
    queue = deque()
    # 첫 번째 간선을 입력한다.
    queue.append((0, 0))
    visited[0][0] = True
    # 현재 C의 값도 체크한다.
    answer[now[2]] = True

    while queue:
        now_Node = queue.popleft()
        # 탐색할 때의 물의 양으로 그래프를 동적으로 업데이트 한다.
        A = now_Node[0]
        B = now_Node[1]
        # C의 현재 물의 양은 A와 B로 결정한다.
        C = now[2] - A - B
        
        # 모든 경로를 탐색한다.
        # A → B, A → C, B → A, ..., C → B
        for k in range(6):
            # 물을 옮긴 후의 상태를 업데이트 한다. 
            next = [A, B, C]
            # 물을 이동 후 물의 양을 업데이트
            next[Receiver[k]] += next[Sender[k]]
            # 물을 옮긴쪽은 일단 다 비웠다고 가정한다.
            next[Sender[k]] = 0

            # 만약 옮기는 쪽의 용기가 더 크다면 
            if next[Sender[K]] > now[Receiver[k]]:
                # 받는 쪽에서 초과하는 양의 물을 보내는 쪽에 넣고
                next[Sender[k]] = next[Receiver[k]] - now[Receiver[k]]
                # 받는 쪽의 물은 용기의 크기에 맞추어 업데이트 한다.
                next[Receiver[k]] = now[Receiver[k]]
            
            # 방문한 적이 없는 간선이라면
            if not visited[next[0]][next[1]]:
                # 방문체크 후 탐색할 간선에 넣는다.
                visited[next[0]][next[1]]
                queue.append((next[0], next[1]))

                # A가 0인 경우 해당하는 C의 index에 True를 초기화한다.
                if next[0] == 0:
                    answer[next[2]] = True

BFS()

# answer 배열을 순회하면서 True인 index를 출력한다.
for i in range(len(answer)):
    if answer[i]:
        print(i, end=' ')
```

<br><br>

<h1>2. 유니온 파인드</h1>
<ul>
  <li>
    <strong>유니온 파인드(union-find)</strong>는 다음 두 가지 연산으로 구성되어 있다.
  </li>
    <ul>
      <li>
        <strong>union 연산</strong>: 여러 노드 중 특정 두 개의 노드를 연결해 하나의 집합으로 <strong>묶는다</strong>.
      </li>
      <li>
        <strong>find 연산</strong>: 두 노드가 <strong>같은 집합</strong>에 속해 있는지 확인한다.
      </li>
    </ul>
</ul>

<br>

<h2>2-1. 유니온 파인드의 핵심 이론</h2>
<ul>
  <li>
    union과 find 두 연산을 완벽히 이해하는 것이 핵심이다.
  </li>
    <ul>
      <li>
        <strong>union 연산</strong>
      </li>
        <ul>
          <li>
            각 노드가 속한 집합을 1개로 합친다.
          </li>
          <li>
            노드 a, b가 a ∈ A, b ∈ B일때 union(a, b)는 <strong>A ∪ B</strong>를 의미한다.
          </li>
        </ul>
      <li>
        <strong>find 연산</strong>
      </li>
        <ul>
          <li>
            특정 노드 a에 관해 a가 속한 집합의 대표 노드를 반환한다.
          </li>
          <li>
            노드 a가 a ∈ A 일 때 find(a)는 A 집합의 대표 노드를 반환한다.
          </li>
        </ul>
    </ul>
</ul>

<h3>2-1-1. 유니온 파인드의 원리 이해하기</h3>
<ul>
  <li>
    유니온 파인드를 표현하는 일반적인 방법은 <strong>1차원 리스트</strong>를 이용하는 것이다.
  </li>
  <li>
    처음에는 각 노드가 연결되어 있지 않기에 <strong>각 노드</strong>가 대표 노드가 된다.
  </li>
    <ul>
      <li>
        각 노드가 모두 대표 노드이기에 리스트를 <strong>자신의 index값</strong>으로 초기화한다.
      </li>
    </ul>
  <li>
    두 개의 노드를 선택해 각각의 대표 노드를 찾아 연결하는 union 연산을 수행한다.
  </li>
    <ul>
      <li>
        1이 대표 노드, 4가 자식 노드라면 리스트의 index = 4의 값을 1로 변경한다. 
      </li>
      <li>
        대표 노드가 아닌 노드끼리 연결할 때에는 각각의 <strong>대표 노드를 찾아 연결</strong>한다.
      </li>
    </ul>
  <li>
    find 연산은 자신이 속한 집합의 <strong>대표 노드를 찾는</strong> 연산이다.
  </li>
    <ul>
      <li>
        단순히 찾는 역할만 하는 것이 아니라 그래프를 <strong>정돈</strong>하고 <strong>시간 복잡도</strong>를 줄인다.
      </li>
        <ul>
          <li>
            연산을 할 때 거치는 노드들이 대표 노드와 <strong>바로 연결</strong>되기에 이후 노드와 관련된 find 연산 속도는 <strong>O(1)</strong>이 되어 <strong>경로 압축</strong>의 효과가 있다.
          </li>
            <ul>
              <li>
                경로 압축이란 실제 그래프에서 여러 노드를 거쳐야 하는 경로에서 <strong>그래프를 변형</strong>해 더 짧은 경로로 갈 수 있도록 함으로써 시간 복잡도를 효과적으로 줄이는 방법을 의미한다.
              </li>
            </ul>
        </ul>
      <li>
        <strong>find 연산의 작동 원리</strong>
      </li>
        <ul>
          <li>
            1. 대상 노드 리스트에 index값과 value값 동일한지 확인한다.
            <br>→ 2. 동일하지 않다면 value값이 가리키는 index의 위치로 이동한다.
            <br>→ 3. 이동 위치의 index값과 value 값이 같을 때까지 1 ~ 2를 반복한다. (재귀 구현).
            <br>→ 4. 대표 노드에 도달하면 재귀 함수를 빠져나오면서 모든 노드값을 대표 노드값으로 변경한다.
          </li>
        </ul>
    </ul>
</ul>

```python
# 집합 표현하기 - 1717
import sys
input = sys.stdin.readline
sys.setrecursionlimit(100000)
N, M = map(int, input().split())
parent = [0] * (N + 1)

def find(a):
    
    # 자기자신이기에 그대로 출력
    if a == parent[a]:
        return a
    # value 값을 따라 속한 집합(root)를 찾기위해 재귀를 활용한다.
    else:
        # 재귀를 빠져 나오면서 모든 경로 노드의 value를 root 노드로 변환한다. (경로 압축).
        parent[a] = find(parent[a])
        return parent[a]

def union(a, b):
    a = find(a)
    b = find(b)
    # 일반적으로 union을 진행하는 과정에서 대소관계는 상관없다.
    if a != b:
      parent[b] = a

def checkSampe(a, b):
    a = find(a)
    b = find(b)
    if a == b:
        return True
    return False

# union-find 그래프 생성
for i in range(0, N + 1):
    parent[i] = i

for i in range(M):
    question, a, b = map(int, input().split())
    if question == 0:
        union(a, b)
    else:
        if checkSame(a, b):
            print("YES")
        else:
            print("NO")
```

```python
# 여행 계획 짜기 - 1976
N = int(input())
M = int(input())
dosi = [[0 for j in range(N + 1)] for i in range(N + 1)]

def find(a):
    # 최하단 DFS에서 반환
    if a == parent[a]:
        return a
    else:
        parent[a] = find(parent[a])
        # 이후 각 DFS에서 결과를 반환하며 경로 압축.
        return parent[a]

def union(a, b):
    a = find(a)
    b = find(b)
    if a != b:
        # 루트 노드끼리 연결돼야 함.
        parent[b] = a

for i in range(1, N + 1):
    dosi[i] = list(map(int, input().split()))
    # 매 입력마다 index 0에 0을 삽입하여 index를 보정한다.
    dosi[i].insert(0, 0)

route = list(map(int, input().split()))
# 마찬가지로 도시 목록에도 index 0에 0을 삽입하여 index를 보정한다.
route.insert(0, 0)

for i in range(1, N + 1):
    parent[i] = i

for i in range(1, N + 1):
    for j in range(1, N + 1):
        if dosi[i][j] == 1:
            union(i, j)

index = find(route[1])
  
isConnect = True
for i in range(1, len(route)):
    if index != find(route)[1]:
        isConnect = False
        break

if isConnect:
    print("YES")
else:
    print("No") 
```

```python
# 거짓말쟁이가 되긴 싫어 - 1043
N, M = map(int, input().split())
trueP = list(map(int, input().split()))
T = trueP[0]
# 첫 번째 원소를 삭제한다. (모든 원소는 좌측으로 당겨짐).
del trueP[0]
result = 0
party = [[] for _ in range(M)]

def find(a):
    if a == parent[a]:
        return a
    else:
        parent[a] = find(parent[a])
        return parent[a]

def union(a, b):
    a = find(a)
    b = find(b)
    if a != b:
      parent[b] = a

for i in range(M):
    party[i] = list(map(int, input().split()))
    del party[i][0]

parent = [0] * (N + 1)

for i in range(N + 1):
    parent[i] = i

for i in range(M):
    firstPeople = party[i][0]
    for j in range(1, len(party[i])):
        union(firstPeople, party[i][j])

for i in range(M):
    isPossible = True
    firstPeople = party[i][0]
    for j in range(len(trueP)):
        if find(firstPeople) == find(trueP[j]):
            isPossible = False
            break
    if isPossible:
        result += 1

print(result)
```

<br><br>

<h1>3. 위상 정렬</h1>
<ul>
  <li>
    <strong>위상 정렬(topology sort)</strong>은 <strong>사이클이 없는 방향 그래프</strong>에서 <strong>노드 순서</strong>를 찾는 알고리즘이다.
  </li>
  <li>
    시간 복잡도는 <strong>O(V + E)</strong> 이다.
  </li>
  <li>
    위상 정렬은 항상 <strong>유일한 값</strong>으로 정렬되지 않는다.
  </li>
</ul>

<br>

<h2>3-1. 위상 정렬의 핵심 이론</h2>
<h3>3-1-1. 위상 정렬의 원리 이해하기</h3>
<ul>
  <li>
    각 노드의 진입 차수를 계산하여 일차원 리스트의 index-value로 표현한다.
  </li>
    <ul>
      <li>
        <strong>진입 차수(in-degree)</strong>란 <strong>자신을 가리키는 에지의 개수</strong>를 의미한다.
      </li>
    </ul>
  <li>
    <strong>진입 차수가 0</strong>인 노드를 선택하고, 선택된 노드를 <strong>정렬 리스트에 저장</strong>한다.
  </li>
  <li>
    정렬 리스트에 저장된 노드가 가리키는 자식 노드들의 진입 차수를 <strong>1씩 차감</strong>한다.
  </li>
  <li>
    이후 위의 과정을 <strong>반복</strong>하여 가능한 모든 노드의 진입 차수를 제거하는 것을 반복하면 끝난다.
  </li>
</ul>

```python
# 줄 세우기 - 2252
from collections import deque
N, M = map(int, input().split())
A = [[] for _ in range(N + 1)]
indegree = [0] * (N + 1)

# defaultdict가 아닌 이차원 리스트로 자료구조를 구현
for i in range(M):
    S, E = map(int, input().split())
    A[S].append(E)
    indegree[E] += 1

queue = deque()

# 탐색을 위해 진입차수가 0인 노드를 queue에 추가.
for i in range(1, N + 1):
    if indegree[i] == 0:
        queue.append(i)

# 탐색 진행
while queue:
    now = queue.popleft()
    # 언패킹을 안 쓰고 출력을 조정하여 답을 출력.
    print(now, end = ' ')
    for next in A[now]:
        indegree[next] -= 1
        if indegree[next] == 0:
            queue.append(next)
```

```python
# 게임 개발하기 - 1516
#   ● 나는 진입 차수가 0인 모든 노드를 개별 위상 정렬 해야한다 생각함.
#   ● 실제로 queue에 0인 모든 노드를 넣고 위상 정렬을 수행하면 모든
#     진입 차수가 0인 노드에 대한 경로의 정보블 얻음.
from collections import deque

N = int(input())
A = [[] for _ in range(N + 1)]
# 진입 차수
indegree = [0] * (N + 1)
# 자기 자신을 찾는데 걸리는 시간.
selfBuild = [0] * (N + 1)

for i in range(1, N + 1):
    inputList = list(map(input().split()))
    # 개별 건물을 짓는데 필요한 시간을 저장한다.
    selfBuild[i] = (inputList[0])
    index = 1
    # 반복을 통해 인접 리스트를 초기화한다.
    while True:
        preTemp = inputList[index]
        index += 1
        if preTemp == -1:
            break
        A[preTemp].append(i)
        # 각 노드별 진입 차수 저장
        indegree[i] += 1

queue = deque()

for i in range(1, N + 1):
    if indegree[i] == 0:
        queue.append(i)

result = [0] * (N + 1)

while queue:
    now = queue.popleft()
    for next in A[now]:
        indegree[next] -= 1
    # 시간 업데이트
    result[next] = max(result[next], result[now] + selfBuild[now])
    if indegree[next] == 0:
        queue.append(next)

for i in range(1, N + 1):
    print(result[i] + selfBuild[i])
```

```python
# 임계 경로 구하기 - 1948
#   ● 기본 위상 정렬에 'edge 뒤집기'라는 개념이 필요한 문제.
#   ● edge 뒤집기는 그래프 문제에 종종 나온다.
import sys
from collections import deque
input = sys.stdin.readline

N = int(input())
M = int(input())
# 인접 리스트 데이터 저장
A = [[] for _ in range(N + 1)]
# 총 간선의 수를 세기위한 역방향 인접 리스트 데이터 저장
reverseA = [[] for _ in range(N + 1)]
indegree = [0] * (N + 1)

for i in range(M):
    S, E, V = map(int, input().split())
    A[S].append((E, V))
    reverseA[E].append((S, V))
    indegree[E] += 1

startDosi, endDosi = map(int, input().split())

queue = deque()
queue.append(startDosi)
result = [0] * (N + 1)

while queue:
    now = queue.popleft()
    for next in A[now]:
        indegree[next[0]] -= 1
        result[next[0]] = max(result[next[0]], result[now] + next[1])
        if indegree[next[0]] == 0:
            queue.append(next[0])

resultCount = 0
visited = [False] * (N + 1)
queue.clear()
queue.append(endDosi)
visited[endDosi] = True

while queue:
    now = queue.popleft()
    for next in reverseA[now]:
        if result[next[0]] + next[1] == result[now]:
            resultCount += 1
            if not visited[next[0]]:
                visited[next[0]] = True
                queue.append(next[0])

print(result[endDosi])
print(resultCount)
```

<br><br>

<h1>4. 다익스트라</h1>
<ul>
  <li>
    <strong>다익스트라(dijkstra)</strong> 알고리즘은 그래프에서 <strong>최단 거리</strong>를 구하는 알고리즘이다.
  </li>
    <ul>
      <li>
        출발 노드와 모든 노드 간의 <strong>최단 거리</strong>를 탐색한다.
      </li>
      <li>
        에지는 모두 <strong>양수</strong>이다.
      </li>
      <li>
        시간 복잡도는 <strong>O(ElogV)</strong>이다.
      </li>
    </ul>
</ul>

<br>

<h2>4-1. 다익스트라 알고리즘의 핵심 이론</h2>
<ul>
  <li>
    <strong>구현 단계</strong>
  </li>
    <ul>
      <li>
        1. <strong>인접 리스트</strong>로 그래프 구현하기.
      </li>
        <ul>
          <li>
            인접 행렬로 구현이 가능하지만, 시간 복잡도와 N의 크기가 클 것을 고려해 인접 리스트를 선택하는 것이 좋다.
          </li>
          <li>
            인접 리스트에 연결한 input 데이터의 자료형은 (노드, 가중치)로 사용할 수도 있다.
          </li>
        </ul>
      <li>
        2. 최단 거리 리스트 초기화하기
      </li>
        <ul>
          <li>
            최단 거리 리스트르 만들고, 출발 노드는 <strong>0</strong>, 이외의 노드는 <strong>무한</strong>으로 초기화 한다.
          </li>
        </ul>
      <li>
        3. 값이 가장 작은 노드 고르기
      </li>
        <ul>
          <li>
            최단 거리 리스트에서 현재 값이 가장 작은 노드를 골라 <strong>시작점</strong>으로 한다.
          </li>
        </ul>
      <li>
        4. 최단 거리 리스트 업데이트하기
      </li>
        <ul>
          <li>
            선택된 노드에서 연결된 에지의 값을 바탕으로 다른 노드의 값을 업데이트한다.
          </li>
          <li>
            연결 노드의 최단 거리는 두 값 중 더 작은 값으로 업데이트 한다.
          </li>
            <ul>
              <li>
                최단 거리 업데이트에는 Min(선택 노드의 최단 거리 리스트의 값 + 에지 가중치, 연결 노드의 최단 거리 리스트의 값)으로 처리한다.
              </li>
            </ul>
        </ul>
      <li>
        5. 과정 3 ~ 4를 반복하며 최단 거리 리스트를 완성한다. 
      </li>
    </ul>
  <li>
    우선순위 큐는 큐의 첫 번째 원소부터 순차적으로 정렬을 적용하기에 이 점에 유의하여 원소를 입력해야 한다.
  </li>
</ul>

```python
# 최단 경로 구하기 - 1753
import sys
input = sys.stdin.readline
from queue import PriorityQueue

V, E = map(int, input().split())
K = int(input())
# maxsize는 int형이 가질 수 있는 최대값을 제공한다.
distance = [sys.maxsize] * (V + 1)
visited = [False] * (V + 1)
myList = [[] for _ in range(V + 1)]
q = PriorityQueue()

for _ in range(E):
    u, v, w = map(int, input().split())
    myList[u].append((v, w))
  
q.put((0, K))
distance[K] = 0

while q.qsize() > 0:
    current = q.get()
    c_v = current[1]
    # (거리, 노드) 순즈올 정렬되기에 한 번 방문한 경우 최단 거리가 된다.
    if visited[c_v]:
        continue
    visited[c_v] = True
    for tmp in myList[c_v]:
        next = tmp[0]
        value = tmp[1]
        if distance[next] > distance[c_v] + value:
            distance[next] = distance[c_v] + value
        q.put((distance[next], next))

for i in range(1, V + 1):
    if visited[i]:
        print(distance[i])
    else:
        print("INF")
```

```python
# 최소 비용 구하기 - 1916
import sys
from queue import PriorityQueue
input = sys.stdin.readline

N = int(input())
M = int(input())
myList = [[] for _in range(N + 1)]
dist = [sys.maxsize] * (N + 1)
visit = [False] * (N + 1)

for _ in range(M):
    start, end, weight = map(int, input().split())
    myList[start].append((end, weight))

start_index, end_index = map(int, input().split())

def dijkstra(start, end):
    pq = PriorityQueue()
    pq.put((0, start))
    # 우선수누이에 데이터를 최단 거리, 노드 순으로 삽입
    dist[start] = 0
    while pd.qsize() > 0:
        nowNode = pd.get()
        now = nowNode[1]
        if now visit[now]:
            visit[now] = True
            for n in myList[now]:
                if dist[n[0]] > dist[now] + n[1]:
                    dist[n[0]] = dist[now] + n[1]
                    pq.put((dist[n[0]], n[0]))

    return dist[end]

print(dijkstra(start_index, end_index))
```

```python
# K번째 최단 경로 찾기 - 1854
import sys
import heapq
input = sys.stdin.readline
N, M, K = map(int, input().split())
W = [[] for _ in range(N + 1)]
# 거리 리스트를 충분히 큰 값으로 초기화
distance = [[sys.maxsize] * K for _ in range(N + 1)]

# defaultdict를 사용하지않고 이중 리스트로 그래프 구현.
for _ in range(M):
    a, b, c = map(int, input().split())
    W[a].append((b, c))

# 가중치를 우선으로 (가중치, 탐색 시작 노드) 순으로 입력.
pq = [(0, 1)]

# 변형 다익스트라 시작
while pq:
    cost, node = heapq.heappop(pq)
    for nNode, nCost in W[node]:
        sCost = cost + nCost
        if distance[nNode][K - 1] > sCost:
            # 가장 마지막 노드를 업데이트
            distance[nNode][K - 1] = sCost
            # 정렬하여 다시 가장 마지막 노드를 sys.maxsize로 함.
            distance[nNode].sort()
            heapq.heappush(pq, [sCost, nNode])

for i in range(1, N + 1):
    if distance[i][K - 1] == sys.maxsize:
        print(-1)
    else:
        print(distance[i][K - 1])
```

<h1>5. 벨만-포드</h1>
<ul>
  <li>
    <strong>벨만-포드(bellman-ford-moore)</strong> 알고리즘은 <strong>최단 거리</strong>를 구하는 알고리즘이다.
  </li>
  <li>
    <strong>특정 출발 노드</strong>에서 <strong>다른 모든 노드</strong>까지의 최단 경로 탐색.
  </li>
  <li>
    <strong>음수 가중치 에지</strong>가 있어도 가능하다.
  </li>
  <li>
    전체 그래프에서 <strong>음수 사이클 존재 여부</strong>를 판단할 수 있다.
  </li>
  <li>
    시간 복잡도는 <strong>O(VE)</strong> 이다.
  </li>
</ul>

<br>

<h2>벨만-포드의 핵심이론</h2>
<ul>
  <li>
    1. <strong>에지 리스트</strong>로 그래프를 구현하고 최단 경로 리스트 초기화하기
  </li>
    <ul>
      <li>
        벨만-포드 알고리즘은 <strong>에지</strong>를 중심으로 동작하기에 에지 리스트로 구현한다.
      </li>
      <li>
        최단 경로 리스트는 출발 노드는 <strong>0</strong>, 나머지 노드는 <strong>무한대</strong>로 초기화 한다.
      </li>
    </ul>
  <li>
    2. <strong>모든 에지</strong>를 확인해 정답 리스트 업데이트하기
  </li>
    <ul>
      <li>
        최단 거리 리스트에서 업데이트 반복 횟수는 <strong>'노드 개수 - 1'</strong> 이다.
      </li>
      <li>
        <strong>업데이트 반복 횟수가 K 번째</strong>라면 해당 시점의 정답 리스트 값은 시작점에서 <strong>K개의 에지를 사용했을 때</strong>의 각 노드에 대한 최단거리이다.
      </li>
      <li>
        모든 에지 E = (s, e, w)에서 다음 조건을 만족하면 업데이트를 시작한다.
      </li>
        <ul>
          <li>
            <strong>D[s] != Inf</strong> 이고, <strong>D[e] > D[s] + w</strong> 일 때 <strong>D[e] = D[s] + w</strong>로 리스트 값을 업데이트한다.
          </li>
            <ul>
              <li>
                음수 사이클이 없을 때 최대 에지 개수가 나오려면 <strong>사향 트리 형태</strong>에서 <strong>양 도착 노드를 선택</strong>해야 한다.
              </li>
              <li>
                에지의 출발 노드를 s, 종료 노드를 e, 에지의 가중치를 w로 가정한다.
              </li>
            </ul>
        </ul>
      <li>
        음수 사이클이 없을 때 N - 1번 에지 사용 횟수를 반복하면 출발 노드와 모든 노드 간의 최단 거리를 알려주는 정답 리스트가 완성된다.
      </li>
    </ul>
  <li>
    3. 음수 사이클 유무 확인하기.
  </li>
    <ul>
      <li>
        <strong>음수 사이클</strong> 존재한다면 사이클을 무한하게 돌수록 가중치가 감소하기에 <strong>최단 거리를 구할 수 없다</strong>.
      </li>
      <li>
        음수 사이클을 확인하기 위해서 <strong>모든 에지를 한 번씩 다시 사용</strong>해 업데이트되는 노드가 발생하는지 확인한다.
      </li>
      <li>
        코딩 테스트에서는 벨만-포드를 통해 거리를 구하기보다 <strong>음수 사이클을 판별</strong>하는 문제가 더 빈번하게 출제된다.
      </li>
    </ul>
</ul>

```python
# 타임머신으로 빨리 가기 - 11657
import sys
input = sys.stdin.readline
N, M = map(int, input().split())
edges = []
distance = [sys.maxsize] * (N + 1)

for i in range(M):
    start, end, time = map(int, input().split())
    edges.append((start, end, time))

# 벨만-포드 수행
distance[1] = 0

for _ in range(N - 1):
    for start, end, time in edges:
        if distance[start] != sys.maxsize and distance[end] > distance[start] + time:
            distance[end] = distance[start] + time

# 음수 사이클 확인
mCycle = False

for start, end, time in edges:
    if distance[start] != sys.maxsize and distance[end] > distance[start] + time:
        mCycle = True

if not mCycle:
    for i in range(2, N + 1):
        if distance[i] != sys.maxsize:
            print(distance[i])
        else:
            print(-1)

else:
    print(-1)
```

```python
# 세일즈맨의 고민 - 1219
#   ● 벨만-포드는 최대와 최소 모두 가능한 것을 간과함.
#   ● 사이클 또한 최대면 조건에 맞는 양수 사이클로 변경
#   ● 벨만-포드는 에지만 계산하는 것이 아니라 에지와 노드를 포함해 
#     노드의 상태를 전파하는 알고리즘이다.

import sys
input = sys.stdin.readline
N, sCity, eCity, M = map(int, input().split())
edges = []
# 이번 문제는 양수 사이클(수익 최대화)를 찾는 문제이기에 -sys.maxsize로 초기화.
distance = [-sys.maxsize] * N

for _ in range(M):
    start, end, price = map(int, input().split())
    edges.append((start, end, price))

cityMoney = list(map(int, input().split()))

# 변형된 벨만-포드 수행
#   ● 바로 노드에 수익을 기록하고 시작한다.
distance[sCity] = cityMoney[sCity]

# 양수 사이클이 전파되도록 충분히 큰 수로 반복
#   ● end 노드가 사이클에 포함되거나, 사이클에 나와서 도착이 가능하다면
#     수익은 무한대가 되기에 충분히 큰 반복을 하여 지속 증가하는지 확인.
for i in range(N + 101):
    for start, end, price in edges:
        
        # 출발 노드가 미방문 노드이면 skip
        if distance[start] == -sys.maxsize:
            continue
        
        # 출발 노드가 이미 최대(사이클로 인햬)라면 도착 노드도 최대로 업데이트
        #   ● 하단의 elif 문에서도 양수 사이클 전파를 하지만 더 빨리 확인하기 위해 
        #     추가된 코드이다.
        elif distance[start] == sys.maxsize:
            distance[end] = sys.maxsize
        
        # 더 많은 돈을 벌 수 있는 새로운 경로가 있는 경우 값 업데이트
        elif distance[end] < distance[start] + cityMoney[end] - price:
            distance[end] = distance[start] + cityMoney[end] - price
            # N - 1 번째 이후 좋아지는 노드들은 사이클 영향을 받는 노드이다.
            #   ● 왜? 더 반복하는지? → 충분히 사이클의 전파 영향을 확인하기 위해
            if i >= N - 1:
                distance[end] = sys.maxsize

if distance[eCity] == -sys.maxsize:
    print("gg")
elif distance[eCity] == sys.maxsize:
    print("Gee")
else:
    print(distance[eCity])
```

<br><br>

<h1>6. 플로이드-워셜</h1>
<ul>
  <li>
    플로이드-워셜(floyd-warshall) 알고리즘은 그래프에서 <strong>최단 거리</strong>를 구하는 알고리즘이다.
  </li>
    <ul>
      <li>
        모든 노드 간에 최단 경로 탐색
      </li>
      <li>
        <strong>음수 가중치 에지</strong>가 있어도 수행 가능
      </li>
      <li>
        <strong>동적 계획법</strong>의 원리를 이용해 알고리즘에 접근
      </li>
      <li>
        시간 복잡도는 <strong>O(V^3)</strong>
      </li>
    </ul>
</ul>

<br>

<h2>6-1. 플로이드-워셜의 핵심 이론</h2>
<ul>
  <li>
    플로이드-워셜 알고리즘을 도출하는 핵심적인 원리는 A → B의 최단 경로를 구했다고 가정할 때, 최단 경로 위에 K 노드가 존재한다면 그것을 이루는 <strong>부분 경로</strong> 역시 최단 경로라는 것이다.
  </li>
  <li>
    즉, 전체 경로의 최단 경로는 <strong>부분 경로의 최단 경로의 조합</strong>으로 이루어진다.
  </li>
</ul>

<h3>플로이드-워셜 점화식</h3>
<ul>
  <li>
    D[S][E] = min(D[S][E], D[S][K] + D[K][E])
  </li>
  <li>
    1. 리스트를 선언하고 초기화히기
  </li>
    <ul>
      <li>
        이차원 리스트를 구현한다.
      </li>
      <li>
        D[S][E]는 S에서 E까지의 최단 거리를 의미한다.
      </li>
      <li>
        S와 E가 같은 칸(자기자신)은 0, 다른 칸은 ∞으로 초기화 한다.
      </li>
    </ul>
  <li>
    2. 최단 거리 리스트에 그래프 데이터 저장하기
  </li>
    <ul>
      <li>
        출발 노드를 S, 도착 노드를 E, 에지의 가중치를 W라 했을 때 <strong>D[S][E] = W</strong>로 에지 정보를 리스트에 입력한다.
      </li>
      <li>
        즉, 그래프를 인접 행렬로 표현한다.
      </li>
    </ul>
  <li>
    3. 점화식으로 리스트 업데이트 하기
  </li>
    <ul>
      <li>
        기존에 구했던 점화식을 <strong>3중 for loop</strong>형태로 반복하면서 리스트의 값을 업데이트한다.
      </li>
        <ul>
          <li>
            <strong>첫 번째 for loop</strong>: 경유지 K에 관해 (1 - N)
          </li>
          <li>
            <strong>두 번째 for loop</strong>: 출발 노드 S에 관해 (1 - N)
          </li>
          <li>
            <strong>세 번째 for loop</strong>: 도착 노드 E에 관해 (1 - N)
          </li>
          <li>
            마지막은 점화식 <strong>D[S][E] = Math.min(D[S][E], D[S][K] + D[K][E])</strong>
          </li>
        </ul>
    </ul>
  <li>
    플루이드-워셜 알고리즘은 모든 노드 간의 최단 거리를 확인하기 때문에 시간 복잡도가 O(V^3)로 크다. 따라서 문제에서 <strong>노드 개수의 범위가 다른 그래프에 비해 작다</strong>.
  </li>
</ul>

```python
# 가장 빠른 버스 노선 구하기 - 11404
import sys
input = sys.stdin.readline
N = int(input())
M = int(input())
distance = [[sys.maxsize for j in range(N + 1)] for i in range(N + 1)]

for i in range(1, N + 1):
    distance[i][i] = 0

# 첫 그래프 초기화
for i in range(M):
    s, e, v = map(int, input().split())
    # 경로 중 더 작은 경로가 있다면 해당 경로로 업데이트
    if distance[s][e] > v:
        distance[s][e] = v

# 플로이드-워셜 수행
for k in range(1, N + 1):
    for i in range(1, N + 1):
        for j in range(1, N + 1):
            if distance[i][j] > distance[i][k] + distance[k][j]:
                distance[i][j] = distance[i][k] + distance[k][j]

for i in range(1, N + 1):
    for j in range(1, N + 1):
        if distance[i][j] == sys.maxsize:
            print(0, end = ' ')
        else:
            print(distance[i][j], end = ' ')
    print()
```

```python
# 경로 찾기 - 11403
N = int(input())
distance = [[0 for j in range(N)] for i in range(N)]

# 인접 행렬 데이터 저장
# 최단 거리 문제가 아니라 도달 가능성을 확인하기 때문에 
# sys.maxsize로 초기화하지 않는다.
for i in range(N):
    distance[i] = list(map(int, input().split()))

# 변형된 플로이드-워셜 수행
for k in range(N):
    for i in range(N):
        for j in range(N):
            if distance[i][k] == 1 and distance[k][j] == 1:
                distance[i][j] = 1

for i in range(N):
    for j in range(N):
        print(distance[i][j], end=' ')
    print()
```

```python
# 케빈 베이컨의 6단계 법칙 - 1389
import sys
N, M = map(int, input().split())
distance = [[sys.maxsize for j in range(N + 1)] for i in range(N + 1)]

for i in range(1, N + 1):
    distance[i][i] = 0

# 양방향 그래프 구현
for i in range(M):
    s, e = map(int, input().split())
    distance[s][e] = 1
    distance[e][s] = 1

# 풀로이드-워셜 알고리즘 수행
for k in range(1, N + 1):
    for i in range(1, N + 1):
        for j in range(1, N + 1):
            if distance[i][j] > distance[i][k] + distance[k][j]:
                distance[i][j] = distance[i][k] + distance[k][j]

Min = sys.maxsize
Answer = -1

for i in range(1, N + 1):
    temp = 0
    for j in range(1, N + 1):
        temp += distance[i][j]
    # 가장 작은 케빈 베이컨의 수를 지닌 i 찾기.
    if Min > temp:
        Min = temp
        Answer = i

print(Answer)
```

<br><br>

<h1>7. 최소 신장 트리</h1>
<ul>
  <li>
    <strong>최소 신장 트리(minimum spanning tree)</strong>란 그래프에서 <strong>모든 노드</strong>를 연결할 때 <strong>사용된 에지들의 가중치의 합을 최소</strong>로 하는 트리이다.
  </li>
  <li>
    <strong>최소 신장 트리의 특징</strong>
  </li>
    <ul>
      <li>
        사이클이 포함되면 가중치의 합이 최소가 될 수 없기 때문에 <strong>사이클을 포함하지 않는다</strong>.
      </li>
      <li>
        <strong>N개의 노드</strong>가 있으면 최소 신장 트리를 구성하는 에지의 개수는 항상 <strong>N - 1개</strong> 이다.
      </li>
    </ul>
</ul>

<br>

<h2>7-1. 최소 신장 트리의 핵심 이론</h2>
<ul>
  <li>
    1. 에지 리스트로 그래프를 구현하고 유니온 파인드 리스트 초기화하기.
  </li>
    <li>
      최소 신장 트리는 데이터를 에지 중심으로 저장하기 때문에 인접 리스트가 아닌 <strong>에지 리스트</strong> 형태로 저장한다.
    </li>
    <li>
      에지 리스트는 일반적으로 <strong>두 개의 노드 변수</strong>와 <strong>하나의 가중치 변수</strong>로 구성된다.
    </li>
    <li>
      <strong>사이클</strong> 처리를 위한 <strong>유니온 파인드</strong> 리스트도 함께 초기화 한다.
    </li>
  <li>
    2. 그래프 데이터를 가중치 기준으로 정렬한다.
  </li>
    <ul>
      <li>
        에지 리스트에 담긴 그래프를 <strong>가중치 기준</strong>으로 <strong>오름차순</strong> 정렬한다.
      </li>
    </ul>
  <li>
    3. 가중치가 낮은 에지부터 연결 시도하기
  </li>
    <ul>
      <li>
        가중치가 낮은 에지부터 순차적으로 연결한다.
      </li>
      <li>
        단, 바로 연결을 하는 것이 아닌 <strong>find 연산</strong>을 통해 사이클이 형성되지 않을 때에만 <strong>union 연산</strong>을 통해 두 노드를 연결한다.
      </li>
    </ul>
  <li>
    4. 과정 3을 반복한다.
  </li>
    <ul>
      <li>
        전체 <strong>노드의 수가 N</strong> 이라면 연결한 <strong>에지의 개수가 N-1</strong> 이 될 때까지 과정 3을 반복한다.
      </li>
    </ul>
  <li>
    5. 총 에지 비용 출력하기
  </li>
    <ul>
      <li>
        <strong>에지의 개수가 N-1</strong>이 되면 알고리즘을 종료하고, 완성된 최소 신장 트리의 <strong>총 에지 비용</strong>을 출력한다.
      </li>
    </ul>
</ul>

```python
# 최소 신장 트리 구하기 - 1197
"""
아래의 이유로 도서와는 다르게 구현하였다.
"""

# MST를 프림으로 구현한다.
#   ● 크루스컬로 구현하면 Python에서는 recursion 문제가 발생할 수 있다.
#   ● 다익스트라는 특정 노드에서 다른 노드까지의 최단 경로(누적합)을 탐색하기에
#     프림처럼 pop 시점에 visited를 확인하지 않는다.
#   ● 프림은 단일 간선 정보를 활용하기에 중복 노드가 나온다면 이미 해당 노드의
#     최단 경로를 확인하였기에 visited를 체크한다.
from collections import defaultdict
import heapq

N, E = map(int, sys.stdin.readline().split())
graph = defaultdict(list)
for _ in range(E):
    s, e, w = map(int, sys.stdin.readline().split())
    graph[s].append((w, e))
    graph[e].append((w, s))
visited = [False] * (N + 1)

q = []
heapq.heappush(q, (0, 1))

# MST의 전체 비용
result = 0
# MST에 포함된 노드 수
cnt = 0

# 전체를 탐색
while q:
    nw, nn = heapq.heappop(q)

    # 방문한 노드라면 skip
    #   ● 이미 해당 노드의 최소 간선을 방문했기에 확인하지 않는다.
    if visited[nn]:
        continue
    visited[nn] = True

    # 방문하지 않았다면 최소 가중치 누적합
    result += nw

    # 다음 노드를 순회하면서 업데이트
    for cw, cn in graph[nn]:
        if visited[cn]:
            continue
        heapq.heappush(q, (cw, cn))
    
print(result)
```

```python
# 다리 만들기 - 17472
#   ● 도서의 MST 코드를 Prim으로 수정.
#   ● BFS의 불필요한 코드 제거.
import copy
import sys
from collections import deque
from queue import PriorityQueue
input = sys.stdin.readline

dr = [0, 1, 0, -1]
dc = [1, 0, -1, 0]

N, M = map(int, input().split())
myMap = [[0 for j in range(M)] for i in range(N)]
visited = [[False for j in range(M)] for i in range(N)]

for i in range(N):
    myMap[i] = list(map(int, input().split()))

# 섬 번호
sNum = 1
# 모든 섬 정보 이중 리스트
sumlist = list([])
# 1개의 섬 정보 리스트
mlist = []

# 섬에 한 칸(노드)을 더해주는 함수
def addNode(i, j, queue):
    myMap[i][j] = sNum
    visited[i][j] = True
    temp = [i, j]
    mlist.append(temp)
    queue.append(temp)

# 탐색을 통해 섬의 정보를 저장
def BFS(i, j):
    queue = deque()
    mlist.clear()
    start = [i, j]
    queue.append(start)
    mlist.append(start)
    visited[i][j] = True
    myMap[i][j] = sNum

    while queue:
        r, c = queue.popleft()
        for d in range(4):
            nr = r + dr[d]
            nc = c + dc[d]
            if 0 <= nr < N and 0 <= nc < M:
                if not visited[nr][nc] and myMap[nr][nc] != 0:
                    # 여기서 mlist 업데이트
                    addNode(nr, nc, queue)
    
    return mlist

# 섬 구분 작업 수행
for i in range(N):
    for j in range(M):
        if myMap[i][j] != 0 and not visited[i][j]:
            # 깊은 복사로 해서 주소를 공유하지 않음.
            # BFS를 통해 하나의 섬의 정보를 가져옴.
            tempList = copy.deepcopy(BFS(i, j))
            sNum += 1
            # 새로운 섬 넘버링
            sumlist.append(tempList)

# 인접 리스트: 각 섬에서 다른 섬으로 가는 최소 거리 저장
edges = [[] for _ in range(sNum)]

# 섬의 각 지점에서 만들 수 있는 모든 에지를 저장
for now in sumlist:
    # 한 개의 섬 정보
    for temp in now:
        r = temp[0]
        c = temp[1]
        now_S = myMap[r][c]
        # 네 방향 탐색 → 인접 리스트에 에지 정보 저장
        for d in range(4):
            tempR = dr[d]
            tempC = dc[d]
            blength = 0
            while r + tempR >= 0 and r + tempR < N and c + tempC >= 0 and c + tempC < M:
                # 같은 섬이면 에지를 만들 수 없음.
                if myMap[r + tempR][c + tempC] == now_S:
                    break
                # 같은 섬도 아니고 바다도 아니면
                elif myMap[r + tempR][c + tempC] != 0:
                    # 다른 섬 → 길이가 1 초과일 때 에지로 추가.
                    if blength > 1:
                        edges[now_S].append((blength, myMap[r + tempR][c + tempC]))
                    break
                # 바다인 경우 다리의 길이 연장
                else: 
                    blength += 1
                if tempR < 0:
                    tempR -= 1
                elif tempR > 0:
                    tempR += 1
                elif tempC < 0:
                    tempC -= 1
                elif tempC > 0:
                    tempC += 1

# Prim 알고리즘으로 최소 신장 트리 구현
visitedIsland = [False] * sNum
pq = PriorityQueue()

# 1번 섬부터 시작 (섬 번호는 1부터 시작)
visitedIsland[1] = True
connected = 1  # 연결된 섬의 개수
result = 0

# 1번 섬과 연결된 모든 간선을 우선순위 큐에 추가
for edge in edges[1]:
    pq.put(edge)  # (거리, 목적지 섬)

# Prim 알고리즘 수행
while pq.qsize() > 0 and connected < sNum - 1:
    dist, next_island = pq.get()
    
    # 이미 방문한 섬이면 건너뛰기
    if visitedIsland[next_island]:
        continue
    
    # 새로운 섬을 MST에 추가
    visitedIsland[next_island] = True
    result += dist
    connected += 1
    
    # 새로 추가된 섬과 연결된 모든 간선을 우선순위 큐에 추가
    for edge in edges[next_island]:
        if not visitedIsland[edge[1]]:
            pq.put(edge)

# sNum이 실제 섬의 수보다 1 크기 때문에 섬의 번호 표시를 위해 -1로 연산
if connected == sNum - 1:
    print(result)
else:
    print(-1)
```

```python
# 불우이웃돕기 - 1414
#   ● MST를 Prim으로 하도록 수정.
from collections import defaultdict
import heapq

# 입력 받기
N = int(sys.stdin.readline())
grid_graph = [list(sys.stdin.readline().strip()) for _ in range(N)]

# grid_graph의 문자를 숫자로 변환 (ord 사용)
for i in range(N):
    for j in range(N):
        cell = grid_graph[i][j]
        if cell == '0':
            grid_graph[i][j] = 0
        # a-z에 해당하는 경우의 변환
        elif 'a' <= cell <= 'z':
            grid_graph[i][j] = ord(cell) - ord('a') + 1
        # A-Z에 해당하는 경우의 변환
        else:
            grid_graph[i][j] = ord(cell) - ord('A') + 27

# N == 1일 때 예외처리
if N == 1:
    print(grid_graph[0][0])
else:
    
    # 랜선의 총 길이 구하기
    total_sum - 0
    for row in grid_graph:
        total_sum += sum(row)

    # grid_graph를 통해서 graph 생성.
    graph = defaultdict(list)
    for i in range(N):
        for j in range(N):
            if grid_graph[i][j] != 0:
                graph[i].append((j, grid_graph[i][j]))
                graph[j].append((i, grid_graph[i][j]))
    
    # Prim 알고리즘 준비
    q = []
    heapq.heappush(q, (0, 1))
    visited = [False] * N
    result = 0

    while q:
        now_weight, now_node = heapq.heappop(q)
        if visited[now_node]:
            continue
        visited[now_node] = True

        result += now_weight

        for next_node, next_weight in graph[now_node]:
            if visited[next_node]:
                continue
            heapq.heappush(q, (next_weight, next_node))
    
    # 전체를 방문했는지 체크
    check = False
    for i in visited:
        if not i:
            check = True
    
    # 출력부 구현
    if check:
        print(-1)
    elif N == 1:
        print(grid_graph[i][j])
    else:
        print(total_sum - result)
```