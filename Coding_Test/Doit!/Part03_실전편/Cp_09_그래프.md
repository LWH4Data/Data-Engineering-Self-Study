<h1>1. 그래프의 표현</h1>

```python
# 2차원 리스트 생성
# a) 추천 방법==========================================
A = [[0 for col in range(4)] for row in range(3)]

# b) 얕은 복사==========================================
#   ● 얕은 복사로 인해 각 행이 독립적이지 않고 같은 객체를 참조하는 문제가 있다.
A = [[0] * 4] * 3 
```

<br>

<h2>1-1. 에지 리스트</h2>
<ul>
  <li>
    <strong>에지 리스트(edge list)</strong>는 <strong>에지</strong>를 중심으로 그래프를 표현한다.
  </li>
  <li>
    에지 리스트는 리스트에 <strong>출발 노드</strong>와 <strong>도착 노드</strong>를 저장하여 에지를 표현한다.
  </li>
    <ul>
      <li>
        <strong>가중치</strong>가 있는 경우에는 출발 노드, 도착 노드 그리고 가중치를 저장하여 가중치가 있는 에지를 표현한다.
      </li>
    </ul>
</ul>

<h3>1-1-1. 에지 리스트로 가중치 없는 그래프 구현하기</h3>
<ul>
  <li>
    가중치가 없는 그래프는 <strong>출발 노드</strong>와 <strong>도착 노드</strong>만 표현하면 되기에 <strong>리스트의 열은 두 개</strong>로 충분하다.
  </li>
  <li>
    1에서 2로 뻗는 에지는 <strong>[1, 2]</strong>로, 4에서 5로 뻗는 에지는 [4, 5]로 표현한다.
  </li>
    <ul>
      <li>
        방향이 있는 에지는 그래프의 순서에 맞게 노드를 저장한다.
      </li>
    </ul>
  <li>
    노드를 리스트에 저장하여 에지를 표현하기 때문에 에지 리스트라 한다.
  </li>
</ul>

<br>

<h2>1-2. 에지 리스트로 가중치 있는 그래프 표현하기</h2>
<ul>
  <li>
    가중치가 있는 그래프는 <strong>열을 세 개</strong>로 늘려 <strong>세 번째 열</strong>에 가중치를 저장하면 된다.
  </li>
  <li>
    1에서 2로 향하는 가중치가 8인 에지는 <strong>[1, 2, 8]</strong>로 표현한다.
  </li>
  <li>
    가중치가 있는 에지 리스트는 <strong>특정 노드</strong>와 관련된 에지를 탐색하지 쉽지 않다.
  </li>
    <ul>
      <li>
        따라서 가중치 에지 리스트는 <strong>노드 사이의 최단 거리</strong>를 구하는 벨만-포드나 최소 신장 트리를 찾는 클루스칼 알고리즘에 사용한다.
      </li>
      <li>
        반면 노드 중심 알고리즘에는 잘 사용하지 않는다.
      </li>
    </ul>
</ul>

<br><br>

<h2>1-3. 인접 행렬</h2>
<ul>
  <li>
    <strong>인접 행렬(adjacency matrix)</strong>은 <strong>2차원 리스트</strong>를 자료구조로 이용하여 그래프를 표현한다.
  </li>
  <li>
    인접 행렬은 에지 리스트와 다르게 <strong>노드 중심</strong>으로 그래프를 표현한다.
  </li>
</ul>

<h3>1-3-1. 인접 행렬로 가중치 없는 그래프 표현하기</h3>
<ul>
  <li>
    노드 1에서 노드 2로 향하는 에지는 인접 행렬에서 <strong>1행 2열</strong>에 1을 저장하는 방식으로 표현한다.
  </li>
    <ul>
      <li>
        value로 1을 저장하는 이유는 가중치가 없기 때문이다.
      </li>
    </ul>
</ul>

<h3>1-3-2. 인접 행렬로 가중치 있는 그래프 표현하기</h3>
<ul>
  <li>
    가중치가 있는 그래프는 2차원 배열의 value에 <strong>1대신 가중치를 저장</strong>한다.
  </li>
  <li>
    두 노드를 연결하는 에지의 여부와 가중치를 리스트에 직접 접근하면 바로 확인할 수 있다는 장점이 있다.
  </li>
    <ul>
      <li>
        그러나 <strong>노드와 관련된 에지</strong>를 탐색하려면 N번 접근해야 하기에 <strong>시간 복잡도</strong>가 인접 리스트에 비해 느리다.
      </li>
      <li>
        또 노드 개수에 비해 에지가 적을 때에는 <strong>공간 효율성</strong>이 떨어진다. (희소 행렬).
      </li>
    </ul>
</ul>

<br>

<h2>1-4. 인접 리스트</h2>
<ul>
  <li>
    <strong>인접 리스트(adjaccency list)</strong>는 <strong>파이썬의 리스트</strong>를 이용해 그래프를 표현한다.
  </li>
  <li>
    <strong>노드 개수</strong>만큼 리스트를 선언한다.
  </li>
  <li>
    리스트의 <strong>input data 형태</strong>는 문제의 <strong>조건에 맞게</strong> 설정한다.
  </li>
</ul>

<h3>1-4-1. 인접 리스트로 가중치 없는 그래프 표현하기</h3>
<ul>
  <li>
    가중치가 없는 경우 인접 리스트 N번 노드와 연결된 노드들은 리스트의 <strong>index N</strong>에 연결된 노드 개수만큼 <strong>리스트에 append</strong>하는 방식으로 표현한다.
  </li>
    <ul>
      <li>
        1번 노드에 2, 3번 노드가 연결돼 있다면 A[1]에 [2, 3]을 연결한다.
      </li>
    </ul>
</ul>

<h3>1-4-2. 인접 리스트로 가중치 있는 그래프 표현하기</h3>
<ul>
  <li>
    가중치가 있는 경우 input data를 <strong>2개(도착 노드, 가중치)</strong>로 사용한다. 또한 아래의 장점들로 실제 코딩 테스트에서 많이 활용된다.
  </li>
  <li>
    노드와 연결된 에지를 탐색하는 <strong>시간</strong>이 매우 뛰어나다.
  </li>
  <li>
    노드 개수가 커져도 공간 효율성이 좋아 <strong>메모리</strong> 초과 에러도 발생하지 않는다.
  </li>
</ul>

```python
# 특정 거리의 도시 찾기 - 18352
import sys
from collections import deque
input = sys.stdin.readline

N, M, K, X = map(int, input().split())
A = [[] for _ in range(N + 1)]
answer = []
# visited로 거리를 관리할 것이기에 -1을 기본값으로 한다.
visited = [-1] * (N + 1)

def BFS(v):
    queue = deque()
    queue.append(v)
    visited[v] += 1
    while queue:
        now_Node = queue.popleft()
        for i in A[now_Node]:
            if visited[i] == -1:
                visited[i] = visited[now_Node] + 1
                queue.append(i)

for _ in range(M):
    S, E = map(int, input().split())
    A[S].append(E)

BFS(X)

for i in range(N + 1):
    if visited[i] == K:
        answer.append(i)

if not answer:
    print(-1)
else:
    answer.sort()
    for i in answer:
        print(i)
```

```python
# 효율적으로 해킹하기 - 1325
import syt
from collections import deque
input = sys.stdin.readline
N, M = map(int, input().split())
A = [[] for _ in range(N + 1)]
answer = [0] * (N + 1)

def BFS(v):
    visited = [False] * (N + 1)
    queue = deque()
    queue.append(v)
    visited[v] = True
    while queue:
        now_Node = queue.popleft()
        for i in A[now_Node]:
            if not visited[i]:
                visited[i] = True
                # 신규 노드 인덱스의 정답 리스트값을 증가.
                answer[i] += 1
                queue.append(i)

for i in range(M):
    S, E = map(int, input().split())
    A[S].append(E)

# 모든 노드에서 BFS 시행
for i in range(1, N + 1):
    BFS(i)

maxVal = max(answer)
for i in range(1, N + 1):
    if maxVal == answer[i]:
        print(i, end=' ')
```

```python
# 이분 그래프 판별하기 - 1707

```