<h1>1. 그래프의 표현</h1>

```python
# 2차원 리스트 생성
# a) 추천 방법==========================================
A = [[0 for col in range(4)] for row in range(3)]

# b) 얕은 복사==========================================
#   ● 얕은 복사로 인해 각 행이 독립적이지 않고 같은 객체를 참조하는 문제가 있다.
A = [[0] * 4] * 3 
```

<br>

<h2>1-1. 에지 리스트</h2>
<ul>
  <li>
    <strong>에지 리스트(edge list)</strong>는 <strong>에지</strong>를 중심으로 그래프를 표현한다.
  </li>
  <li>
    에지 리스트는 리스트에 <strong>출발 노드</strong>와 <strong>도착 노드</strong>를 저장하여 에지를 표현한다.
  </li>
    <ul>
      <li>
        <strong>가중치</strong>가 있는 경우에는 출발 노드, 도착 노드 그리고 가중치를 저장하여 가중치가 있는 에지를 표현한다.
      </li>
    </ul>
</ul>

<h3>1-1-1. 에지 리스트로 가중치 없는 그래프 구현하기</h3>
<ul>
  <li>
    가중치가 없는 그래프는 <strong>출발 노드</strong>와 <strong>도착 노드</strong>만 표현하면 되기에 <strong>리스트의 열은 두 개</strong>로 충분하다.
  </li>
  <li>
    1에서 2로 뻗는 에지는 <strong>[1, 2]</strong>로, 4에서 5로 뻗는 에지는 [4, 5]로 표현한다.
  </li>
    <ul>
      <li>
        방향이 있는 에지는 그래프의 순서에 맞게 노드를 저장한다.
      </li>
    </ul>
  <li>
    노드를 리스트에 저장하여 에지를 표현하기 때문에 에지 리스트라 한다.
  </li>
</ul>

<br>

<h2>1-2. 에지 리스트로 가중치 있는 그래프 표현하기</h2>
<ul>
  <li>
    가중치가 있는 그래프는 <strong>열을 세 개</strong>로 늘려 <strong>세 번째 열</strong>에 가중치를 저장하면 된다.
  </li>
  <li>
    1에서 2로 향하는 가중치가 8인 에지는 <strong>[1, 2, 8]</strong>로 표현한다.
  </li>
  <li>
    가중치가 있는 에지 리스트는 <strong>특정 노드</strong>와 관련된 에지를 탐색하지 쉽지 않다.
  </li>
    <ul>
      <li>
        따라서 가중치 에지 리스트는 <strong>노드 사이의 최단 거리</strong>를 구하는 벨만-포드나 최소 신장 트리를 찾는 클루스칼 알고리즘에 사용한다.
      </li>
      <li>
        반면 노드 중심 알고리즘에는 잘 사용하지 않는다.
      </li>
    </ul>
</ul>

<br><br>

<h2>1-3. 인접 행렬</h2>
<ul>
  <li>
    <strong>인접 행렬(adjacency matrix)</strong>은 <strong>2차원 리스트</strong>를 자료구조로 이용하여 그래프를 표현한다.
  </li>
  <li>
    인접 행렬은 에지 리스트와 다르게 <strong>노드 중심</strong>으로 그래프를 표현한다.
  </li>
</ul>

<h3>1-3-1. 인접 행렬로 가중치 없는 그래프 표현하기</h3>
<ul>
  <li>
    노드 1에서 노드 2로 향하는 에지는 인접 행렬에서 <strong>1행 2열</strong>에 1을 저장하는 방식으로 표현한다.
  </li>
    <ul>
      <li>
        value로 1을 저장하는 이유는 가중치가 없기 때문이다.
      </li>
    </ul>
</ul>

<h3>1-3-2. 인접 행렬로 가중치 있는 그래프 표현하기</h3>
<ul>
  <li>
    가중치가 있는 그래프는 2차원 배열의 value에 <strong>1대신 가중치를 저장</strong>한다.
  </li>
  <li>
    두 노드를 연결하는 에지의 여부와 가중치를 리스트에 직접 접근하면 바로 확인할 수 있다는 장점이 있다.
  </li>
    <ul>
      <li>
        그러나 <strong>노드와 관련된 에지</strong>를 탐색하려면 N번 접근해야 하기에 <strong>시간 복잡도</strong>가 인접 리스트에 비해 느리다.
      </li>
      <li>
        또 노드 개수에 비해 에지가 적을 때에는 <strong>공간 효율성</strong>이 떨어진다. (희소 행렬).
      </li>
    </ul>
</ul>

<br>

<h2>1-4. 인접 리스트</h2>
<ul>
  <li>
    <strong>인접 리스트(adjaccency list)</strong>는 <strong>파이썬의 리스트</strong>를 이용해 그래프를 표현한다.
  </li>
  <li>
    <strong>노드 개수</strong>만큼 리스트를 선언한다.
  </li>
  <li>
    리스트의 <strong>input data 형태</strong>는 문제의 <strong>조건에 맞게</strong> 설정한다.
  </li>
</ul>

<h3>1-4-1. 인접 리스트로 가중치 없는 그래프 표현하기</h3>
<ul>
  <li>
    가중치가 없는 경우 인접 리스트 N번 노드와 연결된 노드들은 리스트의 <strong>index N</strong>에 연결된 노드 개수만큼 <strong>리스트에 append</strong>하는 방식으로 표현한다.
  </li>
    <ul>
      <li>
        1번 노드에 2, 3번 노드가 연결돼 있다면 A[1]에 [2, 3]을 연결한다.
      </li>
    </ul>
</ul>

<h3>1-4-2. 인접 리스트로 가중치 있는 그래프 표현하기</h3>
<ul>
  <li>
    가중치가 있는 경우 input data를 <strong>2개(도착 노드, 가중치)</strong>로 사용한다. 또한 아래의 장점들로 실제 코딩 테스트에서 많이 활용된다.
  </li>
  <li>
    노드와 연결된 에지를 탐색하는 <strong>시간</strong>이 매우 뛰어나다.
  </li>
  <li>
    노드 개수가 커져도 공간 효율성이 좋아 <strong>메모리</strong> 초과 에러도 발생하지 않는다.
  </li>
</ul>

```python
# 특정 거리의 도시 찾기 - 18352
import sys
from collections import deque
input = sys.stdin.readline

N, M, K, X = map(int, input().split())
A = [[] for _ in range(N + 1)]
answer = []
# visited로 거리를 관리할 것이기에 -1을 기본값으로 한다.
visited = [-1] * (N + 1)

def BFS(v):
    queue = deque()
    queue.append(v)
    visited[v] += 1
    while queue:
        now_Node = queue.popleft()
        for i in A[now_Node]:
            if visited[i] == -1:
                visited[i] = visited[now_Node] + 1
                queue.append(i)

for _ in range(M):
    S, E = map(int, input().split())
    A[S].append(E)

BFS(X)

for i in range(N + 1):
    if visited[i] == K:
        answer.append(i)

if not answer:
    print(-1)
else:
    answer.sort()
    for i in answer:
        print(i)
```

```python
# 효율적으로 해킹하기 - 1325
import syt
from collections import deque
input = sys.stdin.readline
N, M = map(int, input().split())
A = [[] for _ in range(N + 1)]
answer = [0] * (N + 1)

def BFS(v):
    visited = [False] * (N + 1)
    queue = deque()
    queue.append(v)
    visited[v] = True
    while queue:
        now_Node = queue.popleft()
        for i in A[now_Node]:
            if not visited[i]:
                visited[i] = True
                # 신규 노드 인덱스의 정답 리스트값을 증가.
                answer[i] += 1
                queue.append(i)

for i in range(M):
    S, E = map(int, input().split())
    A[S].append(E)

# 모든 노드에서 BFS 시행
for i in range(1, N + 1):
    BFS(i)

maxVal = max(answer)
for i in range(1, N + 1):
    if maxVal == answer[i]:
        print(i, end=' ')
```

```python
# 이분 그래프 판별하기 - 1707
#   ● 홀수 길이 사이클이 없는 모든 그래프가 이분 그래프이다.
import sys
sys.setrecursionlimit(10**6)
input = sys.stdin.readline
N = int(input())
IsEven = True

def DFS(node):
    global IsEven
    visited[node] = True
    for i in A[node]:
        if not visited[i]:
            # 인접 노드는 같은 집합이 될 수 없기에 다른 집합으로 처리
            check[i] = (check[node] + 1) % 2
            DFS(i)
        # 이미 방문한 노드가 현재 내 노드와 같은 집합이면 이분 그래프가 아님.
        elif check[node] == check[i]:
            IsEven = False

for _ in range(N):
    V, E = map(int, input().split())
    A = [[] for _ in range(V + 1)]
    visited = [False] * (V + 1)
    check = [0] * (V + 1)
    IsEven = True

    # 인접 리스트로 그래프 저장
    for i in range(E):
        Start, End = map(int, input().split())
        A[Start].append(End)
        A[End].append(Start)
    
    # 주어진 그래프가 항상 1개가 아니므로 모든 노드에서 수행
    for i in range(1, V + 1):
        if IsEven:
            DFS(i)
        else:
            break
    
    if IsEven:
        print("YES")
    else:
        print("NO")
```

```python
# 물의 양 구하기 - 2251
#   ● 두 리스트를 활용하여 A, B, C에서 발생할 수 있는 6개의 이동 케이스를 정의한다.
#   ● 각 간선을 탐색하며 동적으로 변하는 그래프를 BFS로 탐색한다.
from collections import deque

# 간선 구현 (0: A, 1: B, 2: C)
# 보내는 노드
Sender = [0, 0, 1, 1, 2, 2] # 0 → 1 = A → B
# 받는 노드
Receiver = [1, 2, 0, 2, 0, 1]
# A, B, C의 입력을 받는다.
now = list(map(int, input().split()))
# 방문 그래프(A와 B 모두 1 ≤ A, B ≤ 200의 범위이기에 201 × 201의 크기를 이용).
visited = [[False for j in range(201)] for _ in range(201)]
# C 또한 1 ≤ A, B ≤ 200 범위이기에 A와 B에 따른 결과를 201 길이의 배열에 저장한다.
answer = [False] * 201

# 탐색 BFS
def BFS():
    queue = deque()
    # 첫 번째 간선을 입력한다.
    queue.append((0, 0))
    visited[0][0] = True
    # 현재 C의 값도 체크한다.
    answer[now[2]] = True

    while queue:
        now_Node = queue.popleft()
        # 탐색할 때의 물의 양으로 그래프를 동적으로 업데이트 한다.
        A = now_Node[0]
        B = now_Node[1]
        # C의 현재 물의 양은 A와 B로 결정한다.
        C = now[2] - A - B
        
        # 모든 경로를 탐색한다.
        # A → B, A → C, B → A, ..., C → B
        for k in range(6):
            # 물을 옮긴 후의 상태를 업데이트 한다. 
            next = [A, B, C]
            # 물을 이동 후 물의 양을 업데이트
            next[Receiver[k]] += next[Sender[k]]
            # 물을 옮긴쪽은 일단 다 비웠다고 가정한다.
            next[Sender[k]] = 0

            # 만약 옮기는 쪽의 용기가 더 크다면 
            if next[Sender[K]] > now[Receiver[k]]:
                # 받는 쪽에서 초과하는 양의 물을 보내는 쪽에 넣고
                next[Sender[k]] = next[Receiver[k]] - now[Receiver[k]]
                # 받는 쪽의 물은 용기의 크기에 맞추어 업데이트 한다.
                next[Receiver[k]] = now[Receiver[k]]
            
            # 방문한 적이 없는 간선이라면
            if not visited[next[0]][next[1]]:
                # 방문체크 후 탐색할 간선에 넣는다.
                visited[next[0]][next[1]]
                queue.append((next[0], next[1]))

                # A가 0인 경우 해당하는 C의 index에 True를 초기화한다.
                if next[0] == 0:
                    answer[next[2]] = True

BFS()

# answer 배열을 순회하면서 True인 index를 출력한다.
for i in range(len(answer)):
    if answer[i]:
        print(i, end=' ')
```

<br><br>

<h1>2. 유니온 파인드</h1>
<ul>
  <li>
    <strong>유니온 파인드(union-find)</strong>는 다음 두 가지 연산으로 구성되어 있다.
  </li>
    <ul>
      <li>
        <strong>union 연산</strong>: 여러 노드 중 특정 두 개의 노드를 연결해 하나의 집합으로 <strong>묶는다</strong>.
      </li>
      <li>
        <strong>find 연산</strong>: 두 노드가 <strong>같은 집합</strong>에 속해 있는지 확인한다.
      </li>
    </ul>
</ul>

<br>

<h2>2-1. 유니온 파인드의 핵심 이론</h2>
<ul>
  <li>
    union과 find 두 연산을 완벽히 이해하는 것이 핵심이다.
  </li>
    <ul>
      <li>
        <strong>union 연산</strong>
      </li>
        <ul>
          <li>
            각 노드가 속한 집합을 1개로 합친다.
          </li>
          <li>
            노드 a, b가 a ∈ A, b ∈ B일때 union(a, b)는 <strong>A ∪ B</strong>를 의미한다.
          </li>
        </ul>
      <li>
        <strong>find 연산</strong>
      </li>
        <ul>
          <li>
            특정 노드 a에 관해 a가 속한 집합의 대표 노드를 반환한다.
          </li>
          <li>
            노드 a가 a ∈ A 일 때 find(a)는 A 집합의 대표 노드를 반환한다.
          </li>
        </ul>
    </ul>
</ul>

<h3>2-1-1. 유니온 파인드의 원리 이해하기</h3>
<ul>
  <li>
    유니온 파인드를 표현하는 일반적인 방법은 <strong>1차원 리스트</strong>를 이용하는 것이다.
  </li>
  <li>
    처음에는 각 노드가 연결되어 있지 않기에 <strong>각 노드</strong>가 대표 노드가 된다.
  </li>
    <ul>
      <li>
        각 노드가 모두 대표 노드이기에 리스트를 <strong>자신의 index값</strong>으로 초기화한다.
      </li>
    </ul>
  <li>
    두 개의 노드를 선택해 각각의 대표 노드를 찾아 연결하는 union 연산을 수행한다.
  </li>
    <ul>
      <li>
        1이 대표 노드, 4가 자식 노드라면 리스트의 index = 4의 값을 1로 변경한다. 
      </li>
      <li>
        대표 노드가 아닌 노드끼리 연결할 때에는 각각의 <strong>대표 노드를 찾아 연결</strong>한다.
      </li>
    </ul>
  <li>
    find 연산은 자신이 속한 집합의 <strong>대표 노드를 찾는</strong> 연산이다.
  </li>
    <ul>
      <li>
        단순히 찾는 역할만 하는 것이 아니라 그래프를 <strong>정돈</strong>하고 <strong>시간 복잡도</strong>를 줄인다.
      </li>
        <ul>
          <li>
            연산을 할 때 거치는 노드들이 대표 노드와 <strong>바로 연결</strong>되기에 이후 노드와 관련된 find 연산 속도는 <strong>O(1)</strong>이 되어 <strong>경로 압축</strong>의 효과가 있다.
          </li>
            <ul>
              <li>
                경로 압축이란 실제 그래프에서 여러 노드를 거쳐야 하는 경로에서 <strong>그래프를 변형</strong>해 더 짧은 경로로 갈 수 있도록 함으로써 시간 복잡도를 효과적으로 줄이는 방법을 의미한다.
              </li>
            </ul>
        </ul>
      <li>
        <strong>find 연산의 작동 원리</strong>
      </li>
        <ul>
          <li>
            1. 대상 노드 리스트에 index값과 value값 동일한지 확인한다.
            <br>→ 2. 동일하지 않다면 value값이 가리키는 index의 위치로 이동한다.
            <br>→ 3. 이동 위치의 index값과 value 값이 같을 때까지 1 ~ 2를 반복한다. (재귀 구현).
            <br>→ 4. 대표 노드에 도달하면 재귀 함수를 빠져나오면서 모든 노드값을 대표 노드값으로 변경한다.
          </li>
        </ul>
    </ul>
</ul>

```python
# 집합 표현하기 - 1717
import sys
input = sys.stdin.readline
sys.setrecursionlimit(100000)
N, M = map(int, input().split())
parent = [0] * (N + 1)

def find(a):
    
    # 자기자신이기에 그대로 출력
    if a == parent[a]:
        return a
    # value 값을 따라 속한 집합(root)를 찾기위해 재귀를 활용한다.
    else:
        # 재귀를 빠져 나오면서 모든 경로 노드의 value를 root 노드로 변환한다. (경로 압축).
        parent[a] = find(parent[a])
        return parent[a]

def union(a, b):
    a = find(a)
    b = find(b)
    # 일반적으로 union을 진행하는 과정에서 대소관계는 상관없다.
    if a != b:
      parent[b] = a

def checkSampe(a, b):
    a = find(a)
    b = find(b)
    if a == b:
        return True
    return False

# union-find 그래프 생성
for i in range(0, N + 1):
    parent[i] = i

for i in range(M):
    question, a, b = map(int, input().split())
    if question == 0:
        union(a, b)
    else:
        if checkSame(a, b):
            print("YES")
        else:
            print("NO")
```