<h1>1. 기하 알아보기</h1>
<h2>1-1. 기하의 핵심 이론</h2>
<ul>
  <li>
    <strong>CCW(counter-clockwise)</strong>는 <strong>평면상의 3개의 점</strong>과 관견된 점들의 <strong>위치 관계</strong>를 판단하는 알고리즘이다. 수학적으로는 <strong>벡터의 외적</strong>과 관련된 이해가 필요하다.
  </li>
  <li>
    <strong>CW 공식</strong>
  </li>
    <ul>
      <li>
        CCW = (X1Y2 + X2Y3 + X3Y1) - (X2Y1 + X3Y2 + X1Y3)
      </li>
    </ul>
  <li>
    CCW 공식 도출 과정
  </li>
    <ul>
      <li>
        1. X와 Y의 첫 번째 값을 한 번 더 쓴다. 
      </li>
      <li>
        2. 오른쪽 아래로 가는 곱은 더하고, 반면 왼쪽 아래로 가는 곱은 뺀다.
      </li>
      <li>
        3. CCW의 결과 세 가지: 세 점으로 이루어진 두 벡터의 외적값을 의미하며 <strong>|CCW 결과값| / 2</strong>는 세 점으로 이루어진 삼각형의 넓이이다.
      </li>
        <ul>
          <li>
            3-a) <strong>CCW < 0</strong>: 시계 방향
          </li>
          <li>
            3-b) <strong>CCW == 0</strong>: 일직선
          </li>
          <li>
            3-c) <strong>CCW > 0</strong>: 반시계 방향
          </li>
        </ul>
    </ul>
</ul>

```python
# 선분 방향 구하기 - 11758
import sys
input = sys.stdin.readline
x1, y1 = map(int, input().split())
x2, y2 = map(int, input().split())
x3, y3 = map(int, input().split())

# CCW 공식
result = (x1 * y2 + x2 * y3 + x3 * y1) - (x2 * y1 + x3 * y2 + x1 * y3)

if result > 0:
    print(1)
elif result < 0:
    print(-1)
else:
    print(0)
```

```python
# 선분의 교차 여부 구하기 - 17387
import sys
input = sys.stdin.readline
x1, y1, x2, y2 = map(int, input().split())
x3, y3, x4, y4 = map(int, input().split())

# CCW 함수
def CCW(x1, y1, x2, y2, x3, y3):
    
    # CCW 연산 수행
    temp = (x1 * y2 + x2 * y3 + x3 * y1) - (x2 * y1 + x3 * y2 + x1 * y3)

    # 각 case 분류
    # 반시계방향
    if temp > 0:
        return 1
    
    # 시계방향
    elif temp < 0:
        return -1
    
    # 겹치는 경우
    else:
        return 0

# 선분이 완전히 겹치는지 판별하는 함수.
def isOverlab(x1, y1, x2, y2, x3, y3, x4, y4):
    if min(x1, x2) <= max(x3, x4) and min(x3, x4) <= max(x1, x2) and min(y1, y2) <= max(y3, y4) and min(y3, y4) <= max(y1, y2):
        return True
    else:
        return False

# 선분이 교차하는지 확인하는 함수
def isCross(x1, y1, x2, y2, x3, y3, x4, y4):
    abc = CCW(x1, y1, x2, y2, x3, y3)
    abd = CCW(x1, y1, x2, y2, x4, y4)
    # 부호가 반대이면 교차하지만, 연속된 선에서만 교차할 수 있기에
    # 다른 선분에서도 확인해야 함.
    cda = CCW(x3, y3, x4, y4, x1, y1)
    cdb = CCW(x3, y3, x4, y4, x2, y2)
    
    # 둘 다 음수라면 교차하는 것.
    if abc * abd <= 0 and cda * cdb <= 0:
        return True
    else:
        False

# 교차하는지 검증
cross = isCross(x1, y1, x2, y2, x3, y3, x4, y4)

# 결과 출력
if cross:
    print(1)
else:
    print(0)
```

```python
# 선분을 그룹으로 나누기 - 2162
import sys
input = sys.stdin.readline
N = int(input())
parent = [-1] * (3001)

# CCW 연산
def CCW(x1, y1, x2, y2, x3, y3):
    temp = (x1 * y2 + x2 * y3 + x3 * y1) - (x2 * y1 + x3 * y2 + x1 * y3)
    
    # 반시계방향
    if temp > 0:
        return 1
    # 시계방향
    elif temp < 0:
        return -1
    # 직선
    else:
        return 0

# 선분 교차 여부 판별
def isCross(x1, y1, x2, y2, x3, y3, x4, y4):
    abc = CCW(x1, y1, x2, y2, x3, y3)
    abd = CCW(x1, y1, x2, y2, x4, y4)
    cda = CCW(x3, y3, x4, y4, x1, y1)
    cdb = CCW(x3, y3, x4, y4, x2, y2)
    
    # 두 쪽 모두 직선인 경우 겹치는지 확인
    if abc * abd == 0 and cda * cdb == 0:
        return isOverlab(x1, y1, x2, y2, x3, y3, x4, y4)
    # 둘 다 음수라면 교차
    elif abc * abd <= 0 and cda * cdb <= 0:
        return True
    # 아니라면 교차 X
    else:
        return False

# Union-find 변형
def find(a):
    # -1로 초기화 했기에 0보다 작은 경우 root 임.
    if parnet[a] < 0:
        return a
    
    # 아니라면 root 찾고 반환
    else:
        parent[a] = find(parent[a])
        return parent[a]

def union(a, b):
    p = find(a)
    q = find(b)

    # 둘의 root가 같다면
    if p == q:
        return
    
    # 서로 갖고 있는 선분의 수를 더해 저장한다.
    parent[p] += parent[q]
    parent[q] = p

# 입력값을 받을 리스트 초기화
L = []
L.append([])

for i in range(1, N + 1):
    L.append([])
    L[i] = list(map(int, input().split()))

    # 선분을 하나씩 중복 확인하며 확인 (처음에는 연결 안 되었어도 후에는 다른 선분으로인해 교차될 수 있기 때문).
    for j in range(1, i):
        if isCross(L[i][0], L[i][1], L[i][2], L[i][3], L[j][1], L[j][2], L[j][3]):
            union(i, k)
            
ans = 0
res = 0

for i in range(1, N + 1):
    if parent[i] < 0:
        ans += 1
        res = min(res, parent[i])

print(ans)
print(-res)
```