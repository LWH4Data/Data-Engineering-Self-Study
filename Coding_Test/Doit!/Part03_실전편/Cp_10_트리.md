<h1>1. 트리 알아보기</h1>
<ul>
  <li>
    <strong>트리(tree)</strong>는 노드와 에지로 연결된 <strong>그래프의 특수한 형태</strong>로, 주요 특징은 다음과 같다.
  </li>
    <ul>
      <li>
        <strong>순환 구조(cycle)</strong>를 지니고 있지 않고, <strong>1개의 루트 노드</strong>를 갖는다.
      </li>
      <li>
        루트 노드를 제외한 노드는 <strong>단 1개의 부모 노드</strong>를 갖는다.
      </li>
      <li>
        트리의 <strong>부분 트리(subtree)</strong> 역시 트리의 모든 특징을 따른다.
      </li>
    </ul>
</ul>

<br>

<h2>1-1. 트리의 핵심 이론</h2>
<ul>
  <li>
    트리의 각 구성 요소가 장표로 정리되어 있는데 읽어보면 된다.
  </li>
</ul>

```python
# 트리의 부모 찾기 - 11725
#   ● 도서에서는 DFS를 사용하는데 나의 경우 파이썬에서 DFS를 선호하지 않는다.
import sys
sys.setrecursionlimit(10**6)
input = sys.stdin.readline

N = int(input())
visited = [False] * (N + 1)
tree = [[] for _ in range(N + 1)]
answer = [0] * (N + 1)

for _ in range(1, N):
    n1, n2 = map(int, input().split())
    tree[n1].append(n2)
    tree[n2].append(n1)

# DFS 탐색 함수.
def DFS(number):
    visited[number] = True
    for i in tree[number]:
        if not visited[i]:
            # DFS를 수행하면서 부모 노드를 정답 리스트에 저장.
            answer[i] = number

# 부모 노드부터 DFS 시작
DFS(1)

for i in range(2, N + 1):
    print(answer[i])
```

```python
# 리프 노드의 개수 구하기 - 1068
import sys
# 재귀 함수를 위해 충분히 큰 수로 한곗값 설정
sys.setrecursionlimit(10**6)
input = sys.stdin.readline
N = int(input())
visited = [False] * N
tree = [[] for _ in range(N)]
answer = 0
p = list(map(int, input().split()))

for i in range(N):
    if [i] != -1:
        tree[i].append(p[i])
        tree[p[i]].append(i)
    else:
        root = i

# DFS 탐색 함수.
def DFS(number):
    global answer
    visited[number] = True
    cNode = 0

    for i in tree[number]:
        if not visited[i] and i != deleteNode:
            cNode += 1
            DFS(i)
    # 자식 노드 수가 0개일 때 리프 노드로 간주하고 정답 값 증가.
    if cNode == 0:
        answer += 1

deleteNode = int(input())

if deleteNode == root:
    print(0)
else:
    DFS(root)
    print(answer)

#============================================================
# 하단은 BFS와 Union-find로 푼 풀이
#============================================================
def find(a):
    # find를 하는 도중 del_node를 만난다면 del_node의 자식이므로
    # 제외.
    if parent[a] == del_node:
        return del_node

    # 노드 a가 부모가 없다면 조상을 찾은 것.
    if parent[a] == a:
        return a
    
    # 아니라면 조상까지 찾아서 올라감.
    else:
        parent[a] = find(parent[a])
        return parent[a]

# 풀이==========================================================
# 입력값 받기.
N = int(sys.stdin.readline())
if N == 1:
    print(0)
else:
    parents_list = list(map(int, sys.stdin.readline().split()))
    # 트리를 구현
    graph = defaultdict(list)
    for i in range(len(parents_list)):
        if parents_list[i] == -1:
            root = i
        else:
            graph[parents_list[i]].append(i)

    # 삭제될 노드와 그 자식들을 find() 함수로 삭제
    del_node = int(sys.stdin.readline())
    
    if del_node == root:
        print(0)
        sys.exit()

    # 부모 노드를 관리할 parent 리스트 구현. (0부터 시작).
    parent = [0] * N
    for i in range(N):
        parent[i] = i
    for i in range(N):
        for child in graph[i]:
            parent[child] = i

    # BFS 돌리면서 정답 체크
    q = deque()
    q.append(root)
    ans = 0
    visited = [False] * N
    visited[root] = True

    while q:
        now = q.popleft()

        valid_child = 0
        
        # now에 자식이 있는 경우
        for next in graph[now]:

            # 자식 노드가 del_node인지 혹은 그 자손인지 확인한다.
            if next == del_node or find(next) == del_node:
                continue

            # 방문 여부를 체크한다.
            if visited[next]:
                continue
            visited[next] = True

            # next가 del_node도 아니고, 방문한 적이 없다면 탐색 가능한 자식이기에
            # q에 추가하고, 하단에서 leaf node로 추가되지 않도록 +1을 한다.
            valid_child += 1
            q.append(next)

        # now에 자식이 없는 경우는 leaf node이기에 +1을 하여 ans에 포함되지 않도록 한다.
        if valid_child == 0:
            ans += 1
        
    print(ans)
```