<h1>1. 트리 알아보기</h1>
<ul>
  <li>
    <strong>트리(tree)</strong>는 노드와 에지로 연결된 <strong>그래프의 특수한 형태</strong>로, 주요 특징은 다음과 같다.
  </li>
    <ul>
      <li>
        <strong>순환 구조(cycle)</strong>를 지니고 있지 않고, <strong>1개의 루트 노드</strong>를 갖는다.
      </li>
      <li>
        루트 노드를 제외한 노드는 <strong>단 1개의 부모 노드</strong>를 갖는다.
      </li>
      <li>
        트리의 <strong>부분 트리(subtree)</strong> 역시 트리의 모든 특징을 따른다.
      </li>
    </ul>
</ul>

<br>

<h2>1-1. 트리의 핵심 이론</h2>
<ul>
  <li>
    트리의 각 구성 요소가 장표로 정리되어 있는데 읽어보면 된다.
  </li>
</ul>

```python
# 트리의 부모 찾기 - 11725
#   ● 도서에서는 DFS를 사용하는데 나의 경우 파이썬에서 DFS를 선호하지 않는다.
import sys
sys.setrecursionlimit(10**6)
input = sys.stdin.readline

N = int(input())
visited = [False] * (N + 1)
tree = [[] for _ in range(N + 1)]
answer = [0] * (N + 1)

for _ in range(1, N):
    n1, n2 = map(int, input().split())
    tree[n1].append(n2)
    tree[n2].append(n1)

# DFS 탐색 함수.
def DFS(number):
    visited[number] = True
    for i in tree[number]:
        if not visited[i]:
            # DFS를 수행하면서 부모 노드를 정답 리스트에 저장.
            answer[i] = number

# 부모 노드부터 DFS 시작
DFS(1)

for i in range(2, N + 1):
    print(answer[i])
```

```python
# 리프 노드의 개수 구하기 - 1068
import sys
# 재귀 함수를 위해 충분히 큰 수로 한곗값 설정
sys.setrecursionlimit(10**6)
input = sys.stdin.readline
N = int(input())
visited = [False] * N
tree = [[] for _ in range(N)]
answer = 0
p = list(map(int, input().split()))

for i in range(N):
    if [i] != -1:
        tree[i].append(p[i])
        tree[p[i]].append(i)
    else:
        root = i

# DFS 탐색 함수.
def DFS(number):
    global answer
    visited[number] = True
    cNode = 0

    for i in tree[number]:
        if not visited[i] and i != deleteNode:
            cNode += 1
            DFS(i)
    # 자식 노드 수가 0개일 때 리프 노드로 간주하고 정답 값 증가.
    if cNode == 0:
        answer += 1

deleteNode = int(input())

if deleteNode == root:
    print(0)
else:
    DFS(root)
    print(answer)

#============================================================
# 하단은 BFS와 Union-find로 푼 풀이
#============================================================
def find(a):
    # find를 하는 도중 del_node를 만난다면 del_node의 자식이므로
    # 제외.
    if parent[a] == del_node:
        return del_node

    # 노드 a가 부모가 없다면 조상을 찾은 것.
    if parent[a] == a:
        return a
    
    # 아니라면 조상까지 찾아서 올라감.
    else:
        parent[a] = find(parent[a])
        return parent[a]

# 풀이==========================================================
# 입력값 받기.
N = int(sys.stdin.readline())
if N == 1:
    print(0)
else:
    parents_list = list(map(int, sys.stdin.readline().split()))
    # 트리를 구현
    graph = defaultdict(list)
    for i in range(len(parents_list)):
        if parents_list[i] == -1:
            root = i
        else:
            graph[parents_list[i]].append(i)

    # 삭제될 노드와 그 자식들을 find() 함수로 삭제
    del_node = int(sys.stdin.readline())
    
    if del_node == root:
        print(0)
        sys.exit()

    # 부모 노드를 관리할 parent 리스트 구현. (0부터 시작).
    parent = [0] * N
    for i in range(N):
        parent[i] = i
    for i in range(N):
        for child in graph[i]:
            parent[child] = i

    # BFS 돌리면서 정답 체크
    q = deque()
    q.append(root)
    ans = 0
    visited = [False] * N
    visited[root] = True

    while q:
        now = q.popleft()

        valid_child = 0
        
        # now에 자식이 있는 경우
        for next in graph[now]:

            # 자식 노드가 del_node인지 혹은 그 자손인지 확인한다.
            if next == del_node or find(next) == del_node:
                continue

            # 방문 여부를 체크한다.
            if visited[next]:
                continue
            visited[next] = True

            # next가 del_node도 아니고, 방문한 적이 없다면 탐색 가능한 자식이기에
            # q에 추가하고, 하단에서 leaf node로 추가되지 않도록 +1을 한다.
            valid_child += 1
            q.append(next)

        # now에 자식이 없는 경우는 leaf node이기에 +1을 하여 ans에 포함되지 않도록 한다.
        if valid_child == 0:
            ans += 1
        
    print(ans)
```

<br><br>

<h1>2. 트라이</h1>
<ul>
  <li>
    <strong>트라이(trie)</strong>는 <strong>문자열 검색</strong>을 빠르게 실행할 수 있도록 설계한 트리 형태의 자료구조이다.
  </li>
</ul>

<br>

<h2>2-1. 트라이의 핵심 이론</h2>
<ul>
  <li>
    트라이는 일반적으로 단어들을 <strong>사전 형태</strong>로 생성한 후 트리의 <strong>부모 자식 노드 관계</strong>를 통해 검색을 수행한다.
  </li>
  <li>
    <strong>트라이의 특징</strong>
  </li>
    <ul>
      <li>
        <strong>N진 트리</strong>: 문자 종류의 개수에 따라 N이 결정된다. (26개의 문자 → 26진 트리)
      </li>
      <li>
        <strong>루트 노드</strong>는 항상 빈 문자열을 뜻하는 <strong>공백 상태</strong>를 유지한다.
      </li>
    </ul>
</ul>

```python
# 문자열 찾기 - 14425
from sys import stdin
input = stdin.readline

# 그냥 Trie 클래스에 선언하고 사용하면 안되나?
class Node(object):
    def __init__(self, isEnd):
        self.isEnd = isEnd
        self.childNode = {}

class Trie(object):
    def __init__(self):
        self.parent = Node(None)
    
    # 문자 삽입
    def insert(self, string):
        nowNode = self.parent
        temp_length = 0
        for char in string:
            # 자식 Node에 미생성된 문자열이면 새로 생성.
            if char not in nowNode.childNode:
                nowNode.childNode[char] = Node(char)
            # 자식 노드로 이동
            nowNode = nowNode.childNode[char]
            temp_length += 1
            if temp_length == len(string):
                nowNode.isEnd = True
    
    # 문자열이 존재하는지 탐색.
    def search(self, string):
        nowNode = self.parent
        temp_length = 0
        for char in string:
            if char in nowNode.childNode:
                nowNode = nowNode.childNode[char]
                temp_length += 1
                if temp_length == len(string) and nowNode.isEnd == True:
                    return True
                else:
                    return False
            return False

N, M = map(int, input().split())
# Trie 생성
myTrie = Trie()

for _ in range(N):
    word = input().strip()
    # 단어 삽입
    myTrie.insert(word)

result = 0

for _ in range(M):
    word = input().strip()
    # 단어 찾기
    if myTrie.search(word):
        result += 1

print(result)

# set을 활용한 파이썬 풀이======================================
#   ● set은 원소를 hash로 변환한 위치에 데이터를 저장하기에 같은 값을 접근할 때 O(1)이다.
#   ● 따라서 값 탐색과 같은 특정 상황에서는 list보다 set을 사용하는 것이 유리하다.
import sys
input = sys.stdin.readline
n, m = map(int, sys.stdin.readline())
# set 형태로 집합 S 문자열 저장
textList = set([input() for _ in range(n)])
count = 0

# set 형태의 집합 문자열에서 검사 문자열이 있는지 확인.
for _ in range(m):
    subText = input()
    if subText in TextList:
        count += 1

print(count)
```

<br><br>

<h1>3. 이진 트리</h1>
<ul>
  <li>
    <strong>이진 트리(bianry tree)</strong>는 갹 노드의 자식 노드(차수)의 개수가 <strong>2이하</strong>로 구성돼 있는 트리를 의미한다.
  </li>
</ul>

<br>

<h2>3-1. 이진 트리의 핵심 이론</h2>
<h3>3-1-1. 이진 트리의 종류</h3>
<ul>
  <li>
    이진 트리에는 다음의 종류들이 있다.
  </li>
    <ul>
      <li>
        <strong>편향 이진 트리</strong>: 노드들이 <strong>한쪽으로 편향</strong>돼 생성된 이진 트리
      </li>
      <li>
        <strong>포화 이진 트리</strong>: 트리의 <strong>높이가 모두 일정</strong>하며 <strong>리프 노드가 꽉 찬</strong> 이진 트리
      </li>
      <li>
        <strong>완전 이진 트리</strong>: 마지막 레벨을 제외하고 <strong>완전하게 노드들이 채워져</strong> 있으며 마지막은 <strong>왼쪽</strong>부터 채워진 트리
      </li>
    </ul>
  <li>
    일반적으로 코딩 테스트에서 편향 이진 트리는 시간 복잡도가 커지기에 <strong>완전 이진 트리</strong> 형태로 구현을 한다.
  </li>
</ul>

<h3>3-1-2. 이진 트리의 순차 표현</h3>
<ul>
  <li>
    가장 직관적이면서 편리한 트리 자료구조 형태는 <strong>리스트</strong>이다.
  </li>
  <li>
    완전 이진 트리로 구축할 경우 <strong>트리의 노드</strong>와 <strong>리스트의 index</strong> 간의 상관 관계는 다음과 같다.
  </li>
    <ul>
      <li>
        <strong>루트 노드</strong>
      </li>
        <ul>
          <li>
            index = 1
          </li>
          <li>
            제약 조건 X
          </li>
        </ul>
      <li>
        <strong>부모 노드</strong>
      </li>
        <ul>
          <li>
            index = index / 2
          </li>
          <li>
            제약 조건: 현재 노드가 루트 노드가 아님.
          </li>
        </ul>
      <li>
        <strong>왼쪽 자식 노드</strong>
      </li>
        <ul>
          <li>
            index = index * 2
          </li>
          <li>
            제약 조건: index * 2 <= N
          </li>
        </ul>
      <li>
        <strong>오른쪽 자식 노드</strong>
      </li>
        <ul>
          <li>
            index = index * 2 + 1
          </li>
          <li>
            제약 조건: index * 2 + 1 <= N
          </li>
        </ul>
    </ul>
  <li>
    인덱스의 연산은 세그먼트 트리(segment tree)나 LCA(lowest common ancestor) 알고리즘의 기본이기에 숙지해 두어야 한다.
  </li>
    <ul>
      <li>
        위의 연산은 7개의 노드로 된 완전 이진 트리를 그리고 직접 index 연산을 수행하면 쉽게 구할 수 있다.
      </li>
    </ul>
</ul>

```python
# 트리 순회하기 - 1991
#   ● tree 구조를 defaultdict로 수정하여 구현.
from collections import defaultdict

N = int(sys.stdin.readline())
tree = defaultdict(list)

for _ in range(N):
    root, left, right = sys.stdin.readline().split()
    tree[root].append((left, right))

def preOrder(now):
    if now == '.':
        return
    # 1. 현재 노드
    print(now, end='')
    # 2. 왼쪽 탐색
    preOrder(tree[now][0])
    # 3. 오른쪽 탐색
    preOrder(tree[now][1])

def inOrder(now):
    if now == '.':
        return
    # 1. 왼쪽 탐색
    inOrder(tree[now][0])
    # 2. 현재 노드
    print(now, end='')
    # 3. 오른쪽 탐색
    inOrder(tree[now][1])

def postOrder(now):
    if now == '.':
        return
    # 1. 왼쪽 탐색
    postOrder(tree[now][0])
    # 2. 오른쪽 탐색
    postOrder(tree[now][1])
    # 3. 현재 노드
    print(now, end='')

preOrder('A')
print()
inOrder('A')
print()
postOrder('A')
```

<br><br>

<h1>4. 세그먼트 트리</h1>
<ul>
  <li>
    세그먼트 트리란 주어진 테이터의 <strong>구간 합</strong>과 <strong>데이터 업데이트</strong>를 수행하기 위해 고안된 자료구조이다.
  </li>
  <li>
    더 큰 범위에서는 인덱스 트리라고도 불린다.
  </li>
</ul>

<br>

<h2>4-1. 세그먼트 트리의 핵심 이론</h2>
<ul>
  <li>
    세그먼트 트리의 종류는 구간 합, 최대 및 최소 구하기로 나눌 수 있다.
  </li>
  <li>
    구현 단계는 <strong>트리 초기화 → 질의값 구하기(구간합, 최대 , 최소) → 데이터 업데이트</strong>하기로 나눌 수 있다.
  </li>
    <ul>
      <li>
        <strong>1. 트리 초기화하기</strong>
      </li>
        <ul>
          <li>
            리프 노드의 개수가 데이터의 개수(N) 이상이 되도록 리스트를 만든다.
          </li>
          <li>
            리스트의 크기는 <strong>2^k ≥ N</strong>를 만족하는 k의 최솟값을 찾고, <strong>2^k * 2</strong>를 리스트의 크기로 정의하면 된다.
          </li>
          <li>
            리프 노드의 시작 위치는 리스트의 <strong>2^k</strong> 인덱스 위치를 시작 인덱스로 취한다.
          </li>
          <li>
            2^k-1부터 1번 쪽으로 값을 채울 때에는 <strong>자식 노드의 인덱스</strong>를 활용한다.
          </li>
          <li>
            이렇게 목적에 맞는 트리를 구성하면 이후 탐색에 있어 시간 복잡도를 단축할 수 있다.
          </li>
        </ul>
      <li>
        <strong>2. 질의값 구하기</strong>
      </li>
        <ul>
          <li>
            주어진 질의 인덱스를 <strong>세그먼트 트리의 리프 노드에 해당하는 인덱스</strong>로 변경한다.
          </li>
          <li>
            해당하는 노드를 구하고 선택하는 기준은 다음과 같다.
          </li>
            <ul>
              <li>
                a. start_index % 2 == 1일 때 해당 노드 선택.
              </li>
                <ul>
                  <li>
                    오른쪽 자식일 경우 왼쪽 자식의 정보는 필요없기 때문에 선택해야 한다.
                  </li>
                  <li>
                    그렇지 않으면 상위 depth로 넘어갈 때 해당 노드의 정보를 잃는다.
                  </li>
                </ul>
              <li>
                b. end_index % 2 == 0일 때 해동 노드를 선택.
              </li>
                <ul>
                  <li>
                    왼쪽 자식일 경우 오른쪽 자식(end 범위 넘어섬)
                  </li>
                </ul>
              <li>
                c. depth를 변경하여 start_index를 탐색 
              </li>
                <ul>
                  <li>
                    start_index = (start_index + 1) / 2
                  </li>
                  <li>
                    start_index + 1을 하는 이유는 depth가 올라갔을 떄 범위 내의 부모를 찾기 위해서이다. -1을 하면 start_index보다 작아져 범위를 벗어난다.
                  </li>
                </ul>
              <li>
                d. depth를 변경하여 end_index를 탐색. 
              </li>
                <ul>
                  <li>
                    end_index = (end_index - 1) / 2
                  </li>
                </ul>
              <li>
                e. a ~ d를 반복하다 end_index < start_index가 되면 종료한다.
              </li>
            </ul>
          <li>
            질의에 해당하는 노드 연산은 다음고 같다.
          </li>
            <ul>
              <li>
                <strong>구간 합</strong>: 선택된 노드들을 모두 더하여 출력한다.
              </li>
              <li>
                <strong>최댓값 구하기</strong>: 선택된 노드들 중 MAX 값을 선택해 출력한다.
              </li>
              <li>
                <strong>최솟값 구하기</strong>: 선택된 노드들 중 MIN 값을 선택해 출력한다.
              </li>
            </ul>
        </ul>
      <li>
        3. 데이터 업데이트하기
      </li>
        <ul>
          <li>
            각 구현에 맞게 부모 노드를 업데이트 하면 된다.
          </li>
        </ul>
    </ul>
</ul>

```python
# 구간 합 구하기 3 - 2042
import sys
input = sys.stdin.readline

# 수의 개수, 변경이 일어나는 횟수, 구간 힙을 구하는 횟수
N, M, K = map(int, input().split())
treeHeight = 0
length = N

# 트리의 전체 높이를 계산한다.
#   ● 트리를 생성하기 위한 k를 찾는 것.
while length != 0:
    length //= 2
    treeHeight += 1

# pow는 2**treeHeight + 1을 의미
#  ● 위에서 구현 treeHeight을 통해 트리구현.
treeSize = pow(2, treeHeight + 1)
# 시작 인덱스의 한 칸 앞의 index를 초기화한다.
#   ● 1번부터 첫 번째 노드가 되도록 연산을 수행하기 때문이다.
leftNodeStartIndex = treeSize // 2 - 1
tree = [0] * treeSize

# 데이터를 리프 노드에 저장.
#   ● 시작 인덱스부터 leaf node의 끝까지 값을 채운다.
#   ● 앞서 leftNodeStartIndex를 시작 leafnode의 바로 앞 index로 하였기에 +1로 시작
#   ● n-th와 같이 몇 번째 수가 들어올 때 계산을 깔끔히 하기 위함.
for i in range(leftNodeStartIndex + 1, leftNodeStartIndex + N + 1):
    tree[i] = int(input())

# 인덱스 트리 생성 함수
#   ● 몫을 통해서 중복으로 누적합을 통해 구현하는 방법을 채택한다.
#   ● for loop 보다 안정적인 방법
def setTree(i):
    while i != 1:
        tree[i // 2] += tree[i]
        i -= 1

# 0번 index를 제외하고 모든 칸을 대상으로 하기에 treeSize -1이 된다.
setTree(treeSize - 1)

# 값 변경 함수
def changeVal(index, value):
    # 차이만을 계산하여 부모로 전파한다.
    diff = value - tree[index]
    while index > 0:
        tree[index] = tree[index] + diff
        # 부모의 index를 index // 2를 통해 구한다.
        index = index // 2

# 구간 합 계산 함수
def getSum(s, e):
    partSum = 0
    while s <= e:
        if s % 2 == 1:
            partSum += tree[s]
            s += 1
        if e % 2 == 0:
            partSum += tree[e]
            e -= 1
        s = s // 2
        e = e // 2
    
    return partSum

for _ in range(M + K):
    question, s, e = map(int, input().split())
    if question == 1:
        changeVal(leftNodeStartIndex + s, e)
    elif question == 2:
        s = s + leftNodeStartIndex
        e = e + leftNodeIndex\
        print(getSum(s, e))
```

```python
# 최솟값 찾기 2 - 10868
#   ● 도서와는 다르지만 직관적인 방법으로 풀이를 변경 및 템플릿화 함.
#   ● index 다루는 방식의 차이라 생각.

# 입력값 받기
N, M = map(int, sys.stdin.readline().split())

# 최솟값을 반환하는 함수=========================================
def seg_min(start_idx, end_idx):
    start_idx += startNode
    end_idx += startNode
    # 최대값을 초기화하고 업데이트 하는 방식으로 활용.
    #   ● list를 생성하고 append한 뒤 마지막에 min()을 처리하는 건
    #     메모리 낭비가 된다.
    result = sys.maxsize
    
    while start_idx <= end_idx:
        if start_idx % 2 == 1:
            result = min(result, seg_tree[start_idx])
            start_idx += 1
        
        if end_idx % 2 == 0:
            result = min(result, seg_tree[end_idx])
            end_idx -= 1
        
        start_idx //= 2
        end_idx //= 2
    
    print(result)

# segment tree 구현============================================
length = N
treeHeight = 0
while length != 0:
    length //= 2
    treeHeight += 1

# leafnode들 구현
treeSize = pow(2, treeHeight + 1)
seg_tree = [sys.maxsize] * treeSize
startNode = treeSize // 2
for i in range(startNode, startNode + N):
    seg_tree[i] = int(sys.stdin.readline())

# 부모 노드의 값 채우기
for i in range(startNode - 1, 0, -1):
    seg_tree[i] = min(seg_tree[2*i], seg_tree[2*i + 1])

# 쌍이 주어졌을 때 최솟값을 반환한다.
for _ in range(M):
    a, b = map(int, sys.stdin.readline().split())
    a -= 1
    b -= 1
    seg_min(a, b)
```