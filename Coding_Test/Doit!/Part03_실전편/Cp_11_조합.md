<h1>1. 조합 알아보기</h1>
<ul>
  <li>
    <strong>조합(combination)</strong>은 <strong>nCr</strong>로 표현하며 <strong>n개의 숫자 중 r개</strong>를 뽑는 경우의 수를 뜻합니다.
  </li>
  <li>
    <strong>순열</strong>은 <strong>nPr</strong>로 표현하며 <strong>n개의 숫자 중 r개</strong>를 뽑아 <strong>순서</strong>를 고려해 나열하는 경우의 수를 의미한다.
  </li>
</ul>

<br>

<h2>1-1. 순열과 조합의 핵심 이론</h2>

<p>

순열의 식은 다음과 같다.
$$ _nP_r= \frac{n!}{(n-r)!} $$

조합의 식은 다음과 같다.
$$ _nC_r= \frac{n!}{(n-r)!r!} $$

순열과 조합은 동적 계획법(DP)의 시작이 되기에 잘 준비해 두면 도움이 된다.

</p>

<br>

<h2>1-2. 조합 문제 풀이 순서</h2>
<ul>
  <li>
    1. 특정 문제를 가정하기
  </li>
    <ul>
      <li>
        5개의 데이터에서 3개를 선택하는 조합의 경우의 수를 가정한다.
      </li>
    </ul>
  <li>
    2. 모든 부분 문제가 해결된 상황이라 가정하고 문제 생각하기
  </li>
    <ul>
      <li>
        예를 들어 이미 1 ~ 4까지 두 개의 수를 선택하고 5가 남는다.
      </li>
      <li>
        이때에는 5를 선택하거나 1 ~ 4 중 하나를 선택하는 두 가지 방법이 존재한다.
      </li>
      <li>
        따라서 점화식은 D[5][3] = D[4][2] + D[4][3]과 같아 진다.
      </li>
    </ul>
  <li>
    3. 특정 문제를 해결한 내용을 바탕으로 일반 점화식 도출하기
  </li>
    <ul>
      <li>
        점화식을 일반화하면 D[i][j] = D[i-1][j] + D[i-1][j-1]이 된다.
      </li>
    </ul>
</ul>

```python
# 이항 계수 구하기 1 - 11050

import sys
input = sys.stdin.readline
N, K = map(int, input().split())

# 조합을 구하기 위한 DP 테이블 생성
D = [[0] * (N + 1) for _ in range(N + 1)]

# 점화식을 통해 DP 테이블 채우기
for i in range(0, N + 1):
    D[i][1] = i    # i개 중에 하나를 선택하는 경우의 수 = i
    D[i][0] = 1    # i개 중에 아무것도 선택하지 않는 경우의 수 = 1
    D[i][i] = 1    # i개 중에 i개를 선택하는 경우의 수 = 1

# 조합 기본 점화식을 통해 나머지 칸을 채우기.
#   ● 가로 축이 i, 세로 축이 j 이다.
for i in range(2, N + 1):
    for j in range(1, i):
        D[i][j] = D[i - 1][j] + D[i - 1][j - 1]

print(D[N][K])
```

```python
# 이항계수 구하기 2 - 11051
import sys
input = sys.stdin.readline
N, K = map(int, input().split())
D = [[0] * (N + 1) for _ in range(N + 1)]

# DP 테이블 초기화
for i in range(N + 1):
    D[i][1] = i
    D[i][0] = 1
    D[i][i] = 1

# DP 테이블의 나머지 영역을 점화식으로 초기화
for i in range(2, N + 1):
    for j in range(1, i):
        D[i][j] = D[i-1][j] + D[i-1][j-1]
        # 바로 모듈러 연산을 진행.
        D[i][j] = D[i][j] % 10007

print(D[N][K])
```

```python
# 부녀회장이 될 테야 - 2775
# 입력값 받기
T = int(sys.stdin.readline())

for _ in range(T):
    k = int(sys.stdin.readline())
    n = int(sys.stdin.readline())

    # DP 테이블 구현
    dp_table = [[0] * (n + 1) for _ in range(k + 1)]
    # 1호 채우기
    for i in range(k + 1):
        dp_table[i][1] = 1
    for i in range(1, n + 1):
        dp_table[0][i] = i
    
    # 점화식으로 남은 영역 채우기
    for i in range(1, k + 1):
        for j in range(2, n + 1):
            dp_table[i][j] = dp_table[i - 1][j] + dp_table[i][j - 1]
    
    print(dp_table[k][n])
```

```python
# 다리 놓기 - 1010

# 입력받기
T = int(sys.stdin.readline())

for _ in range(T):
    N, M = map(int, sys.stdin.readline().split())

    # M개중 N개이기에 M을 기준으로 DP 테이블을 생성한다.
    dp_table = [[0] * (M + 1) for _ in range(M + 1)]

    for i in range(M + 1):
        dp_table[i][i] = 1
        dp_table[i][1] = i
        dp_table[i][0] = 1
    
    # 점화식으로 DP 테이블 채우기.
    for i in range(2, M + 1):
        for j in range(1, i):
            dp_table[i][j] = dp_table[i - 1][j - 1] + dp_table[i - 1][j]

    print(dp_table[M][N])
```

```python
# 조약돌 꺼내기 - 13251
#   ● 조합 풀이
#       → 색깔별 조약돌의 개수에서 K개를 뽑을 수 있는 경우의 수를 구한 뒤
#       → 전체 돌에 대해 K를 뽑는 경우의 수로 나눈다.
#   ● 도서에서는 조합 외의 풀이를 시도해 볼것을 권하며 다음과 같다.

# 색깔별 조약돌 개수 저장 리스트(M은 50이하).
D = [0] * 51
# 색깔별 확률 저장 리스트
probability = [0] * 51
M = int(input())
D = list(map(int, input().split()))
T = 0

# 전체 돌의 개수 초기화
for i in range(M):
    T += D[i]

K = int(input())
ans = 0

# 정답 구하기
for i in range(M):
    # 돌의 수가 선택하는 K개보다 큰 경우
    if D[i] >= K:
        for k in range(K):
            # 확률식을 통해 업데이트
            probability[i] = probability[i] * (D[i] - k) / (T - k)
        ans += probability[i]
  
print(ans)

# 나의 풀이=======================================================
# 입력값 받기
M = int(sys.stdin.readline())
colors = list(map(int, sys.stdin.readline().split()))
K = int(sys.stdin.readline())
N = sum(colors)

# 1개반 뽑는 경우 예외처리
flag = False
if K == 1:
    flag = True

# 색상이 1개인 경우 예외처리
if M == 1:
    flag = True

# 색상 리스트의 M개의 원소마다 K번의 확률을 계산하고 더한다.
# 연산 수행으로 답 구하기
result = 0
temp = 0
for m in range(M):
    result += temp
    temp = 1
    for k in range(K):
        temp *= (colors[m] - k) / (N - k)


print(result + temp)

# 점화식?
# print((5/18)*(4/17) + (6/18)*(5/17) + (7/18)*(6/17))
```

```python
# 순열의 순서 구하기 - 1722
#   ● 이해가 안돼서 일단 정리해 둠.

import sys, time
sys.stdin = open("input.txt")
s_t = time.time()

# 3개를 선택하는 완탐시 20 * 20 * 20으로 가능할 듯. 여기에 정렬 Nlog(N)
#==============================================================
F = [0] * 21
S = [0] * 21
visited = [False] * 21
N = int(sys.stdin.readline())
F[0] = 1

# 팩토리얼 리스트 초기화
for i in range(1, N + 1):
    F[i] = F[i - 1] * i

# list로 입력 받기
num_list = list(map(int, sys.stdin.readline().split()))

# 1인 경우 K번째 순열 찾기
if num_list[0] == 1:

    # K 초기화
    K = num_list[1]

    # i번째 자리에 들어갈 숫자를 찾기
    for i in range(1, N + 1):
        cnt = 1  # 남은 숫자들 중 몇 번째를 선택할지 (1부터 시작)

        # 1부터 N까지 모든 숫자를 확인
        for j in range(1, N + 1):
            # 숫자 j를 이미 사용했다면 건너뛰기
            if visited[j]:
                continue

            # K가 cnt * F[N-i] 이하이면, 남은 숫자 중 cnt번째 숫자가 답
            if K <= cnt * F[N - i]:
                # 이전 그룹들의 경우의 수를 K에서 빼고
                K -= F[N - i] * (cnt - 1)
                # i번째 자리에 숫자 j를 배치
                S[i] = j
                visited[j] = True
                break
            
            # 아직 K가 더 크면, 다음 숫자 그룹으로
            cnt += 1
    
    for i in range(1, N + 1):
        print(S[i], end=' ')

else:
    # 주어진 순열이 몇 번째인지 구하기 (K = 1부터 시작)
    K = 1
    
    # 각 자리를 순회하며 앞에 몇 개의 순열이 있는지 계산
    for i in range(1, N + 1):
        cnt = 0  # num_list[i]보다 작으면서 아직 안 쓴 숫자 개수

        # num_list[i]보다 작은 숫자들 중 미사용 숫자를 세기
        for j in range(1, num_list[i]):
            if not visited[j]:
                cnt += 1
        
        # cnt개의 작은 숫자로 시작하는 순열들을 모두 건너뜀
        #  ● cnt: 현재 선택한 수보다 작은 미사용 수의 개수
        #  ● F[N - i]: 현재 자리 이후 남은 자리들의 경우의 수
        K += cnt * F[N - i]
        
        # 현재 자리의 숫자를 사용했다고 표시
        visited[num_list[i]] = True
    print(K)
#==============================================================

e_t = time.time()
print("time: ", e_t - s_t)
```

```python
# 사전 찾기 - 1256
import sys, time
sys.stdin = open("input.txt")
s_t = time.time()

#======================================================================
N, M, K = map(int, input().split())
# 조합의 경우의 수를 저장하는 DP 테이블
#   ● 핵심 조합이 C(N + M, M) 또는 C(N + M, N)이며 N + M = 200이기에 202로 설정한다.
#   ● N + M 중 N 혹은 M을 뽑는 조합인 이유는 a 혹은 z로 이루어져 N 개를 추출하면 알아서
#     나머지가 결정되기 때문이다.
D = [[0] * 202 for _ in range(202)]

# 조합 테이블 값 업대이트
for i in range(0, 201):
    # 선택하는 수의 개수(j)가 전체 수의 개수(i - 1)을 넘을 수 없음.
    for j in range(0, i + 1):
        # 1개를 뽑거나 0개를 뽑는 경우 1로 초기화
        #   ● 기존의 j == 1인 경우 i로 할당되는 경우는 하단의 점화식에 포함되기에 생략한다.
        if j == 0 or j == i:
            D[i][j] = 1
        # 위에 해당하지 않는다면 연산으로 값 초기화
        else:
            D[i][j] = D[i - 1][j - 1] + D[i - 1][j]
            # K 범위를 넘어간다면 범위의 최댓값 저장.
            #   ● 쓸대없는 값을 제거하여 최적화 한다.
            if D[i][j] > 1000000000:
                D[i][j] = 1000000001

# 주어진 자릿수로 만들 수 없는 K 번째 수의 경우 -1을 출력.
if D[N + M][M] < K:
    print(-1)
# 출력이 가능한 경우
else:
    while not (N == 0 and M == 0):
        # a를 선택해도 남은 경우의 수가 K보다 큰 경우 a를 출력
        #   ● K는 a로 시작하는 그룹에 속하기에 a를 출력한다.
        if D[N - 1 + M][M] >= K:
            print("a", end='')
            N -= 1
        # 아닌 경우 b를 출력하고, K와 M을 업데이트
        #   ● 남은 경우의 수가 K보다 작다는 건 a로 시작하는 조합의 수보다 K가 큰 것이기에 K는
        #     z로 시작하는 그룹에 속하게 되기 때문이다.
        else:
            print("z", end='')
            # 건너 뛴 그룹의 크기만큼 K를 줄인다.
            K -= D[N - 1 + M][M]
            M -= 1
#======================================================================

e_t = time.time()
print("time: ", e_t - s_t)
```

```python
# 선물 전달하기 - 1947

```