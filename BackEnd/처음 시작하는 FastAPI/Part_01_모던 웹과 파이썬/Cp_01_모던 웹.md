<h1>1. 서비스와 API</h1>
<ul>
  <li>
    사물을 연결하는 애플리케이션 프로그래밍 인터페이스(API)의 중요성이 점점 더 부각되고 있다.
  </li>
  <li>
    <strong>백</strong>과 <strong>프런트</strong>는 API를 통해 소통한다.
  </li>
  <li>
    API는 DB 스키마에 준하는 일종의 <strong>규약</strong>이다.
  </li>
</ul>

<h2>1-1. API 종류</h2>
<ul>
  <li>
    API는 제어 구조인 <strong>프로토콜</strong>과 콘텐츠 구조인 <strong>형식</strong>을 정의한다.
  </li>
  <li>
    네트워크의 연결 전에 API는 일반적으로 <strong>매우 가까운 연결</strong>을 의미하였으며 <strong>라이브러리의 함수를 호출</strong>하는 것이었다.
  </li>
  <li>
    <strong>원격 프로시저 호출(remote procedure call)은</strong> <strong>같은 컴퓨터</strong>나 <strong>다른 프로세스의 함수</strong>를 호출하기 위해서 개발되었다.
  </li>
  <li>
    <strong>메시징</strong>은 프로세스 간에 파이프라인으로 <strong>작은 데이터 청크를 전송</strong>한다.
  </li>
    <ul>
      <li>
        메시지는 <strong>동사와 같은 명령어</strong> 일 수 있으며 혹은 <strong>명사형으로 관련된 이벤트</strong>를 나타낼 수도 있다.
      </li>
      <li>
        메시징의 통신은 다음처럼 다양한 패턴이 존재한다.
      </li>
        <ul>
          <li>
            <strong>요청-응답</strong>: 웹 브라우저가 웹 서버를 호출하는 방법과 같다.
          </li>
          <li>
            <strong>게시-구독(publish-subscribe)</strong>: <strong>게시자</strong>가 메시지를 게시하면 <strong>구독자</strong>는 메시지의 일부 데이터에 따라 각각에 대해 조치를 취한다.
          </li>
          <li>
            <strong>대기열</strong>: 게시-구독과 비슷하지만 구독자 풀 중 하나에서만 메시지를 받아보고 해옫엥 롬긴다.
          </li>
        </ul>
    </ul>
</ul>

<br>

<h2>1-2. HTTP</h2>
<ul>
  <li>
    버너리스의 월드 와이드 웹을 위한 세 가지 구성 요소
  </li>
    <ul>
      <li>
        <strong>HTML</strong>: <strong>데이터를 표시</strong>하는 언어
      </li>
      <li>
        <strong>HTTP</strong>: 클라이언트-서버 <strong>프로토콜</strong>
      </li>
      <li>
        <strong>URL</strong>: 웹 리소스를 위한 <strong>주소 체계</strong>
      </li>
    </ul>
</ul>

<br>

<h2>1-3. REST(ful)</h2>
<ul>
  <li>
    로이 필딩은 박사 학위 논문에서 HTTP 사용을 위한 아키텍처 스타일인 대표 상태 전이(repesentational state transfer, REST)를 정의했다.
  </li>
  <li>
    엄격한 규칙 없이 공유되던 REST 방식이 진화를 거듭해 현대 웹의 주류인 RESTful로 불리게 되었으며 다음의 특징이 있다.
  </li>
    <ul>
      <li>
        HTTP(클라이언트-서버 프로토콜 사용)
      </li>
      <li>
        상태 비저장(각 연결이 독립적)
      </li>
      <li>
        캐시 기능
      </li>
      <li>
        리소스 기반
      </li>
    </ul>
  <li>
    <strong>리소스(resource)</strong>란 식별하고 작업할 수 있는 <strong>데이터</strong>를 의미한다.
  </li>
  <li>
    웹 서비스는 노출하고자하는 각 기능에 대해 고유한 URL과 HTTP 동사(동작)인 <strong>엔드포인트(endpoint)</strong>를 제공한다.
  </li>
    <ul>
      <li>
        <strong>엔드포인트</strong>는 URL을 기능으로 라우팅해 <strong>라우트(route)</strong>라고도 한다.
      </li>
        <ul>
          <li>
            라우트란 요청된 URL을 어떤 기능(함수나 컨트롤러)에 연결해주는 <strong>경로 규칙</strong>을 의미한다.
          </li>
        </ul>
    </ul>
  <li>
    HTTP의 동사는 DB의 CRUD와 흡사하다.
  </li>
    <ul>
      <li>
        <strong>POST</strong>: 만들기(쓰기)
      </li>
      <li>
        <strong>PUT</strong>: 전체 수정(갈아 끼우기)
      </li>
      <li>
        <strong>PATCH</strong>: 부분 수정(고치기)
      </li>
      <li>
        <strong>GET</strong>: 가져오기(읽기, 찾기)
      </li>
      <li>
        <strong>DELETE</strong>: 삭제
      </li>
    </ul>
  <li>
    클라이언트는 HTTP 메시지와 다음의 데이터를 조합하여 RESTful 엔드포인트로 요청을 보낸다.
  </li>
    <ul>
      <li>
        헤더
      </li>
      <li>
        URL 문자열
      </li>
      <li>
        쿼리 매개변수
      </li>
      <li>
        본문 값
      </li>
    </ul>
  <li>
    HTTP의 응답은 다음과 같다.
  </li>
    <ul>
      <li>
        <strong>100번대</strong>: 정보, 계속 진행
      </li>
      <li>
        <strong>200번대</strong>: 성공
      </li>
      <li>
        <strong>300번대</strong>: 리디렉션
      </li>
      <li>
        <strong>400번대</strong>: 클라이언트 오류
      </li>
      <li>
        <strong>500번대</strong>: 서버 오류
      </li>
    </ul>
</ul>

<br>

<h2>1-4. JSON 및 API 데이터 형식</h2>
<ul>
  <li>
    프런트와 백은 일반 ASCII 텍스트를 교환할 수 있다. 
  </li>
  <li>
    리스트와 같은 데이터의 구조는 <strong>JSON(JavaScript Object Notation)</strong>을 활용하여 전달한다.
  </li>
  <li>
    JSON은 XML 혹은 SOAP과 같은 이전의 데이터 표현 방식을 대부분 대체했다.
  </li>
</ul>

<br>

<h2>1-5. JSON:API</h2>
<ul>
  <li>
    중대한 논란이 될 작업 같은 경우 JSON:API를 좀 더 엄격하게 지키는 것을 권장한다.
  </li>
</ul>

<br>

<h2>1-6. GraphQL</h2>
<ul>
  <li>
    특정 용도에서 RESTful이 사용하기 번거로울 때 사용하기 위해 Meta에서 보다 유연한 서비스 쿼리를 지정하기 위해 만든 GraphQL을 사용해 볼 수 있다.
  </li>
</ul>

<br><br>

<h1>2. 동시성</h1>
<ul>
  <li>
    서비스가 성장하고 연결량이 빠르게 증가할 때 <strong>효율성</strong>과 <strong>확장성</strong>이 중요한데 이를 위해서는 다음 두 가지 항목을 줄여야 한다.
  </li>
    <ul>
      <li>
        <strong>지연 시간(latency)</strong>: 사전 대기 시간
      </li>
      <li>
        <strong>처리량(throughput)</strong>: 서비스와 호출자 간의 초당 바이트 수
      </li>
    </ul>
  <li>
    CPU는 빠르지만 I/O(디스크, 네트워크 등)는 느리다. 따라서 CPU는 I/O 대기 시간 동안 다른 일을 처리하는데 이런 <strong>교대 실행</strong>이 병렬처럼 보이는 것이 <strong>동시성(concurrency)</strong>이다.
  </li>
  <li>
    파이썬은 일반적으로 순차적으로 하나씩 수행하는 동기식(synchronous)이다.
  </li>
    <ul>
      <li>
        모든 코드가 CPU를 사용해 계산(CPU bound)되는 경우 비동기를 사용할 여유가 없지만 <strong>외부 작업이 완료될 때까지</strong> 기다려야 하는 작업을 CPU가 수행(I/O 바운드)한다면 <strong>비동기</strong>가 될 수 있다.
      </li>
      <li>
        비동기식 시스템은 <strong>이벤트 루프(event loop)</strong>를 통해 느린 작업(I/O)를 관리한다. 이벤트 루프는 작업을 시작하고 <strong>결과를 기다리지 않고 다른 일을 처리</strong>한다. 이후 작업이 완료되면 해당 이벤트를 받아서 <strong>후속 처리</strong>한다.
      </li>
      <li>
        단, 이벤트 루프에서 <strong>CPU 집약적인 작업</strong>을 너무 많이 수행하지 않도록 주의해야 한다. (그렇지 않으면 모든 작업 속도가 저하된다).
      </li>
    </ul>
</ul>

<br><br>

<h1>3. 계층</h1>
<ul>
  <li>
    애플리케이션은 크기와 복잡성을 관리하기 위해 소위 <strong>3 계층 모델(three-tier-model)</strong>을 많이 사용했다. 
  </li>
  <li>
    계층은 <strong>웹 클라이언트 ↔ [웹, 서비스, 데이터] ↔ [모델, 데이터베이스]</strong>로 구성된다.
  </li>
    <ul>
      <li>
        <strong>웹</strong>: 클라이언트의 요청을 수집하고, 서비스 계층을 호출해 응답을 반환하는 <strong>HTTP를 통한 I/O 계층</strong>
      </li>
      <li>
        <strong>서비스</strong>: 필요할 때 <strong>데이터 계층을 호출</strong>하는 비즈니스 로직
      </li>
      <li>
        <strong>데이터</strong>: 데이터 저장소 및 기타 서비스에 <strong>접근</strong>
      </li>
      <li>
        <strong>모델</strong>: 모든 계층이 공유하는 <strong>데이터 정의</strong>
      </li>
      <li>
        <strong>웹 클라이언트</strong>: 웹 브라우저 또는 기타 HTTP 클라이언트 측 소프트웨어
      </li>
      <li>
        <strong>데이터베이스</strong>: 데이터 저장소
      </li>
    </ul>
  <li>
    각 계층은 API로 통신한다.
  </li>
  <li>
    웹 계층은 클라이언트 애플리케이션과 API를 통해 <strong>사용자에게 표시</strong>된다.
  </li>
  <li>
    서비스 계층은 웹사이트가 제공하는 모든 것의 <strong>실제 세부 정보</strong>가 담긴다.
  </li>
  <li>
    데이터 계층은 <strong>데이터의 접근</strong>을 서비스 계층에 제공한다.
  </li>
  <li>
    모델 계층은 실제 계층이 아니라 <strong>계층끼리 공유하는 데이터 정의의 소스</strong>이다.
  </li>
  <li>
    계층에는 다음과 같은 특성들이 있다.
  </li>
    <ul>
      <li>
        각 계층의 전문가가 작성한다.
      </li>
      <li>
        테스트 격리성을 지닌다.
      </li>
      <li>
        대체 및 보완 가능: 웹 계층과 함계 gRPC 같은 API를 사용해 또 다른 웹 계층을 추가할 수 있다.
      </li>
    </ul>
  <li>
    계층을 분리하는 이유는 대표적으로 다음과 같다.
  </li>
    <ul>
      <li>
        계층을 분리하지 않을 경우 문제가 늘어날 수 있다.
      </li>
      <li>
        계층을 나중에 분리하는 것은 어렵다.
      </li>
      <li>
        코드 로직이 얽힌다면 두 계층 이상의 전문 지식이 필요해진다.
      </li>
    </ul>
  <li>
    각 계층은 수직적인 의미를 갖지 않는 <strong>수평 계층</strong>이다.
  </li>
  <li>
    각 계층의 권장 데이터 형식을 화살표로 표현하면 다음과 같다.
  </li>
    <ul>
      <li>
        <strong>웹 클라이언트 ↔ 웹</strong>: JSON을 사용한 RESTful HTTP
      </li>
      <li>
        <strong>웹 ↔ 서비스</strong>: 모델
      </li>
      <li>
        <strong>서비스 ↔ 데이터</strong>: 모델
      </li>
      <li>
        <strong>데이터 ↔ DB 및 서비스</strong>: 특정 API
      </li>
    </ul>
</ul>

<br><br>

<h1>4. 데이터</h1>
<ul>
  <li>
    각종 데이터베이스와 ETL에 대한 설명...
  </li>
</ul>

<br><br>

<h1>5. 정리</h1>
<ul>
  <li>
    웹 기술에는 여러 API가 있지만 특히 RESTful을 많이 사용한다.
  </li>
  <li>
    <strong>비동기 호출</strong>을 통해 <strong>동시성</strong>을 확보하여 <strong>전체 프로세스의 속도</strong>가 빨라진다.
  </li>
  <li>
    웹 서비스 앱은 <strong>여러 계층</strong>으로 나눌 만큼 큰 경우가 많다.
  </li>
</ul>