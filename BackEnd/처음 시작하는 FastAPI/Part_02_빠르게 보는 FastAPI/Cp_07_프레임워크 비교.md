<ul>
  <li>
    Flask나 Django에서 FastAPI로 앱을 마이그레이션ㄴ할 계획이 있거나 마이그레이션이 궁금할 때 유용한 내용들이다.
  </li>
</ul>

<br>

<h1>Flask</h1>
<ul>
  <li>
    Flask는 마이크로프레임워크라 자처하며 기본 뼈대를 제공하고 <strong>필요에 따라 서드파티 패키지를 다운 받아 보완</strong>한다.
  </li>
  <li>
    Django 보다는 덩치가 작으며 빠르게 배울 수 있다.
  </li>
  <li>
    ASGI가 아닌 WSGI 기반으로하는 <strong>동기식 프레임워크</strong>이다.
  </li>
</ul>

<br>

<h1>1-1. 경로</h1>
<ul>
  <li>
    Flask와 FastAPI는 모두 최상위 수준에서 <strong>데코레이터</strong>를 사용해 <strong>경로를 웹 엔드포인트와 연결</strong>한다.
  </li>
</ul>

```python
# 1. FastAPI와 Flask의 경로

# FastAPI=================
from fastapi import FastAPI

app = FastAPI()

@app.get("/hi/{who}")
def greet(who: str):
    return f"Hello? {who}?"

# Flast===================
#   - 데코레이터의 who가 <>로 둘러싸인다.
#   - 메서드는 기본값인 GET이 아니라면 인자로 포함해야 한다.
#     - 기본값이기에 생략도 가능하지만 명시해서 나쁠 것도 없다.
#   - jsonify는 인수를 JSON 문자열로 변환해 반환한다.
#     - 딕셔너리를 포함한 모든 데이터 유형에 대해 명시적으로 작동한다.
from flask import Flask, jsonify

app = Flast(__name__)

@app.route("/hi/<who>", methods=["GET"])
def greet(who: str):
    return jsonify(f"Hello? {who}?")
```

<br>

<h2>1-2. 쿼리 매개변수</h2>

```python
# 1. FastAPI의 쿼리 매개변수
#   - 쿼리 매개변수를 전달할 때 '?' 뒤에 전달한다.
from fastapi import FastAPI

app = FastAPI()

@app.get("/hi")
def greet(who):
    return f"Hello? {who}?"
```

```python
# 2. Flask
#   - Flask는 request 객체에서 요청 값을 가져온다.
#   - args는 쿼리 매개변수가 포함된 딕셔너리를 생성한다.
from flask import Flask, request, jsonify

app = Flask(__name__)

@app.route("/hi", methods=["GET"])
def greet():
    who: str = request.args.get("who")
    return jsonify(f"Hello? {who}?")
```

<br>

<h2>1-3. 본문</h2>

```python
# 1. FastAPI 본문
from fastapi import FastAPI, Body

app = FastAPI()

@app.post("/hi")
def greet(who: str = Body(embed=True)):
    retrun f"Hello? {who}?"
```

```python
# 2. Flask 본문
#   - Flask는 JSON 입력을 request.json에 저장한다.
from flask import Flask, request, jsonify

app = Flask(__name__)

@app.route("/hi", methods=["POST"])
def greet():
    who: str = request.json["who"]
    return jsonify(f"Hello? {who}?")
```

<br>

<h2>1-4. 헤더</h2>

```python
# 1. FastAPI 헤더
from fastapi import FastAPI, Header

app = FastAPI()

@app.get("/hi")
def greet(who: str = Header()):
    return f"Hello? {who}?"
```

```python
# 2. Flask 헤더
#   - 마찬가지로 request 객체에 요청 데이터를 보관한다.
from flask import Flask, request, jsonify

app = Flask(__name__)

@app.route("/hi", methods=["GET"])
def greet():
    who: str = request.headers.get("who")
    return jsonify(f"Hello? {who}?")
```

<br><br>

<h1>2. Django</h1>
<ul>  
  <li>
    Django의 홈페이지를 따르면 Flask나 FastAPI 보다 더 <strong>크고 복잡</strong>하며 <strong>마감 기한이 있는 완벽주의자</strong>를 타깃으로 한다고 되어 있다.
  </li>
  <li>
    <strong>내장된 객체 관계형 매퍼(object-relational mapper, ORM)</strong>는 <strong>주요 데이터베이스를 백엔드</strong>로 사용하는 웹사이트에 유용하다.
  </li>
  <li>
    전통적인 WSGI 앱이었으나 <strong>버전 3.0에서 ASGI</strong>에 대한 지원이 추가 되었다.
  </li>
  <li>
    데코레이터를 갖지 않고 <strong>단일 URLConf 테이블</strong>에서 경로를 정의하는 것을 선호한다. <strong>모든 경로를 한 곳</strong>에서 볼 수 있다는 장점이 있지만 함수만 볼 때에는 <strong>어떤 URL이 함수와 연결됐는지 확인하기 어려워진다</strong>.
  </li>
</ul>

<br><br>

<h1>3. 기타 웹 프레임워크 기능</h1>
<ul>
  <li>
    웹 프레임워크는 다음 영역에도 도움이 된다.
  </li>
    <ul>
      <li>
        <strong>양식</strong>: 세 가지 패키지 모두 표준 HTML 양식을 지원한다.
      </li>
      <li>
        <strong>파일</strong>: 모든 패키지가 멀티파트 HTTP 요청 및 응답을 포함한 파일 업로드와 다운로드를 처리한다.
      </li>
      <li>
        <strong>템플릿</strong>: 텍스트와 코드를 혼합할 수 있으며 콘텐츠 중심 웹 사이트에 유용하다.
      </li>
    </ul>
  <li>
    기본 HTTP 이외의 네트워킹 방법을 사용하려면 다음을 시도해 볼 수 있다.
  </li>
    <ul>
      <li>
        <strong>서버에서 보낸 이벤트</strong>: 필요에 따라 클라이언트에 데이터를 푸시한다. FastAPI는 <strong>sse-startlette</strong>을 사용한다.
      </li>
      <li>
        <strong>큐</strong>: 작업 큐, 게시-구독, 기타 네트워킹 패턴은 제로 MQ, 셀러리, 레디스 등 외부 패키지에서 지원된다.
      </li>
      <li>
        <strong>웹 소켓</strong>: FastAPI는 웹 소켓에 대해 <strong>직접 제공</strong>한다.
      </li>
    </ul>
</ul>

<br><br>

<h1>4. 데이터베이스</h1>
<ul>
  <li>
    DB 처리는 Flask와 FastAPI는 기본 패키지에 포함되지 않지만 Django에서는 핵심 기능이다.
  </li>
  <li>
    웹 프레임워크의 데이터 계층은 다양한 DB에 접근할 수 있다.
  </li>
  <li>
    FastAPI와 Flask에서 많이 선택하는 패키지는 <strong>SQLAlchemy</strong>로 SQL부터 ORM까지 접근 수준이 다양한 패키지를 사용한다.
  </li>
  <li>
    대량의 DB를 사용하는 경우 ROM과 자동화된 DB 관리자 페이지를 지원하는 Django를 사용할 것을 권한다.
  </li>
</ul>