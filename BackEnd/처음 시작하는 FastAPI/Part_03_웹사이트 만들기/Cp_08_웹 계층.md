<ul>
  <li>
    <strong>인터페이스(interface)</strong> 또는 <strong>라우터(router) 계층</strong>이라고도 할 수 있는 FastAPI 앱의 <strong>최상위 계층</strong>에 대해 알아본다.
  </li>
  <li>
    서비스 계층과 데이터 계층과의 통합에 대해 자세히 알아본다.
  </li>
  <li>
    코드를 적게 작성할수록 나중에 기억하거나 수정할 일이 줄어든다.
  </li>
  <li>
    검색, 생성, 수정, 교체, 삭제 기능을 구현하며 더미 데이터를 제공한다.
  </li>
</ul>

<br>

<h1>1. 쉬는 시간: 상향식, 하향식, 양방향?</h1>
<ul>
  <li>
    웹 사이트를 구축할 때 다음과 같은 방식으로 작업을 진행할 수 있다.
  </li>
    <ul>
      <li>
        <strong>웹 계층</strong>에서 시작하는 <strong>하향식 작업</strong>
      </li>
      <li>
        <strong>데이터 계층</strong>에서 시작하는 <strong>상향식 작업</strong>
      </li>
      <li>
        <strong>서비스 계층</strong>에서 시작하는 <strong>양방향 작업</strong>
      </li>
    </ul>
  <li>
    아키텍처를 어떻게 구성하는가에 따라 개발 순서와 진행 방향이 달라진다. 이와 관련해서는 다양한 아키텍쳐 패턴을 참고할 수 있다.
  </li>
    <ul>
      <li>
        파이썬에 적용하는 클린 아키텍처 (https://bit.ly/49DM9qY)
      </li>
      <li>
        파이썬으로 살펴보는 아키텍처 패턴 (https://bit.ly/3Tkk4ze)
      </li>
      <li>
        마이크로 서비스 API (https://oreil.ly/Gk0z2)
      </li>
    </ul>
  <li>
    웹 계층은 유저와 서비스 간에 데이터를 전달하는 방법 중 하나일 뿐이며 CLI 또는 소프트웨어 개발 키트(SDK) 등을 사용할 수도 있다.
  </li>
    <ul>
      <li>
        웹 계층은 다른 프레임워크에서 <strong>뷰(view)</strong> 또는 <strong>프레젠테이션(presentation) 계층</strong>이라 한다.
      </li>
    </ul>
</ul>

<br><br>

<h1>2. RESTful API 설계</h1>
<ul>
  <li>
    HTTP는 <strong>웹 클라이언트와 서버 간에 명령과 데이터를 주고받는 방법</strong>이며 RESTful은 방법들 중 하나이다.
  </li>
  <li>
    RESTful의 설계는 다음 요소로 구성된다.
  </li>
    <ul>
      <li>
        <strong>리소스</strong>: 앱에서 관리하는 데이터 요소
      </li>
      <li>
        <strong>ID</strong>: 고유 리소스 식별자
      </li>
      <li>
        <strong>URL</strong>: 구조화된 리소스와 ID로 이루어진 문자열
      </li>
      <li>
        <strong>동작</strong>: URL과 함께 등장하는 용어로, 다음과 같이 사용한다.
      </li>
        <ul>
          <li>
            <strong>GET</strong>: 리소스를 검색한다.
          </li>
          <li>
            <strong>POST</strong>: 새 리소스를 만든다.
          </li>
          <li>
            <strong>PUT</strong>: 리소스를 전체적으로 교체한다.
          </li>
          <li>
            <strong>PATCH</strong>: 리소스를 부분적으로 교체한다.
          </li>
          <li>
            <strong>DELETE</strong>: 리소스를 폭파한다.
          </li>
        </ul>
    </ul>
  <li>
    <strong>resource와 ID가 포함된 URL</strong>과 <strong>동사를 결합</strong>하는 일반적인 RESTful 규칙은 <strong>경로 매개변수(URL의 / 사이의 내용)의 패턴</strong>을 사용한다.
  </li>
    <ul>
      <li>
        <strong><동작> /resource/</strong>: resource 유형의 <strong>모든 리소스</strong>에 <동작>을 적용한다.
      </li>
      <li>
        <strong><동작> /resource/id</strong>: <strong>id가 있는 resource</strong>에 <동작>을 적용한다.
      </li>
    </ul>
  <li>
    웹 요청은 종종 더 많은 정보를 전달해 다음과 같은 사항을 수행하도록 지시한다.
  </li>
    <ul>
      <li>
        결과 정렬
      </li>
      <li>
        결과 페이지 매기기(페이징)
      </li>
      <li>
        또 다른 기능 수행
      </li>
    </ul>
  <li>
    매개변수들은 <strong>경로 매개변수(/)</strong>로 전달되기도 하고 <strong>쿼리 매개변수(?)</strong>로 전달되기도 한다. 단, URL은 <strong>길이 제한</strong>이 있기 때문에 <strong>대용량 요청 데이터는 종종 HTTP 본문</strong>으로 전달된다.
  </li>
  <li>
    대부분 리소스 이름, API, DB 테이블 등의 네임스페이스는 명명을 할 때 <strong>복수</strong>를 사용하라 하지만 저자는 이 방식이 합리적이지 못하다 생각되어 도서에서는 <strong>단수형 명명 체계</strong>를 사용한다 한다.
  </li>
</ul>

<br><br>

<h1>3. 파일 및 디렉터리 구조</h1>
<ul>
  <li>
    나는 docker로 환경을 구축하고 /docs를 통해 API를 확인하면서 실습을 진행할 계획이다. (실습 폴더는 별도 첨부).
  </li>
  <li>
    단, 컨터이너를 백
  </li>
    <ul>
      <li>
        도서에서는 로컬 머신에서 테스트를 진행하며 직접 코드를 CLI로 수행하는 방식을 활용한다.
      </li>
    </ul>
  <li>
    디렉터리 구조에 대한 의견은 다양할 수 있다.
  </li>
  <li>
    <strong>__init__.py</strong>는 비어 있다. 일종의 파이썬 해킹(트릭 혹은 편법)으로, 해당 디렉터리를 <strong>가져올(import)</strong> 수 있는 <strong>파이썬 패키지로 취급</strong>한다.
  </li>
  <li>
    fake 디렉터리가 하위 계층을 빌드할 때 상위 계층에 일부 <strong>스텁 데이터(stub data)</strong>를 제공한다.
  </li>
  <li>
    파이썬은 디렉터리 구조 자체보다 <strong>__init__.py</strong>가 있는지를 기준으로 폴더를 패키지로 인식해 <strong>import</strong> 한다.
  </li>
  <li>
    <strong>.py 파일</strong>은 <strong>모듈</strong>이며 <strong>__init__.py</strong>가 있는 폴더는 <strong>패키지</strong>로 간주되어 <strong>sys.path에 등록된 순서</strong>에 따라 불러온다.
  </li>
  <li>
    같은 이름의 모듈이 로컬과 표준 라이브러리에 모두 있다면 파이썬은 <strong>sys.path의 우선순위</strong>에 따라 어떤 것을 import 할지 결정한다.
  </li>
  <li>
    요약하면 패키지와 모듈을 구분하며 sys에 등록된 경로에 따라 우선 순위를 두어 처리를 한다.
  </li>
</ul>

<br><br>

<h1>4. 첫 번째 웹사이트 코드</h1>

```python
# 1. main 프로그램```
from fastapi import FastAPI

# app은 모든 것을 하나로 묶는 FastAPI 객체이다.
app = FastAPI()

@app.get("/")
def top():
    return "top here"
```

```python
# 2. main.py에 엔드포인트 추가.
from fastapi import FastAPI

app = FastAPI()
@app.get("/")
def top():
    return "top here"

@app.get("/echo/{thing}")
def echo(thing):
    return f"echoing {thing}"
```

<br><br>

<h1>5. 요청</h1>
<ul>
  <li>
    HTTP 요청은 <strong>텍스트로 된 헤더</strong>와 <strong>하나 이상의 본문</strong>으로 구성된다.
  </li>
  <li>
    HTTP 데이터를 파이썬 구도로 변환하는 역할을 프레임워크가 대신 처리하는데 이때 유용한 기능이 <strong>FastAPI의 의존성 주입</strong>이다.
  </li>
    <ul>
      <li>
        <strong>Header</strong>: HTTP 헤더에서 가져온다.
      </li>
      <li>
        <strong>Path</strong>: URL에서 가져온다.
      </li>
      <li>
        <strong>Query</strong>: URL의 ? 뒤에서 가져온다.
      </li>
      <li>
        <strong>Body</strong>: HTTP 본문에서 가져온다.
      </li>
    </ul>
  <li>
    <strong>환경 변수</strong>와 <strong>구성 설정</strong>은 간접적으로 가져오는 데이터이다.
  </li>
</ul>

<br><br>

<h1>6. 다중 라우터</h1>
<ul>
  <li>
    모든 경로를 처리하는 코드를 하나의 파일에 넣을 수도 있지만 <strong>여러 개의 하위 라우터</strong>를 사용하는 것이 더 편리할 때가 많다.
  </li>
</ul>

```python
# 1. web/explorer.py - APIRouter
from fastapi import FastAPI

router = APIRouter(prefix="/explorer")

@ router.get("/")
def top():
    return "top explorer endpoint"
```

```python
# 2. main에 하위 라우터 연결
from fastapi import FastAPI
from .web import explorer

app = FastAPI()

app.include_router(explorer.router)
```

<br><br>

<h1>7. 웹 계층 구축</h1>
<ul>
  <li>
    웹 계층에 <strong>실제 핵심 함수를 추가</strong>한다. 처음에는 웹 함수에서 사용하는 모든 데이터를 <strong>가짜</strong>로 만든다.
  </li>
</ul>

<br><br>

<h1>8. 데이터 모델 정의</h1>

```python
# 1. 탐험가 모델 정의 (model/explorer.py)
#   - 계층 간에 전달할 기본적인 데이터를 정의한다.
#   - 이후에 데이터가 추가될 수 있지만 현재는 기본 스키마로 구성한다.
from pydantic import BaseModel

class Explorer(BaseModel):
    name: str
    country: str
    description: str = ""
```

```python
# 2. 생명체 모델 정의 (model/creature.py)
#   - 마찬가지로 계층 간에 전달할 기본적인 데이터를 정의한다.
from pydantic import BaseModel

class Explorer(BaseModel):
    name: str
    country: str
    area: str
    description: str
    aka: str
```

<br><br>

<h1>스텁과 가짜 데이터</h1>
<ul>
  <li>
    모의(mock) 데이터라고도 불리는 <strong>스텁(stub)</strong>은 동작 중인 모듈을 호출하지 않고 반환되는 <strong>미리 준비된 응답</strong>을 의미한다.
  </li>
</ul>

<br><br>

<h1>10. 단계별로 구현하는 공통 기능</h1>
<ul>
  <li>
    실습은 데이터 정의부터 탐색적으로 진행된다. 종종 최종적으로 무엇이 필요한지 불명확한 경우가 있기에 <strong>공통으로 적용할 몇 가지 사항</strong>부터 시작한다.
  </li>
  <li>
    프런트엔드의 일반적인 모습 (CRUD)
  </li>
    <ul>
      <li>
        일부 또는 전체 조회 (R)
      </li>
      <li>
        생성 (C)
      </li>
      <li>
        전체 교체 (U)
      </li> 
      <li>
        부분 수정 (U)
      </li>
      <li>
        삭제 (D)
      </li>
    </ul>
  <li>
    U 부분을 부분 업데이트와 전체 업데이트로 나누었다. 이런 부분은 개발 중인 서비스의 구조에 따라 달라진다.
  </li>
</ul>

<br><br>

<h1>11. 가짜 데이터 생성</h1>
<ul>
  <li>
    하향식으로 개발을 진행하면 세 계층 모두에서 몇몇 함수를 복제하게 된다. 따라서 최상위 fake 디렉터리를 만들고 가짜 데이터를 제공하는 모듈을 만든다.
  </li>
</ul>

```python
# 1. 탐험가 가짜 데이터를 제공하는 모듈 (fake/explorer.py)
from model.explorer import Explorer

# 가짜 데이터. 10장에서 실제 데이터베이스와 SQL로 바꾼다.
_explorers = [
    Explorer(name="Claude Hande",
            country="FR",
            description="보통달이 뜨면 만나기 힒듬."),
    Explorer(name="Noah Weiser",
            country="DE",
            description="눈이 나쁘고 벌목도를 가지고 다님."),
]

def get_all() -> list[Explorer]:
    """탐험가 목록을 반환한다."""
    return _explorers

def get_one(name: str) -> Explorer:
    """검색한 탐험가를 반환한다."""
    for _explorer in _explorers:
        if _explorer.name == name:
            return _explorer
    return None

# 다음 함수는 현재 올바로 작동하지 않는다.
# 실제로는 _explorers 목록을 수정하지 않지만,
# 마치 작동하는 것처럼 동작한다.
def create(explorer: Explorer) -> Explorer:
    """탐험가를 추가한다."""
    return explorer

def modify(name: str, explorer: Explorer) -> Explorer:
    """탐험가의 정보를 일부 수정한다."""
    return explorer

def replace(name: str, explorer: Explorer) -> Explorer:
    """탐험가를 완전히 교체한다."""
    return explorer

def delete(name: str) -> bool:
    """탐험가를 삭제한다. 만약 대상이 없담녀 False를 반환한다."""
    for _explorer in _explorers:
        if _explorer.name == name:
            return True
    return False
```

```python
# 2. 생명체 가짜 데이터를 제공하는 모듈 (fake/creature.py)
from model.creature import Creature

# 데이터베이스와 SQL로 바꿀 때까지 사용할 가짜 데이터
_creatures = [
    Creature(name="Yeti",
            aka="Abominable Snowman",
            country="CN",
            area="Himalayas",
            description="Hirsute Himalayan"),
    
    Creature(name="Bigfoot",
            description="Yeti's Cousin Eddie",
            country="US",
            area="*",
            aka="Sasquatch"),
]

def get_all() -> list[Creature]:
    """생명체 목록을 반환한다."""
    return _creatures

def get_one(name: str) -> Creature | None:
    """검색한 생명체를 반환한다."""
    for _creature in _creatures:
        if _creature.name == name:
            return _creature
    return None

# 다음 함수는 현재 올바로 동작하지 않는다.
# 실제로는 _creatures 목록을 수정하지 않지만,
# 마치 작동하는 것처럼 동작한다.
def create(creature: Creature) -> Creature:
    """생명체를 추가한다."""
    return creature

def modify(name: str, creature: Creature) -> Creature:
    """생명체 정보를 일부 수정한다."""
    return creature

def replace(name: str, creature: Creature) -> Creature:
    """생명체를 완전히 교체한다."""
    return creature

def delete(name: str) -> bool:
    """생명체를 삭제한다. 만약 대상이 없다면 False를 반환한다."""
    for _creature in _creatures:
        if _creature.name == name:
            return True
    return False
```

```python
# 3. 탐험가 새로운 엔드포인트 추가 (web/explorer.py)
from fastapi import APIRouter
from ..model.explorer import Explorer
from ..fake import explorer as service

router = APIRouter(prefix="/explorer")

@router.get("/")
def get_all() -> list[Explorer]:
    return service.get_all()

@router.get("/{name}")
def get_one(name) -> Explorer | None:
    return service.get_one(name)

# 나머지 엔드포인트. 현재는 아무 일도 하지 않는다.
@router.post("/")
def create(explorer: Explorer) -> Explorer:
    return service.create(explorer)

@router.patch("/{name}")
def modify(name, explorer: Explorer) -> Explorer:
    return service.modify(name, explorer)

@router.put("/{name}")
def replace(name, explorer: Explorer) -> Explorer:
    return service.replace(name, explorer)

@router.delete("/{name}")
def delete(name: str):
    return None
```

```python
# 4. 생명체 새로운 엔드포인트 추가 (web/creature.py)
from fastapi import APIRouter
from model.creature import Creature
import fake.creature as service

router = APIRouter(prefix = "/creature")

@router.get("/")
def get_all() -> list[Creature]:
    return service.get_all()

@router.get("/{name}")
def get_one(name) -> Creature:
    return service.get_one(name)

# 나머지 엔드포인트. 현재는 아무 일도 하지 않는다.
@router.post("/")
def create(creature: Creature) -> Creature:
    return service.create(creature)

@router.patch("/{name}")
def modify(name, creature: Creature) -> Creature:
    return service.modify(name, creature)

@router.put("/{name}")
def replace(name, creature: Creature) -> Creature:
    return service.replace(name, creature)

@router.delete("/{name}")
def delete(name: str):
    return service.delete(name)
```

```python
# 5. 마지막으로 main.py를 수정한다.
from fastapi import FastAPI
from web import creature, explorer

app = FastAPI()

app.include_router(explorer.router)
app.include_router(creature.router)
```

<br><br>

<h1>12. 테스트!</h1>
<ul>
  <li>
    도서에서는 명령어로 테스트를 수행하지만 나의 경우 docs를 활용한다.
  </li>
  <li>
    수정이 필요한 코드들이 몇 있어 수정을 완료하면 도서와 동일한 결과를 얻을 수 있다.
  </li>
</ul>

<br><br>

<h1>13. FastAPI가 자동 생성한 테스트 양식</h1>
<ul>
  <li>
    docs를 활용해 web UI로 실습을 진행하는데 나의 경우 이미 12번에서 활용했다.
  </li>
</ul>

<br><br>

<h1>14. 서비스 게층과 데이터 계층의 대화</h1>
<ul>
  <li>
    웹 계층의 함수는 데이터 계층에서 관리하는 데이터가 필요할 때마다 <strong>서비스 계층이 중개</strong>해 줄 것을 요청한다.
  </li>
  <li>
    서비스 개층이 중개를 하는 것이 더 많은 코드가 필요하여 비효율적이라 생각될 수 있지만 다음과 같은 장점이 있다.
  </li>
    <ul>
      <li>
        웹 계층은 웹을 다루고 데이터 계층은 데이터 저장소와 서비스를 다루기에 <strong>각각의 세부 정보를 완전히 분리</strong>하는 것이 안전하다.
      </li>
      <li>
        계층을 <strong>독립적으로 테스트</strong>할 수 있다.
      </li>
    </ul>
  <li>
    사이트 규모가 작아 중개자의 역할이 필요 없다면 서비스 계층은 건너 뛰어도 된다.
  </li>
</ul>

<br><br>

<h1>15. 페이징과 정렬</h1>
<ul>
  <li>
    API의 엔드포인트(URL)로 요청을 보낼 때 단 <strong>하나의 항목</strong>, <strong>여러 항목</strong>, <strong>모든 항목</strong> 등 다양한 요청을 보낼 수 있다.
  </li>
  <li>
    여러 resource를 조회할 때에는 다음과 같이 특정 순서에 맞추어 결과를 볼 수 있는 방법들이 있다.
  </li>
    <ul>
      <li>
        <strong>정렬</strong>: 한 번에 한 묶음만 돌려받더라도 <strong>모든 결과가 정렬</strong>된다.
      </li>
      <li>
        <strong>페이징</strong>: <strong>정렬을 유지</strong>하면서 한 번에 <strong>일부 결과만 반환</strong>한다.
      </li>
    </ul>
  <li>
    전렬 및 페이징 예시
  </li>
    <ul>
      <li>
        <strong>정렬</strong>(GET /explorer?<strong>sort=country</strong>): 국가 코드별 정렬된 탐험가
      </li>
      <li>
        <strong>페이징</strong>(GET /explorer?<strong>offset=10&size=10</strong>): 전체 목록에서 10번부터 19번까지에 있는 탐험가를 조회한다.
      </li>
      <li>
        <strong>정렬 & 페이징</strong>(GET /explorer?<strong>sort=country&offset=10&size=10</strong>)
      </li>
    </ul>
  <li>
    정렬 및 페이징을 쿼리 매개변수로 지정할 수도 있지만 FastAPI의 <strong>의존성 주입</strong>이 도움이 된다.
  </li>
    <ul>
      <li>
        정렬 및 페이징 매개변수를 <strong>Pydantic 모델</strong>로 정의한다.
      </li>
      <li>
        <strong>get_all() 경로 함수</strong>의 인자로 <strong>Depends 기능</strong>을 이용해 매개변수 모델을 전달한다.
      </li>
    </ul>
  <li>
    단, 정렬과 페이징은 <strong>DB</strong>에서 이루어지는 것이 좋다. DB 자체가 이런 작업에 능숙하기 때문이다.
  </li>
</ul>