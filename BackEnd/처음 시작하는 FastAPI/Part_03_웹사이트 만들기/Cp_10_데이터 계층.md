<h1>1. DB-API</h1>
<ul>
  <li>
    파이썬에는 RDBMS 인터페이스에 대한 스펙을 구현한 DB-API가 기본으로 들어가 있다.
  </li>
  <li>
    DB-API 주요 기능은 다음과 같다.
  </li>
    <ul>
      <li>
        <strong>connect()</strong>: 함수로 DB에 대한 연결인 com 객체를 생성한다.
      </li>
      <li>
        <strong>cursor()</strong>: 함수로 커서로 생성한다.
      </li>
      <li>
        <strong>execute(stmt)</strong>: SQL 문자열(stmt)을 실행한다.
      </li>
        <ul>
          <li>
            <strong>execute(stmt)</strong>: 매개변수가 없는 경우
          </li>
          <li>
            <strong>execute(stmt, params)</strong>: params 매개변수가 <strong>단일 시퀀스(리스트나 튜플)</strong> 또는 <strong>딕셔너리 인경우</strong>
          </li>
          <li>
            <strong>executemany(stmt, params_seq)</strong>: params_seq 시퀀스에 <strong>매개변수 그룹이 여러 개</strong> 있는 경우
          </li>
        </ul>
    </ul>
  <li>
    매개변수 지정 스타일별 문장 및 매개변수 예시는 p162에 장표로 정리되어 있다.
  </li>
  <li>
    SQL의 <strong>INSERT, DELETE, UPDATE</strong> 문의 경우 execute() 함수에서 <strong>반환된 값</strong>으로 동작 결과를 알 수 있다. 그러나 <strong>SELECT</strong>의 경우 fetch 메서드로 반환된 행을 <strong>파이썬 튜플로 순회</strong>한다.
  </li>
</ul>

```python
# 1. named 스타일을 매개변수로 사용하는 경우
stmt = """select * from creature where
    name=:name or country=:country"""
params = {"name": "yeti", "country": "CN"}
curs.execute(stmt, params)
```

<br><br>

<h1>2. SQLite</h1>
<ul>
  <li>
    파이썬 표준 패키지에는 <strong>sqlite3 모듈</strong>이 있으며 이를 통해 SQLite 데이터베이스르 지원한다.
  </li>
    <ul>
      <li>
        SQLite는 별도의 DB <strong>서버가 없으며</strong> 모든 코드가 라이브러리에 있고 저장소가 <strong>단일 파일</strong>에 있다.
      </li>
    </ul>
</ul>

```python
# 1. sqlite3를 사용하여 데이터 저장소 구현 (data/creature.py)
import sqlite3
from model.creature import Creature

DB_NAME = "cryptid.db"
conn = sqlite3.connect(DB_NAME)
curs = conn.cursor()

def init():
    curs.execute("create table creature(name, description, country, area, aka)")

def row_to_model(row; tuple) -> Creature:
    name, description, country, area, aka = row
    return Creature(
        name=name,
        description=description,
        country=country,
        area=area,
        aka=aka,
    )

def model_to_dict(creature: Creature) -> dict:
    return creature.model_dump()

def get_one(name: str) -> Creature:
    qry = "select = from creature where name=:name"
    params = {"name": name}
    curs.execute(qry, params)
    row = curs.fetchone()
    return row_to_model(row)

def get_all(name: str) -> list[Creature]:
    qry = "select * from creature"
    curs.execute(qry)
    rows = list(curs.fetchall())
    return [row_to_model(row) for row in rows]

def create(creature: Creature):
    qry = """insert into creature values
        (:name, :description, :country, :area, :aka)"""
    params = model_to_dict(creature)
    curs.execute(qry, params)

def modify(creature: Creature):
    return creature

def replace(creature: Creature):
    return creature

def delete(creature: Creature):
    qry = "delete from creature where name = :name"
    params = {"name": creature.name}
    curs.execute(qry, params)
```

<br><br>

<h1>3. 레이아웃</h1>
<ul>
  <li>
    앞으로의 실습은 실제 SQLite에 저장된 데이터를 기반으로 진행된다.
  </li>
</ul>

<br><br>

<h1>4. 데이터베이스 초기화</h1>
<ul>
  <li>
    SQLite 모듈은 <strong>init() 함수</strong>를 호출하지 않기에 다른 함수가 사용할수 있는 SQLite의 <strong>conn 또는 curs가 존재하지 않는다</strong>.
  </li>
  <li>
    위의 문제들에 대해서는 다음의 해결책을 적용해 볼 수 있다.
  </li>
    <ul>
      <li>
        코드에 DB 정보를 <strong>하드 코딩</strong>한다.
      </li>
      <li>
        <strong>계층</strong>을 통해 정보를 전달한다. (단, 이는 계층 분리를 위반하는 것이며 서비스 계층이 데이터 계층의 내부를 알게된다).
      </li>
      <li>
        구성 파일 및 환경 변수로 <strong>외부 소스</strong>에서 정보를 전달한다.
      </li>
    </ul>
</ul>

```python
# 1. 환경 변수를 정의하여 DB를 초기화 한다. (data/init.py)
#   - init.py를 추가하여 초기화 코드를 추가한다.
"""SQLite 데이터베이스를 초기화한다."""
import os
from pathlib import Path
from sqlite3 import connect, Connection, Cursor

conn: Connection | None = None
curs: Cursor | None = None

def get_db(name: str | None = None, reset: bool = False):
    """SQLite 데이터베이스 파일에 연결한다."""
    global conn, curs
    if conn:
        if not reset:
            return
        conn = None
    if not name:
        name = os.getenv("CRYPTID_SQLITE_DB")
        top_dir = Path(__file__).resolve().parents[1]
        db_dir = top_dir / "db"
        db_dir.mkdir(exist_ok=True)
        db_name = "cryptid.db"
        db_path = str(db_dir / db_name)
        name = os.getenv("CRYPTID_SQLite_DB", db_path)
    conn = connect(name, check_same_thread=False)
    curs = conn.cursor()

get_db()
```

```python
# 2. 파이썬 모듈은 싱글톤으로 init.py의 초기화 코드는 처음 코드를 가져올 때 한 번만 수행된다.
#   → 현재 모듈을 대신 사용하도록 설정한다.
# (data/creature.py)
from .init import conn, curs
from model.creature import Creature

curs.execute("""create table if not exists creature(
                name text primary key,
                description text,
                country text,
                area text,
                aka text)""")

def row_to_model(row: tuple) -> Creature:
    (name, description, country, area, aka) = row
    return Creature(name, description, country, area, aka)

def model_to_dict(creature: Creature) -> dict:
    return creature.model_dump()

def get_one(name: str) -> Creature:
    qry = "select * from creature where name=:name"
    params = {"name": name}
    curs.execute(qry, params)
    return row_to_model(curs.fetchone())

def get_all() -> list[Creature]:
    qry = "select * from creature"
    curs.execute(qry)
    return [row_to_model(row) for in curs.fetchall()]

def create(creature: Creature) -> Creature:
    qry = "insert into creature values" \
        " (:name, :description, :country, :area, :aka)"
    params = model_to_dict(creature)
    curs.execute(qry, params)
    return get_one(creature.name)

def modify(creature: Creature) -> Creature:
    qry = """update creature
            set country=:country.
                name=:name,
                description=:description,
                area=:area,
                aka=:aka
            where name=:name_orig"""
    params = model_to_dict(creature)
    params["name_orig"] = creature.name
    _ = curs.execute(qry, params)
    return get_one(creature.name)

def delete(creature: Creature) -> bool:
    qry = "delete from creature where name - :name"
    params = {"name": creature.name}
    res = curs.execute(qry, params)
    return bool(res)
```

```python
# 2. DB 구성 추가 (data/explorer.py)
from .init import curs
from model.explorer import Explorer

curs.execute("""create table if not exists explorer(
            name text privary key,
            country text,
            description text)"""
            )

def row_to_model(row: tuple) -> Explorer:
    return Explorer(name=row[0], country=row[1], description=row[2])

def model_to_dict(explorer: Explorer) -> dict:
    return explorer.model_dump() if explorer else None

def get_one(name: str) -> Explorer:
    qry = "select * from explorer where name=:name"
    params = {"name": name}
    curs.execute(qry, params)
    return row_to_model(curs.fetchone())

def get_all() -> list[Explorer]:
    qry = "select * from explorer"
    curs.execute(qry)
    return [row_to_model(row) for row in curs.fetchall()]

def create(explorer: Explorer) -> Explorer:
    qry = """insert into explorer (name, country, description)
            values (:name, :country, :description)"""
    params = model_to_dict(explorer)
    _ = curs.execute(qry, params)
    return get_one(explorer.name)

def modify(name: str, explorer: Explorer) -> Explorer:
    qry = """update explorer
            set country=:country,
            name=:name,
            description=:description
            where name=:name_orig"""
    params = model_to_dict(explorer)
    params["name_orig"] = explorer.name
    _ = curs.execute(qry, params)
    explorer2 = get_one(explorer.name)
    return explorer2

def delete(explorer: Explorer) -> bool:
    qry = "delete from explorer where name = :name
    params = {"name": explorer.name}
    res = curs.execute(qry, params)
    return bool(res)
```

<br><br>

<h1>5. 서비스 계층 연결</h1>
<ul>
  <li>
    데이터 계층의 구현에 맞게 서비스 계층을 수정한다.
  </li>
</ul>

```python
# 1. service/explorer.py 수정
import data.explorer as data
```

```python
# 2. service/creature.py 수정
import data.creature as data
``` 

<br><br>

<h1>6. 테스트!</h1>
<ul>
  <li>
    test 디렉터리에 하위 디렉터리르 생성하고 테스트를 진행한다.
  </li>
    <ul>
      <li>
        <strong>unit</strong>: 특정 계층에만 해당하는 테스트
      </li>
      <li>
        <strong>full</strong>: 전 계층에 걸친 테스트
      </li>
    </ul>
  <li>
    도서에서 권장하는 테스트 흐름은 다음과 같다.
  </li>
    <il>
      코드를 처음 작성할 때, 몇 가지 수동 테스트를 수행한다.
      <br>→ 파이썬 구문 오류를 수정한 후, 단위 테스트를 수행한다.
      <br>→ 모든 계층에 걸쳐 전체 데이터 흐름을 확보한 후, 전체 테스트를 수행한다.
    </ul>
</ul>

<br>

<h2>6-1. 전체 테스트</h2>
<ul>
  <li>
    전체 테스트는 웹 엔드포인트를 호출한다. 즉, 서비스 계층에서 데이터 계층까지 내려 갔다가 다시 돌아온다.
  </li>
  <li>
    최하위 계층(데이터 계층)에서 오류를 잡아 최상위 계층(웹 계층)으로 전달하는 방법들에는 다음의 방법들이 있다.
  </li>
    <ul>
      <li>
        SQLite가 예외를 반환하면 <strong>웹 계층</strong>에서 이를 처리한다.
      </li>
        <ul>
          <li>
            이 방법은 두 계층이 <strong>혼합</strong>될 수 있기에 권장하지 않는다.
          </li>
        </ul>
      <li>
        서비스 및 데이터 계층의 모든 함수가 Explorer를 반환하던 것을 <strong>Explorer | None을 반환</strong>하도록 한다.
      </li>
        <ul>
          <li>
            None을 반환하는 경우 실패 이유를 확인하기 어렵다는 문제가 있다.
          </li>
        </ul>
      <li>
        문제의 세부 사항을 포함하는 <strong>Missing과 Duplicate 예외</strong>를 정의한다. 이 경우 웹 경로 함수가 예외를 잡을 때까지 데이터가 코드 변경없이 계층을 통해 전달된다.
      </li>
        <ul>
          <li>
            DB가 아닌 앱별로 적용이 되기에 <strong>무결성</strong>을 유지할 수 있어 도서에서 권장한다.
          </li>
        </ul>
    </ul>
</ul>

```python
# 1. 최상위 디렉터리에 생성한 error.py 파일
class Missing(Exception):
    def __init__(self, msg: str):
        self.msg = msg

class Duplicate(Exception):
    def __init__(self, msg: str):
        self.msg = msg
```

```python
# 2. 생성한 예외 클래스를 활용할 수 있게 data/explorer.py를 수정한다.
from init import (conn, curs, IntegrityError)
from model.explorer import Explorer
from error import Missing, Dupliate

curs.execute("""create table if not exists explorer(
                name text primary key,
                country text,
                description text)""")

def row_to_model(row: tuple) -> Explorer:
    name, country, description = row
    return Explorer(name=name,
        country=country, description=description)

def model_to_dict(explorer: Explorer) -> dict:
    return explorer.model_dump()
  
def get_one(name: str) -> Explorer:
    qry = "select * from explorer where name=:name"
    params = {"name": name}
    curs.execute(qry, params)
    row = curs.fetchone()
    if row:
        return row_to_model(row)
    else:
        raise Missing(msg=f"Explorer {name} not fount")

def get_all() -> list[Explorer]:
    qry = "select * from explorer"
    curs.execute(qry)
    return [row_to_model(row) for row in curs.fetchall()]
  
def create(explorer: Explorer) -> Explorer:
    if not explorer:
        return None
    qry = """insert into explorer (name, country, description)
            values (:name, :country, :description)"""
    params = model_to_dict(explorer)
    try:
        curs.execute(qry, params)
    except IntegrityError:
        raise Duplicate(msg=
            f"Explorer {explorer.name} already exists")
    return get_one(explorer.name)

def modify(name: str, explorer: Explorer) -> Explorer:
    if not (name and explorer):
        return None
    qry = """update explorer
            set name=:name,
            country=:country,
            description=:description,
            where name=:name_orig"""
    params = model_to_dict(explorer)
    params["name_orig"] = explorer.name
    curs.execute(qry, params)
    if curs.rowcount == 1:
        return get_one(explorer.name)
    else:
        raise Missing(msg=f"Explorer {name} not found")

def delete(name: str):
    if not name:
        return False
    qry = "delete from explorer where name = :name"
    params = {"name": name}
    curs.execute(qry, params)
    if curs.rowcount != 1:
        raise Missing(msg=f"Explorer {name} not found")
```

```python
# 3. 데이터 계층의 예외가 웹 계층에서 활용되도록 코드 수정.
from fastapi import APIRouter, HTTPExceptiokn
from model.explorer import Explorer
from service import explorer as service
from error import Duplicate, Missing

router = APIRouter(prefix = "/explorer")

@router.get("")
@router.get("/")
def get_all() -> list[Explorer]:
    return service.get_all()

@router.get("/{name}")
@router.get("/{name}/")
def get_one(name) -> Explorer:
    try:
        return service.get_one(name)
    except Missing as exc:
        raise HTTPException(status_code=404, detail=exc.msg)

@router.post("", status_code=201)
@router.post("/", status_code=201)
def create(explorer: Explorer) -> Explorer:
    try:
        return service.create(explorer)
    except Duplicate as exc:
        raise HTTPException(status_code=404, detail=exc.msg)

@router.patch("/{name}")
@router.patch("/{name}/")
def modify(name: str, explorer: Explorer) -> Explorer:
    try:
        return service.modifyt(name, explorer)
    except Missing as exc:
        raise HTTPException(status_code=404, detail=exc.msg)

@router.put("/{name}")
@router.put("/{name}/")
def replace(name: str, explorer: Explorer) -> Explorer:
    try: 
        return service.replace(id, explorer)
    except Missing as exc:
        raise HTTPException(status_code=404, detail=exc.msg)

@router.delete("/{name}", status_code=204)
@router.delete("/{name}/", status_code=204)
def delete(name: str):
    try:
        return service.delete(name)
    except Missing as exc:
        raise HTTPException(status_code=404, detail=exc.msg)
```

<br>

<h2>6-2. 단위 테스트</h2>
<ul>
  <li>
    data로부터 init 또는 creature를 가져오기 전에 환경 변수 CRYPTID_SQLITE_DATABASE를 ":memory"로 설정한다. 
  </li>
  <li>
    sample이라는 이름의 fixture는 Creature 객체가 필요한 함수에 전달한다.
  </li>
  <li>
    테스트가 순서대로 실행된다. 동일한 DB가 계속 유지되기 때문이다. pytest를 사용하면 다음과 같은 스코프를 설정할 수 있다.
  </li>
    <ul>
      <li>
        함수 스코프(기본값): 모든 테스트 함수를 수행하기 전에 새로운 것으로 호출한다.
      </li>
      <li>
        세션 스코프: 처음에 한 번만 호출된다.
      </li>
    </ul>
  <li>
    일부 테스크는 Missing 또는 Duplicate 예외를 강제로 일으키고 예외가 잘 잡히는지 확인한다.
  </li>
</ul>

```python
# 1. data/creature.py에 대한 단위 테스트(test/unit/data/test_creature.py)
import os
import pytest
from model.creature import Creature
from error import Missing, Duplicate

# 아래 줄에 있는 data.init에 메모리 DB를 사용하도록 data 모듈을 가져오기 전에 설정.
os.environ["CRYPTID_SQLITE_DB"] = ":memory"
# data 모듈이 중복돼 explorer를 찾지 못해 src를 명시.
from src.data import explorer

@pytest.fixture
def sample() -> Creature:
    return Creature(name="yeti", country="CN", area="Himalayas",
        description="Harmless Himalayan",
        aka="Abominable Snowman")

def test_create(sample):
    resp = creature.create(sample)
    assert resp == sample

def test_create_duplicate(sample):
    with pytest.raises(Duplicate):
        _ = creature.create(sample)

def test_get_one(sample):
    resp = creature.get_one(sample.name)
    assert resp == sample

def test_get_one_missing():
    with pytest.raises(Missing):
        _ = creature.get_one("boxturtle")

def test_modify(sample):
    creature.area = "Sesame Street"
    resp = creature.modify(sample.name, sample)
    assert resp == sample

def test_modify_missing():
    thing: Creature = Creature(name="snurfle", country="RU", area="",
        description="some thing", aka="")
    with pytest.raises(Missing):
        _ = creature.modify(thing.name, thing)

def test_delete(sample):
    resp = creature.delete(sample.name)
    assert resp is None

def test_delete_missing(sample):
    with pytest.raises(Missing):
        _ = creature.delete(sample.name)
```

```python
# 2. test/unit/data/test_explorer.py
import os
import pytest
from model.explorer import Explorer
from error import Missing, Duplicate

os.environ["CRYPTID_SQLITE_DB"] = ":memory"
from src.data import creature

@pytest.fixture
def sample() -> Explorer:
    return Explorer(name="yeti", country="CN", area="Himalayas",
        description="Harmless Himalayan",
        aka="Abominable Snowman")

def test_create(sample):
    resp = explorer.create(sample)
    assert resp == sample

def test_create_duplicate(sample):
    with pytest.raises(Duplicate):
        _ = explorer.create(sample)

def test_get_one(sample):
    resp = explorer.get_one(smaple.name)
    assert resp == sample

def test_get_one_missing():
    with pytest.raises(Missing):
        _ = explorer.get_one("boxturtle")

def test_modify(sample):
    explorer.area = "Sesame Street"
    resp = explorer.modify(sample.name, sample)
    assert resp == sample

def test_modify_missing():
    thing: Explorer = Explorer(name="snurfle", country="RU", area="",
        description="some thing", aka="")
    with pytest.raises(Missing):
        _ = explorer.modify(thing.name, thing)

def test_delete(sample):
    resp = explorer.delete(sample.name)
    assert resp is None

def test_delete_missing(sample):
    with pytest.raises(Missing):
        _ = explorere.delete(sample.name)
```