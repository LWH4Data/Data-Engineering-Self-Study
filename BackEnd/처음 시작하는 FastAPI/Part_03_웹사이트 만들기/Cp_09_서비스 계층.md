<h1>1. 서비스 정의</h1>
<ul>
  <li>
    서비스 계층은 다양한 소스로부터 <strong>요청을 받고</strong>, <strong>데이터에 접근</strong>하며 <strong>응답을 반환</strong>한다.
  </li>
  <li>
    일반적으로 서비스 패턴은 다음과 같이 조합된다.
  </li>
    <ul>
      <li>
        생성 / 검색 / 변경(부분 또는 전체) / 삭제
      </li>
      <li>
        한 가지 / 여러 가지
      </li>
    </ul>
  <li>
    RESTful 라우터 계층에서 명사는 resource 이다. (현재 예에서는 creature와 explorer).
  </li>
</ul>

<br><br>

<h1>3. 보호</h1>
<ul>
  <li>
    서비스 계층은 데이터 계층에서 <strong>들어가고 나오는 것</strong>만 신경쓰면 된다.
  </li>
  <li>
    인증과 인가의 복잡성은 상위 계층(현재는 web 계층)에서 처리할 수 있다.
  </li>
  <li>
    생성, 수정, 삭제 함수는 광범위하게 개방되어서는 안되며, get 함수 조차도 어느 정도 제한이 포함된다.
  </li>
</ul>

<br><br>

<h1>4. 기능</h1>

```python
# 1. creature 서비스 모듈을 가짜 데이터에 연결 (service/creature.py)
from ..model.creature import Creature
import fake.creature as data

def get_all() -> list[Creature]:
    return data.get_all()

def get_one(name: str) -> Creature | None:
    return data.get_one(name)

def create(creature: Creature) -> Creature:
    return data.create(creature)

def replace(name: str, creature: Creature) -> Creature:
    return data.replace(name, creature)

def modify(name: str, creature: Creature) -> Creature:
    return data.modify(name, creature)

def delete(name: str) -> bool:
    return data.delete(name)
```

```python
# 2. 마찬가지로 explorer 서비스 모듈을 가짜 데이터에 연결( service/explorer.py)
from ..model.explorer import Explorer
import fake.explorer as data

def get_all() -> list[Explorer]:
    return data.get_all()

def get_one(name: str) -> Explorer | None:
    return data.get_one(name)

def create(explorer: Explorer) -> Explorer:
    return data.create(explorer)

def replace(name: str, explorer: Explorer) -> Explorer:
    return data.replace(name, explorer)

def modify(name: str, explorer: Explorer) -> Explorer:
    return data.modify(name, explorer)

def delete(name: str) -> bool:
    return data.delete(name)
```

<br><br>

<h1>5. 테스트!</h1>
<ul>
  <li>
    이번 테스트는 pytest를 통해 직접 스크립트를 실행하는 방법을 사용하는데, 이건 컨테이너 내부에 들어가서 진행한다.
  </li>
    <ul>
      <li>
        pytest를 사용하기에 pytest에서 사용할 <strong>접두사 test_</strong> 혹은 <strong>접미사 _test</strong>를 붙여야 한다.
      </li>
    </ul>
  <li>
    테스트를 하기 전 예외 처리를 수행하여 잘못된 반환의 유형을 코딩해 둔다.
  </li>
</ul>

```python
# 1. 서비스 테스트 (test/unit/service/test_creature.py)
from ..model.creature import Creature
from ..service import creature as code

sample = Creature(
    name="Yeti",
    country="CN",
    area="Himalayas",
    description="Hirsute Himalayan",
    aka="Abominable Snowman"
)

def test_create():
    resp = code.create(sample)
    assert resp == sample

def test_get_exists():
    resp = code.get_one("Yeti")
    return resp == sample

def test_get_missing():
    resp = code.get_one("boxturtle")
    assert resp is None
```

<br><br>

<h1>6. 웹 계층 수정</h1>
<ul>
  <li>
    서비스 계층 테스트를 완료하였기에 웹 계층에서 fake를 service로 변경한다.
  </li>
</ul>

```python
# 1. web/explorer.py
- import fake.explorer as service

+ import service.explorer as service
```

```python
# web/creature.py
- import fake.creature as service

+ import service.creature as service
```

<br><br>

<h1>7. 기타 서비스 수준 고려 사항</h1>
<ul>
  <li>
    다음의 기술 아이디어는 소규모 사이트에도 도움이 된다.
  </li>
    <ul>
      <li>
        로깅
      </li>
      <li>
        표시
      </li>
      <li>
        모니터링
      </li>
      <li>
        추적
      </li>
    </ul>
</ul>

<br>

<h2>7-1. 로깅</h2>
<ul>
  <li>
    FastAPI는 타임스탬프, 메서드, URL을 포함해 엔드포인트에 대한 각 API 호출을 기록하지만 <strong>본문</strong>이나 <strong>헤더</strong>를 통해 전달되는 데이터는 <strong>기록하지 않는다</strong>.
  </li>
</ul>

<br>

<h2>7-2. 지표, 모니터링, 통합 가시성</h2>
<ul>
  <li>
    API 웹 사이트의 경우 데이터 분석을 위해 엔드포인트 접근 빈도 등을 추적하기 위해 <strong>통계 메트릭(지표)를 수집</strong>한다.
  </li>
  <li>
    통계 메트릭을 수집하는 것을 <strong>모니터링(monitering)</strong> 혹은 <strong>관찰 가능성(observability)</strong>라 한다.
  </li>
  <li>
    모니터링은 보통 그라파나와 프로메테우스를 사용한다.
  </li>
</ul>

<br>

<h2>7-3. 추적</h2>
<ul>
  <li>
    새로운 오픈 소스 프로젝트에서 Jaeger(https://www.jaegertracing.io) 같은 초기 추적 제품을 OpenTelemetry(https://opentelemetry.io)로 브랜드화 했으며 추적을 위해 사용할 수 있다.
  </li>
  <li>
    추적에서는 응답 시간 등을 측정하여 추적하고 고도화를 시도해 볼 수 있다.
  </li>
</ul>