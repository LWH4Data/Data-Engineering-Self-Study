<h1>1. 인증의 필요성</h1>
<ul>
  <li>
    인증은 정체성의 문제이며 구현을 하기 위해서는 비밀 정보를 고유 <strong>정체성에 매핑</strong>해야 한다.
  </li>
  <li>
    단순 조회수가 아니라 순 방문자 수, 가장 인기있는 페이지 등을 알기 위해서는 인증이 필요하다.
  </li>
  <li>
    인증이나 인가를 사용하는 경우 공격자가 일반 텍스트에서 비밀 데이터를 추출하지 못하도록 사이트에 대한 접근을 <strong>암호화(HTTPS)</strong> 해야 한다.
  </li>
</ul>

<br><br>

<h1>2. 인증 방법</h1>
<ul>
  <li>
    웹 인증 방법과 도구는 다양하며 다음과 같은 대표적인 예가 있다.
  </li>
    <ul>
      <li>
        <strong>유저 아이디 / 이메일 및 비밀번호</strong>: 전통적인 HTTP 기본 및 다이제스트 인증
      </li>
      <li>
        <strong>API 키</strong>: 비밀 정보가 담긴 임의의 긴 문자열
      </li>
      <li>
        <strong>OAuth2</strong>: 인증 및 인가를 위한 일종의 표준
      </li>
      <li>
        <strong>JSON 웹 토큰(JWT)</strong>: 암호로 서명된 유저 정보가 담긴 인코딩 형식
      </li>
    </ul>
</ul>

<br><br>

<h1>3. 글로벌 인증: 공유 비밀번호</h1>
<ul>
  <li>
    웹 서버만 아는 비밀번호를 전달하며 암호가 일치하면 인증이 완료된다.
  </li>
  <li>
    단, HTTPS가 아닌 <strong>HTTP</strong>의 경우 <strong>프런트엔드가 해킹</strong> 당하면 문제가 발생한다.
  </li>
</ul>

```python
# 1. HTTP 기본 인증을 사용해 유저 정보 가져오가. (auth.py)
from fastapi import Depends, FastAPI
from fastapi.security import HTTPBasic, HTTPBasicCredentials

app = FastAPI()
basic = HTTPBasic()

@app.get("/who")
def get_user(
    creds: HTTPBasicCredentials = Depends(basic)):
    return {"username": creds.username, "password": creds.password}
```

```python
# 2. auth.py에 비밀 아이디와 비밀번호 추가.
from fastapi import Depends, FastAPI, HTTPException
from fastapi.security import HTTPBasic, HTTPBasicCredentials

app = FastAPI()

secret_user: str = "newphone"
secret_password: str = "whodis?"

basic: HTTPBasicCredentials = HTTPBasic()

@app.get("/who")
def get_user(
    creds: HTTPBasicCredentials = Depends(basic)) -> dict:
    if (creds.username == secret_user and
        creds.password == secret_password):
        return {"username": creds.username,
            "password": creds.password}
    raise HTTPException(status_code=401, detail="Hey!")
```

<br><br>

<h1>4. 간단한 개인 인증</h1>
<ul>
  <li>
    실제 개별 유저를 인증하려면 다음과 같은 조금 더 많은 작업을 수행해야 한다.
  </li>
    <ul>
      <li>
        유저 값(이름 및 비밀번호)을 <strong>HTTP 헤더</strong>로 API 서버 엔드포인트에 전달한다.
      </li>
      <li>
        이러한 헤더의 텍스트를 탈취하는 사람을 피하려면 <strong>HTTPS</strong>를 사용한다.
      </li>
      <li>
        비밀번호를 다른 문자열로 <strong>해시</strong>한다. 해시 결과는 해제가 불가능하므로 <strong>원래 비밀번호를 단어와 비교</strong>한다.
      </li>
      <li>
        실제 DB에 아이디와 해시된 비밀번호 (원래 일반 텍스트 비밀번호가 아닌)가 담긴 <strong>유저 DB 테이블</strong>을 저장한다.
      </li>
      <li>
        새로 입력한 비밀번호를 해시하고 그 결과를 <strong>DB에 해시된 비밀번호 단어와 비교</strong>한다.
      </li>
      <li>
        아이디와 해시된 비밀번호가 일치하면 일치하는 유저 객체를 스택 위로 전달한다. 일치하지 않으면 <strong>None을 반환</strong>하거나 <strong>예외</strong>를 발생시킨다.
      </li>
      <li>
        서비스 계층에서 <strong>개별 유저 인증과 관련된 모든 지표/로깅 등</strong>을 실행한다.
      </li>
      <li>
        웹 계층에서 인증된 유저 정보를 필요한 <strong>모든 기능에 전송</strong>한다.
      </li>
    </ul> 
</ul>

<br><br>

<h1>5. 더 멋진 개인 인증</h1>
<ul>
  <li>
    개인 인증을 하려면 개인 정보를 최소한 <strong>키(아이디나 API 키)와 비밀(비밀번호나 API 비밀번호)이 있는 레코드가 포함된 DB</strong>같은 곳에 <strong>저장</strong>해야 한다.
  </li>
  <li>
    웹 방문자는 보호된 URL에 접근할 때 이런 정보를 제공하기에 DB에 이를 <strong>일치시킬 수 있는 무언가</strong>가 필요하다.
  </li>
</ul>

<br><br>

<h2>5-1. OAuth2</h2>
<ul>
  <li>
    <strong>개방형 인증(Open Authorization, OAuth)</strong>은 앱이 <strong>유저를 대신</strong>해 웹 앱에서 호스팅하는 <strong>리소스에 접근</strong>할 수 있도록 설계된 표준이다.
  </li>
    <ul>
      <li>
        원래 OAuth는 A라는 앱이 B라는 앱의 <strong>특정 리소스에만 접근하도록 허용</strong>할 목적으로 설계 되었다.
      </li>
      <li>
        OAuth2에는 가벼운 설명(http://oreil.ly/ehmuf)부터 무거운 설명(https://oreil.ly/qAUaM)까지 다양한 설명이 있다.
      </li>
    </ul>
  <li>
    설치해야되는 패키지들을 requirements.txt에 추가한다.
  </li>
</ul>

<br>

<h2>5-2. 유저 모델</h2>

```python
# 1. 유저 정의 (model/user.py)
from pydantic import BaseModel

# 유저의 기본 모델
class PublicUser(BaseModel):
    # 유저의 이름으로 외부로 노출되는 유일한 속성이다.
    name: str

# 유저가 처음 가입 시 사용할 요청 본문의 Pydantic모델.
#   - PublicUser를 상속하기에 name 속성을 설명하지 않아도 갖고 있다.
class SignInUser(PublicUser):
    password: str

# FastAPI 서버 내부에서 서비스 계층과 데이터 계층의 통신 시 사용한다.
#   - 마찬가지로 PublicUser를 상속하기에 name을 명시할 필요가 없다.
class PrivateUser(publicUser):
    hash: str
```

<br>

<h2>5-3. 유저 데이터 계층</h2>
<ul>
  <li>
    <strong>user(활성 유저)</strong> 및 <strong>xuser(삭제된 유저)</strong> 테이블을 만든다.
  </li>
    <ul>
      <li>
        개발자 중에 deleted 필드를 추가하는 경우가 있는데 이것보다는 <strong>탈퇴한 회원 테이블</strong>에서 관리하는 것을 권장한다. 그러면 유저 조회시에 불필요한 데이터를 확인할 필요가 없다.
      </li>
      <li>
        불리언과 같이 카디널리티가 낮은 필드에 대한 인덱스를 만드는 것은 좋지 않다.
      </li>
    </ul>
</ul>

```python
# 1. 데이터 계층 (data/user.py)
from model.user import PublicUser, PrivateUser, SignInUser
from .init import (conn, curs, get_db, IntegrityError)
from error import Missing, Duplicate

curs.execute("""create table if not exits
                user(
                    name text primary key,
                    hash text)""")
curs.execute("""create table if not exists
                xuser(
                    name text primary key,
                    hash text)""")

# is_public 인자에 따라 나가는 모델이 분기된다.
def row_to_model(row: tuple, is_public: bool = True) -> PublicUser | PirvateUser:
    name, hash = row
    if is_public:
        return PublicUer(name=name)
    else:
        return PrivateUser(name=name, hash=hash)

def model_to_dict(user: PrivateUser) -> dict:
    return user.model_dump()

# 유저 조회는 is_pulibc에 따라 PublicUser 또는 PrivateUser를 반환한다.
def get_one(name: str, is_public: bool = True) -> PublicUser | PrivateUser:
    qry = "select * from user where name=:name"
    params = {"name": name}
    curs.execute(qry, params)
    row = curs.fetchone()
    if row:
        return row_to_model(row, is_public=is_public)
    else:
        raise Missing(msg=f"User {name} not found")

# 유저 목록 조회에서는 민감정보(hash)를 포함할 일이 없어 PublicUser 모델 집합을 반환한다.
def get_all() -> list[PublicUser]:
    qry = "select * from user"
    curs.execute(qry)
    return [row_to_model(row) for row in curs.fetchall()]

# 유저 생성을 위해서는 password를 암호화한 hash 값을 저장해야 한다.
# create 함수는 user 인자가 hash 값을 갖고 있는 것으로 간주한다.
# 저장이 완료되면 외부로 노출돼도 되는 PublicUser를 반환한다.
def create(user: PrivateUser, table:str = "user") -> PublicUser:
    """user 테이블 또는 xuser 테이블에 유저를 생성한다."""
    qry = f"""insert into {table}
        (name, hash)
        values
        (:name, :hash)"""
    params = model_to_dict(user)
    try:
        curs.execute(qry, params)
    except IntegrityError:
        raise Duplicate(msg=
            f"{table}: user {user.name} already exists")
    return PublicUser(name=user.name)

# name이 외부로 노출되기에 현재는 name에 대한 변경만 가능하다.
def modify(name: str, user: PublicUser) -> PublicUser:
    """name으로 조회한 유저의 이름을 수정한다."""
    qry = """update user set
            name=:name
            where name=:name0"""
    params = {
        "name": user.name
        "name0": name}
    curs.execute(qry, params)
    if curs.rowcount == 1:
        return get_one(user.name)
    else:
        raise Missing(msg=f"User {name} not found")

def delete(name: str) -> None:
    """name으로 user 테이블에서 조회한 유저를 삭제하고, xuser 테이블에 추가한다"""
    user = get_one(name, is_public=False)
    qry = "delete from user where name = :name"
    params = {"name": name}
    curs.execute(qry, params)
    if curs.rowcount != 1:
        raise Missing(msg=f"user {name} not found")
    create(user, table="xuser")
```

<br>

<h2>5-4. 유저 가짜 데이터 계층</h2>

```python
from model.user import SignInUser, PrivateUser, PublicUser
from error import Missing, Duplicate

from model.user import SignInUser, PrivateUser, PublicUser
from error import Missing, Duplicate

# 이 모둘에서는 hash 비밀번호 검증을 하지 않는다.
fakes = [
    PublicUser(name="kwijobo"),
    PublicUser(name="ermagerd"),
]

def find(name: str) -> PublicUser | None:
    for e in fakes:
        if e.name == name:
            return e
    return None

def check_missing(name: str):
    if not find(name):
        raise Missing(msg=f"Missing user {name}")

def check_duplicate(name: str):
    if find(name):
        raise Duplicate(msg=f"Duplicate user {name}")

def get_all() -> list[PublicUser]:
    """모든 유저를 반환한다."""
    check_missing(name)
    return find(name)

def get_one(name: str) -> PublicUser:
    """한 유저를 반환한다."""
    check_missing(name)
    return find(name)

def create(user: PublicUser) -> PublicUser:
    """유저를 생성한다."""
    check_duplicate(user.name)
    return PublicUser(name=user.name)

def modify(name: str, user: PublicUser) -> PublicUser:
    """유저를 수정한다."""
    check_missing(name)
    return user

def delete(name: str) -> None:
    """유저를 삭제한다."""
    check_missing(name)
    return None
```

<br>

<h2>5-5. 유저 서비스 계층</h2>

```python
# 1. OAuth2와 JWT를 추가한 서비스 계층 (service/user.py)
from datetime import timedelta, datetime
import os
from jose import jwt
import bcrypt
from model.user import PublicUser, PrivateUser, SignInUser

if os.getenv("CRYPTID_UNIT_TEST"):
    from fake import user as data
else:
    from data import user as data

# --- 새로운 인증 관련 코드

# SECRET_KEY는 반드시 바꾸고 배포해야 한다!
SECRET_KEY = "keep-it-secret-keep-it-safe"
ALGORITM = "HS256"

def verify_password(plain: str, hash: str) -> bool:
    """plain을 해시 값과, DB의 hash 값과 비교한다."""
    password_bytes = plain.encode('utf-8')
    hash_bytes = hash.encode('utf-8')
    is_valid = bcrypt.checkpw(password_bytes, hash_bytes)
    return is_valid

def get_hash(plain: str) -> str:
    """plain의 해시값을 반환한다."""
    password_bytes = plain.encode('utf-8')
    salt = bcrypt.gensalt()
    hashed_password = bcrypt.hashpw(password_bytes, salt)
    return hashed_password.decode('utf-8')

def get_jwt_username(token:str) -> str | None:
    """JWT 접근 토큰으로부터 username을 반환한다."""
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        if not (username := payload.get("sub")):
            return None
    except jwt.JWTError:
        return None
    return username

def get_current_user(token: str) -> PublicUser | None:
    """OAuth 토큰을 풀어서 PublicUser를 반환한다."""
    if not(username := get_jwt_username(token)):
        return None
    if (user := lookup_user(username)):
        return user
    return None

def lookup_user(username: str, is_public=True) -> PublicUser | PrivateUser | None:
    """DB에서 username에 매칭되는 User를 반환한다.
    is_public이 True이면 PublicUser를 반환하고, False 이면 PrivateUser를 반환한다.
    hash 속성은 PrivateUSer만 갖고 있다. 비밀번호 인증을 위해 hash 속성이 필요하다.
    """
    if (user := data.get_one(username, is_public=is_public)):
        return user
    return None

def auth_user(name: str, plain: str) -> PublicUser | PrivateUser | None:
    """name과 plain 암호로 유저를 인증한다."""
    if not (user := lookup_user(name, is_public=False)):
        return None
    if not verify_password(plain, user.hash):
        return None
    return user

def create_access_token(data: dict,
    expires: timedelta | None = None
):
    """JWT 접근 토큰을 반환한다."""
    src = data.copy()
    now = datatime.utcnow()
    if not expires:
        expires = timedelta(minutes=15)
    src.update({"exp": now + expires})
    encoded_jwt = jwt.encode(src, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

# --- CRUD 통과 코드

def get_all() -> list[PublicUser]:
    return data.get_all()

def get_one(name) -> PublicUser:
    return data.get_all()

# data.create는 hash 속성을 지닌 PrivateUser를 기대한다.
# SignInUser의 password를 해시한 hash 속성을 갖고 있는 PrivateUser를 만들어 전달한다.
def create(sign_in_user: SignInUser) -> PublicUser:
    user = PrivateUser(name=sign_in_user.name, hash=get_hash(sign_in_user.password))
    return data.create(user)

def modify(name: str, user: PublicUser) -> PublicUser:
    return data.modify(name, user)

def delete(name: str) -> None:
    return data.delete(name)
```

<br>

<h2>5-6. 유저 웹 계층</h2>

```python
# 1. 유저의 웹 계층을 정의한다. (web/user.py)
import os
from fastapi import APIRouter, HTTPException, Depends
from datetime import timedelta
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from model.user import PrivateUser, PublicUser, SignInUser

if os.getenv("CRYPTID_UNIT_TEST"):
    from fake import user as service
else:
    from service import user as service
from error import Missing, Duplicate

ACCESS_TOKEN_EXPIRE_MINUTES = 30

router = APIRouter(prefix - "/user")

# --- 새로운 인증 관련 코드들

# 이 의존성은 "/user/token"을 동작하게 하고
# (username과 pass를 담고 있는 form을 읽는다.)
# 접근 토큰을 반환한다.

oauth2_dep = OAuth2PasswordBearer(tokenUrl="/user/token")

def unauthed():
    raise HTTPException(
        status_code=401,
        detail="Incorrect username or password",
        headers={"WWW-Authenticate": "Bearer"},
        )

@router.post("/token")
async def create_access_token(
    form_data: OAuth2PasswordRequestForm = Depends()
):
    """username과 password를 OAuth 양식에서 꺼내고
        JWT 접근 토큰을 반환한다."""
    user = service.auth_user(form_data.username, form_data.password)
    if not user:
        unauthed()
    expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = service.create__access_token(
        data={"sub": user.name}, expires=expires
    )
    return {"access_token": access_token, "token_type": "bearer"}

# 이 엔드포인트는 oauth2_dep() 의존성을 갖고 있다.
@router.get("/token")
def get_access_token(token: str = Depends(oauth2_dep)) -> dict:
    """현재 접근 토큰을 반환한다."""
    return {"token": token}

# --- 이전 CRUD 코드

@router.get("/")
def get_all() -> list[PublicUser]:
    return service.get_all()

@router.get("/{name}")
def get_one(name) -> PublicUser:
    try:
        return service.get_one(name)
    except Missing as exc:
        raise HTTPException(status_code=404, detail=exc.msg)

@router.post("/", status_code=201)
def create(user: SignInUser) -> PublicUser:
    try:
        return service.create(user)
    except Duplicate as exc:
        raise HTTPEception(status_code=409, detail=exc.msg)

@router.patch("/{name}")
def modify(name: str, user: PublicUser) -> PublicUser:
    try:
        return service.modify(name, user)
    except Missing as exc:
        raise HTTPException(status_code=404, detail=exc.msg)

@router.delete("/{name}")
def delete(name: str) -> None:
    try:
        return service.delete(name)
    except Missing as exc:
        raise HTTPException(status_code=404, detail=exc.msg)
    except Duplicate as exc:
        raise HTTPException(status_code=409, detail=exc.msg)
```

<br>

<h2>5-7. 테스트!</h2>
<ul>
  <li>
    테스트의 방식은 이전과 동일하다.
  </li>
</ul>

```python
# 1. 테스트를 위한 main.py 작성
from fastapi import FastAPI
from web import explorer, creature, user

app = FastAPI()

app.include_router(explorer.router)
app.include_router(creature.router)
app.include_router(user.router)
```

<br>

<h2>5-10 JWT</h2>
<ul>
  <li>
    JWT는 세 가지 섹션이 있는 읽기 가능한 문자열이다.
  </li>
    <ul>
      <li>
        <strong>Header</strong>: 사용된 암호화 알고리즘 및 토큰 유형
      </li>
      <li>
        <strong>Payload</strong>
      </li>
      <li>
        <strong>Signature</strong>
      </li>
    </ul>
  <li>
    각 세션은 <strong>Base64URL</strong> 형식으로 인코딩된 JSON 문자열로 구성된다.
  </li>
    <ul>
      <li>
        Base64URL은 URL에도 안전한 일반 ASCII 문자열로, 웹 서버에 URL, 쿼리 매개변수, HTTP 헤더, 쿠기 등으로 전달한다.
      </li>
    </ul>
</ul>

<br>

<h2>5-11. 서드파티 인증: OIDC</h2>
<ul>
  <li>
    다른 웹사이트에서 구글 페이스북(메타) 등의 계정을 통해 로그인을 할 수 있다.
  </li>
    <ul>
      <li>
        이런 웹 사이트들은 OAuth2를 기반으로 구축된 <strong>OIDC</strong>라는 표준을 사용하는 경우가 많다. 외부 OIDC 사용 사이트에 접근하면 동일하게 <strong>OAuth2 접근 토큰</strong>과 <strong>ID 토큰</strong>이 반환된다.
      </li>
    </ul>
  <li>
    공식 FastAPI 문서에는 OIDC와의 통합을 위한 코드가 포함되어 있지 않아 직접 구현보다 <strong>서드파티 패키지</strong>를 사용하는 것이 좋다.
  </li>
    <ul>
      <li>
        자세한 내용은 p207의 서드파티 패키질 목록을 확인.
      </li>
    </ul>
</ul>

<br><br>

<h1>6. 인가</h1>
<ul>
  <li>
    <strong>인증</strong>은 정체성인 <strong>누구</strong>를, <strong>인가</strong>는 어떤 리소스 및 웹 엔드포인트에 어떤 접근을 하는지인 <strong>무엇</strong>을 처리한다.
  </li>
  <li>
    인증 사례의 진행과정
  </li>
    <ul>
      <li>
        관리자 방문자만 추적하고 나머지는 익명으로 유지하는 경우
        <br>→ 인증된 유저 아이디의 Admin 테이블을 사용한다.
        <br>→ Admin 테이블에서 이름을 조회한다.
        <br>→ 이름이 일치하는 유저 테이블에서 해시된 비밀번호와 대조한다.
      </li>
      <li>
        모든 방문자를 인증하지만 일부 엔드포인트는 관리자에게 권한을 부여해야 하는 경우
        <br>→ 유저 테이블의 모든 유저를 인증한다.
        <br>→ Admin 테이블을 확인해 해당 유저가 관리자인지 확인한다.
      </li>
      <li>
        두 가지 이상의 권한 유형(e.g. 읽기 전용, 읽기, 쓰기)
      </li>
        <ul>
          <li>
            Permission 정의 테이블을 사용한다.
          </li>
          <li>
            UserPermission 테이블을 사용한다. 유저와 권한을 한 쌍으로 한다. 
          </li>
        </ul>
      <li>
        권한 조합이 복잡한 경우 레벨을 추가하고 역할(독립된 권한 집합)을 정의한다.
      </li>
        <ul>
          <li>
            Role 테이블을 만든다.
          </li>
          <li>
            User 및 Role 항목을 페어링하는 UserRole 테이블을 생성한다. 역할 기반 접근 제어라고도 한다.
          </li>
        </ul>
    </ul>
</ul>

<br><br>

<h1>7. 미들웨어</h1>
<ul>
  <li>
    FastAPI에서는 미들웨어는 모든 요청이 엔드포인트에 도달하기 전에 가로채서 <strong>공통 작업을 자동으로 처리</strong>해 앱의 일관성과 효율성을 높인다.
  </li>
  <li>
    미들 웨어에는 다음과 같은 코드를 삽입한다.
  </li>
    <ul>
      <li>
        요청을 가로챈다.
      </li>
      <li>
        요청에 대한 작업을 수행한다.
      </li>
      <li>
        요청을 경로 함수에 전달한다.
      </li>
      <li>
        패치 함수가 반환한 응답을 가로챈다.
      </li>
      <li>
        응답으로 무언가를 수행한다.
      </li>
      <li>
        호출자에게 응답을 반환한다.
      </li>
    </ul>
</ul>

<br>

<h2>7-1. CORS</h2>
<ul>
  <li>
    <strong>교차 출처 리소스 공유(cross-origin resource sharing, CORS)</strong>는 웹사이트가 신뢰하는 다른 서버와 통신하는 데 사용한다.
  </li>
    <ul>
      <li>
        <strong>프로토콜</strong>: HTTP 혹은 HTTPS
      </li>
      <li>
        <strong>도메인</strong>: google.com 또는 localhost 같은 인터넷 도메인
      </li>
      <li>
        <strong>포트</strong>: 80, 440 또는 8000 같은 해당 도메인의 숫자 TCP/IP 포트
      </li>
    </ul>
  <li>
    백엔드가 신뢰하는 프런트엔드를 CORS로 지정하는 방식에는 다음이 있다.
  </li>
    <ul>
      <li>
        Origin
      </li>
      <li>
        HTTP 메서드
      </li>
      <li>
        HTTP 헤더
      </li>
      <li>
        CORS 캐시 시간제한
      </li>
    </ul>
</ul>

```python
# 1. CORS 미들웨어 활성화
from fastapi import FastAPI, Request
from fastapi.middleware.cors import CORSMiddleware

app = FastAPI()

app.add_middleware(
CORSMiddleware,
    allow_origins=["https://ui.cryptids.com",],
    allow_credentials=True,
    allow_method=["*"],
    allow_headers=["*"]
)

@app.get("/test_cors")
def test_cors(request: Request):
    print(request)
```

<br>

<h2>7-2. 서드파티 패키지</h2>
<ul>
  <li>
    여러 인가 및 인증 솔류션이 있는데 이들은 직접 구현하기보다 <strong>패키지</strong>를 사용하는 것이 훨씬 빠르고 편하다.
  </li>
</ul>