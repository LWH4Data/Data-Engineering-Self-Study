<h1>1. 배포</h1>
<ul>
  <li>
    많은 트래픽을 처리하기 위해서는 다중 코어에서 실행되는 여러 대의 서버가 필요하다.
  </li>
</ul>

<br>

<h2>1-1. 다중 작업</h2>
<ul>
  <li>
    FastAPI는 ASGI를 기반으로 하며 Gunicorn의 UvicornWorker 클래스로 관리할 수 있다.
  </li>
  <li>
    Gunicorn은 먼저 <strong>최상위 Gunicorn 프로세스</strong>를 시작하고, 이와 통신하는 네 개의 <strong>Uvicorn 워커 하위 프로세스</strong>를 실행한다.
  </li>
    <ul>
      <li>
        하위 워커 프로세스는 localhost(0.0.0.0):8000을 공유한다.
      </li>
    </ul>
  <li>
    main:app은 main.py와 변수 이름이 app인 FastAPI 객체를 참조한다.
  </li>
  <li>
    Gunicorn은 가용성 유지, 외부 요청의 수집과 전달, 응답 반환은 처리하지만 HTTPS 함호화는 처리하지 않는다.
  </li>
</ul>

<br><br>

<h1>2. HTTPS</h1>
<ul>
  <li>
    FastAPI <strong>공식 HTTPS 문서</strong>, <strong>라미레즈(Ramirez, https://oreil.ly/zcUWS)</strong>, <strong>Traefik(트래픽, https://traefik)</strong>을 사용해 FastAPI에 HTTPS 지원을 추가한다.
  </li>
    <ul>
      <li>
        Traefik은 <strong>리버스 프록시</strong> 및 <strong>로드밸런서</strong>로 nginx와 유사하게 웹 서버 위에 위치하지만 HTTPS가 내장된다.
      </li>
    </ul>
</ul>

<br>

<h2>2-1. 도커</h2>
<ul>
  <li>
    <strong>공식 FastAPI 문서</strong>에는 FastAPI 앱의 도커 버전을 구축하는 방법이 설명되어 있다.
  </li>
</ul>

<br>

<h2>2-2. 클라우드 서비스</h2>
<ul>
  <li>
    다양한 호스팅 서버를 통해 FastAPI를 호스팅하는 방법을 설명한다.
  </li>
</ul>

<br>

<h2>2-3. 쿠버네티스</h2>
<ul>
  <li>
    FastAPI를 쿠버네티스로 배포하는 방법은 수만타 무코파다이(Sumanta Mukhopadhyay)의 쿠버네티스에 FastAPI 배포하기(https://oreil.ly/ktTNu)가 있다.
  </li>
</ul>

<br><br>

<h1>3. 성능</h1>
<ul>
  <li>
    FastAPI는 대부분 비동기로 I/O 대기를 피하는 ASGI 덕분에 속도가 빠르다.
  </li>
</ul>

<br>

<h2>3-1. 비동기</h2>
<ul>
  <li>
    웹 서버는 대부분의 시간을 HTTP 네트워크 요청을 받고 결과를 반환하는 데 소 비한다.
  </li>
  <li>
    웹 서비스의 코드가 응답을 기다려야 할 때 비동기 함수(async def)를 사용하는 것이 좋다. 이때문에 FastAPI가 빠른 것이다.
  </li>
  <li>
    성능은 다음 두 가지로 측정할 수 있다.
  </li>
    <ul>
      <li>
        단일 요청을 처리하는 데 걸리는 시간.
      </li>
      <li> 
        한 번에 처리할 수 있는 요청 수.
      </li>
    </ul>
</ul>

<br>

<h2>3-2. 캐시</h2>
<ul>
  <li>
    정적 소스에서 궁극적으로 데이터를 가져오는 웹 엔드포인트가 있는 경우, 함수에서 데이터를 캐시할 수 있다.
  </li>
</ul>

<br>

<h2>3-3. 데이터베이스와 파일, 메모리</h2>
<ul>
  <li>
    SQL에서는 WHERE 절의 모든 컬럼을 인덱싱해야 한다.
  </li>
  <li>
    쿼리 최적화 도구를 사용해볼수도 있다.
  </li>
  <li>
    파이썬 스크립트나 오픈 소스 도구로 DB 부하 테스트를 수행할 수 있다.
  </li>
</ul>

<br>

<h2>3-4. 큐</h2>
<ul>
  <li>
    1초 이상 걸리는 작업은 Celery 같은 작업 큐에 넘기는 것이 좋다.
  </li>
</ul>

<br>

<h2>3-5. 파이썬 자체</h2>
<ul>
  <li>
    속도가 느린 경우 PyPy를 사용하거나 C, C++ 또는 러스트로 파이썬 확장 프로그램을 작성하거나, Cython으로 변환할 수 있다.
  </li>
  <li>
    Mojo 언어에 대해 소개해 두었다. C와 유사하면서도 Python 처럼 AI에 사용할 수 있는 언어를 목표한다고 한다.
  </li>
</ul>

<br><br>

<h1>4. 트러블슈팅</h1>
<h2>4-1. 문제 유형</h2>
<ul>
  <li>
    <strong>401</strong>: 인증 혹인 인가 오류
  </li>
  <li>
    <strong>422</strong>: 일반적으로 잘못된 모델 사용에 대한 Pydantic 응답.
  </li>
  <li>
    <strong>500</strong>: FastAPI 서비스 뒤에 있는 서비스가 실패.
  </li>
</ul>

<br>

<h2>4-2. 로깅</h2>
<ul>
  <li>
    Uvicorn과 그 외 웹 서비스는 일반적으로 <strong>stdout</strong>에 로그를 기록한다.
  </li>
    <ul>
      <li>
        로그를 통해서는 HTTP 동사, URL 등 <strong>어떤 호출</strong>이 이루어졌는지 알 수 있다.
      </li>
      <li>
        그러나 <strong>본문</strong>, <strong>헤더</strong>, <strong>쿠키</strong>의 데이터를 확인할 수 없다.
      </li>
    </ul>
  <li>
    에러가 발생한다면 관련 함수에 print() 문을 추가하는 것을 포함하여 <strong>예외 처리</strong>를 해두는 것이 중요하다.
  </li>
</ul>

<br>

<h2>4-3. 지표</h2>
<ul>
  <li>
    모니터링 툴에는 당연하게도 Prometheus와 Grafana를 소개한다. 특이한 점은 OpenTelemetry가 있으며 타이밍을 측정한다.
  </li>
</ul>