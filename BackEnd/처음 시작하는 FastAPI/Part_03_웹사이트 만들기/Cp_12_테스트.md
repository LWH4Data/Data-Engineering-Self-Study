<h1>1. 웹 API 테스트</h1>
<ul>
  <li>
    수동 테스트 도구는 코드를 작성한 직후 빠르게 검증하는 데 유용하다.
  </li>
  <li>
    수동 테스트 중 하나가 망가진다면 수십 개의 테스트를 다시 해야할 수도 있다 이 때문에 자동화된 테스트가 중요하며 도서에서는 <strong>pytest</strong>를 사용한다.
  </li>
</ul>

<br><br>

<h1>2. 테스트의 종류</h1>
<ul>
  <li>
    <strong>단위 테스트</strong>: 어떤 계층에서 <strong>개별 기능</strong>을 테스트 한다.
  </li>
  <li>
    <strong>통합 테스트</strong>: 여러 계층에 걸쳐 <strong>연결성을 테스트</strong>한다.
  </li>
  <li>
    <strong>전체 테스트</strong>: <strong>전체 API</strong>와 그 아래에 있는 스택을 테스트한다.
  </li>
</ul>

<br><br>

<h1>3. 테스트 대상</h1>
<ul>
  <li>
    주어진 입력대로 출력이 나오는지를 포함하여 여러 가지 테스트를 진행한다.
  </li>
  <li>
    오류는 어디에서나 발생할 수 있다.
  </li>
  <li>
    여러 테스트 방법
  </li>
    <ul>
      <li>
        HTTPie를 통한 완전 수동 테스트
      </li>
      <li>
        파이썬 코드 조각에 대한 수동 단위 테스트
      </li>
      <li>
        <strong>Pytest</strong> 스크립트를 사용한 자동화 테스트
      </li>
    </ul>
</ul>

<br><br>

<h1>4. pytest</h1>
<ul>
  <li>
    최근에 가장 많이 사용되는 패키지는 pytest이다. 
  </li>
  <li>
    pytest의 기능들에는 다음이 있다.
  </li>
    <ul>
      <li>
        <strong>테스트 탐색</strong>
      </li>
        <ul>
          <li>
            파일명이 <strong>test</strong>로 시작하거나 끝나는 파이썬 파일을 찾아 자동으로 실행한다.
          </li>
          <li>
            하위 디렉터리로 계속 내려가며 <strong>파일명 규칙</strong>이 일치하는 파일을 찾아 해당 디렉터리에 있는 모든 테스트를 실행한다.
          </li>
        </ul>
      <li>
        <strong>단언(assertion) 실패 상세</strong>
      </li>
        <ul>
          <li>
            실패한 단언문은 예상 결과와 실제 결과를 출력한다.
          </li>
        </ul>
      <li>
        <strong>픽스처(fixture)</strong>
      </li>
        <ul>
          <li>
            fixture 함수는 전체 테스트 스크립트에 대해 <strong>한 번만</strong> 수행될 수도 있고, <strong>모든 테스크</strong>에 대해 실행될 수도 있다.
          </li>
          <li>
            표준 테스트 데이터나 DB 초기화 데이터를 테스트 함수에 <strong>매개변수로 제공</strong>하는 역할을 한다.
          </li>
          <li>
            일종의 <strong>의존성 주입</strong>이다.
          </li>
          <li>
            일반 테스트 함수에 <strong>특정 데이터를 전달</strong>한다.
          </li>
        </ul>
      <li>
        <strong>매개변수화 테스트</strong>
      </li>
        <ul>
          <li>
            매개변수화 테스트를 이용하면 테스트 함수에 <strong>여러 테스트 데이터</strong>를 제공할 수 있다.
          </li>
        </ul>
    </ul>
</ul>

<br><br>

<h1>5. 레이아웃</h1>
<ul>
  <li>
    테스트 코드를 두는 합리적인 방법에는 다음 두 가지가 있다.
  </li>
    <ul>
      <li>
        <strong>최상단 디렉터리 test</strong>를 만들고 테스트 대상을 둘 <strong>하위 디렉터리</strong>를 만든다.
      </li>
      <li>
        <strong>각 디렉터리 아래에 test 디렉터리</strong>를 만든다.
      </li>
    </ul>
</ul>

<br><br>

<h1>6. 단위 테스트 자동화</h1>
<ul>
  <li>
    단위 테스트는 <strong>한 계층 내에서 한 가지 검사</strong>를 수행하며 대개 어떤 함수에<strong> 매개변수를 전달하고 반환값을 단언</strong>하는 것을 의미한다.
  </li>
  <li>
    단위 테스트는 테스트 대상과 <strong>격리</strong> 돼야 한다.
  </li>
</ul>

<br>

<h2>6-1. 모의</h2>
<ul>
  <li>
    외부에서 불러오는 함수나 앱의 경우 <strong>모의(mocking)</strong>로 하여 테스트 대상을 격리할 수 있다.
  </li>
</ul>

```python
# 1. 모듈 1: mod1.py
def preamble() -> str:
    return "The sum is "
```

```python
# 2. 모듈 2: mod2.py
import mod1

def summer(x: int, y: int) -> str:
    return mod1.preamble() + f"{x+y}"
```

```python
# 3. summer()를 검증한다.
import mod2

def test_summer():
    assert "The sum is 11"
```

```bash
# 4. pytest를 통해 검증한다.
#   ● -q: 부가적인 세부사항은 출력하지 않고 테스트를 진행한다. 
pytest -q test_summer1.py
```

```python
# 5. preamble()을 모의해 효과를 제거할 수도 있다.
from unittest import mock
import mod1
import mod2

# mock.patch를 파이썬 컨텍스트 관리자로 다룬다.
def test_caller_a():
    # ● "mod1.preamble": mod1 모듈의 preamble() 함수를 나타내는 전체 문자열
    # ● return_value="": 빈 문자열 반환
    with mock.patch("mod1.preamble", return_value=""):
        assert "11" == mod2.summer(5, 6)

# mock_preamble로 선언한 모의 객체를 그대로 사용한다.
def test_caller_b():
    with mock.patch("mod1.preamble") as mock_preamble:
        mock_preamble.return_value = ""
        assert "11" == mod2.summer(5, 6)

# 데코레이터로 모의 객체를 정의하여 인수로 전달한다.
@mock.patch("mod1.preamble", return_value="")
def test_caller_c(mock_preamble):
    assert "11" == mod2.summer(5, 6)

# 데코레이터를 사용하되 mock_preamble 호출에 대한 return_value를 따로 지정한다.
@mock.patch("mod1.preamble")
def test_caller_d(mock_preamble):
    mock_preamble.return_value =""
    assert "11" == mod2.summer(5, 6)
```

```python
# 6. 각 테스트 확인.
pytest -q test_summer2.py
```

<br>

<h2>6-2. 테스트 더블과 fake</h2>
<ul>
  <li>
    <strong>테스트 더블(test double)</strong>을 활용하면 테스트 대상 코드에서 <strong>원하는 부분을 분리</strong>할 수 있다.
  </li>
    <ul>
      <li>
        preamble() 함수가 빈 문자열을 반환하거나 import 구문을 사용한다.
      </li>
    </ul>
</ul>

```python
# 1. 단위 테스트에 사용하는 테스트 더블
import os

if os.getenv("UNIT_TEST"):
    import fake_mod1 as mod1
else:
    import mod1

def summer(x: int, y: int) -> str:
    return mod1.preamble() + f"{x+y}"
```

```python
# 2. 더블 모듈 (fake_mod1.py)
def preamble() -> str:
    return ""
```

```python
# 3.테스트 코드 작성 (test_summer_fake.py)
import os
os.environ["UNIT_TEST"] = "true"

import mod2

def test_summer.fake():
    assert "11" == mod2.summer(5, 6)
```

<br>

<h2>6-3. 웹 계층 테스트</h2>
<ul>
  <li>
    웹 계층은 <strong>API</strong>를 구현한다. 이상적으로는 실패할 수 있는 케이스르 포함해 여러 테스트 케이스가 있어야 한다.
  </li>
</ul>

```python
# 1. 테스트를 위해 수정 (web/creature.py)
import os
from fastapi import APIRouter, HTTPException
from model.creature import Creature
if os.getenv("CRYPTID_UNIT_TEST"):
    from fake import creature as service
else:
    from service import creature as service
from error import Missing, Duplicate

router = APIRouter(prefix = "/creature")

@router.get("/")
def get_all() -> list[Creature]:
    return service.get_all()

@router.get("/{name}")
def get_one(name) -> Creature:
    try:
        return service.get_one(name)
    except Missing as exc:
        raise HTTPException(status_code=404, detail=exc.msg)

@router.post("/", status_code=201)
def create(creature: Creature) -> Creature:
    try:
        return service.create(creature)
    except Duplicate as exc:
        raise HTTPException(status_code=409, detail=exc.msg)

@router.patch("/{name}")
def modify(name: str, creature: Creature) -> Creature:
    try:
        return service.modify(name, creature)
    except Missing as exc:
        raise HTTPException(status_code=404, detail=exc.msg)

@router.put("/{name}")
def replace(name: str, creature: Creature) -> Creature:
    try:
        return service.replace(name, creature)
    except Missing as exc:
        raise HTTPException(status_code=404, detail=exc.msg)

@router.delete("/{name}")
def delete(name: str) -> None:
    try:
        return service.delete(name)
    except Missing as exc:
        raise HTTPException(status_code=404, detail=exc.msg)
```

```python
# 2. 테스트에 맞춰 fake 디렉터리 수정 (fake/creature.py)
from error import Duplicate, Missing

def get_one(name: str) -> Creature:
    """검색한 생명체를 반환한다."""
    for _creature in _creatures:
        if _creature.name == name:
            return _creature
    raise Missing(msg=f"Creature {name} not found")

def create(creature: Creature) -> Creature:
    """생명체를 추가한다."""
    if next((x for x in _creature if x.name == creature.name), None):
        raise Duplicate(msg=f"Creature {creature.name} already exists")
    _creatures.append(creature)
    return creature

def modify(name: str, creature: Creature) -> Creature:
    """생명체의 정보를 일부 수정한다."""
    _creature = next((x for x in _creatures if x.name == creature.name), None)
    if _creature is not None:
        _creature = creature
        return _creature
    else:
        raise Missing(msg=f"Creature {name} not found")

def replace(name: str, creature: Creature) -> Creature:
    """생명체를 완전히 교체한다."""
    _creature = next((x for x in _creatures if x.name == creature.name), None)
    if _creature is None:
        raise Missing(msg=f"Creature {name} not found")
    
    _creature = creature
    return _creature

def delete(name: str) -> bool:
    """생명체를 삭제한다."""
    if not name:
        return False
    
    _creature = next((x for x in _creatures if x.name == name), None)
    if _creature is None:
        raise Missing(msg=f"Explorer {name} not found")
    
    _creatures.remove(_creature)
    return True
```

```python
# 3. fixture를 활용한 생명체에 대한 웹 계층의 단위 테스트 
# (test/unit/web/test_creature.py)
#   - 테스트를 수행할 때 가짜 creature 데이터가 변한다.
#   - 어떤 순서로 테스트를 진행하던 멱등성을 유지하는 것이 좋다.
from fastapi import HTTPException
import pytest
import os
os.environ["CRYPTID_UNIT_TEST"] = "true"
from model.creature import Creature
from web import creature

@pytest.fixture
def sample() -> Creature:
    return Creature(
        name="dragon",
        description="Wings! Fire! Aieee!",
        country="*",
        area="",
        aka="",
    )

@pytest.fixture
def fakes() -> list[Creature]:
    return creature.get_all()

def assert_duplicate(exc):
    assert exc.value.status_code == 404
    assert "Duplicate" in exc.value.msg

def assert_missing(exc):
    assert exc.value.status_code == 404
    assert "Missing" in exc.value.msg

def test_create_duplicate(fakes):
    with pytest.raises(HTTPException) as exc:
        _ = creature.create(fakes[0])
        assert_duplicate(exc)

def test_get_one(fakes):
    assert creature.get_one(fakes[0].name) == fakes[0]

def test_get_one_missing():
    with pytest.raises(HTTPException) as exc:
        _ = creature.get_one("bobcat")
        assert_missing(exc)

def test_modify(fakes):
    assert creature.modify(fakes[0].name, fakes[0]) == fakes[0]

def test_modify_missing(sample):
    with pytest.raises(HTTPException) as exc:
        _ = creature.modify(sample.name, sample)
        assert_missing(exc)

def test_delete(fakes):
    assert creature.delete(fakes[0].name) is None

def test_delete_missing(sample):
    with pytest.raises(HTTPException) as exc:
        _ = creature.delete("emu")
        assert_missing(exc)

def test_create(sample):
    assert creature.create(sample) == sample
```

<br>

<h2>6-4. 서비스 계층 테스트</h2>
<ul>
  <li>
    서비스 계층은 웹 계층과 데이터 계층 모두에 연결된다.
  </li>
  <li>
    하위 수준의 모듈을 가져와 사용하며 데이터 계층에서 발생할 수 있는 예외를 따로 잡지 않고 <strong>웹 계층에서 처리</strong>하도록 남겨둔다.
  </li>
</ul>

```python
# 1. 테스트를 위해 수정 (service/creature.py)
import os
from model.creature import Creature
if os.getenv("CRYPTID_UNIT_TEST"):
    from fake import creature as data
else:
    from data import creature as data

def get_all() -> list[Creature]:
    return data.get_all()

def get_one(name) -> Creature:
    return data.get_one(name)

def creature(creature: Creature) -> Creature:
    return data.create(creature)

def modify(name: str, creature: Creature) -> Creature:
    return data.modify(name, creature)

def delete(name, str) -> Name:
    return data.delete(name)
```

```python
# 2. 서비스 계층 테스트 (test/unit/service/test_creature.py)
import os
os.environ["CRYPTID_UNIT_TEST"] = "true"
import pytest

from model.creature import Creature
from error import Missing, Duplicate
from data import creature as data

@pytest.fixture
def sample() -> Creature:
    return Creature(name="yeti",
        aka="Abominable Snowman",
        country="CN",
        area="Himalayas",
        description="Handsome Himalayan")

def test_create(sample):
    resp = data.create(sample)
    assert resp == sample

def test_create_duplicate(sample):
    resp = data.create(sample)
    assert resp == sample
    with pytest.raises(Duplicate):
        resp = data.create(sample)

def test_get_exists(sample):
    resp = data.create(sample)
    assert resp == sample
    resp = data.get_one(sample.name)
    assert resp == sample

def test_get_missing():
    with pytest.raises(Missing):
        _ = data.get_one("boxturtle")
    
def test_modify(sample):
    sample.country = "CA" # Canada!
    resp = data.modify(sample.name, sample)
    assert resp == sample

def test_modify_missing():
    bob: Creature = Creature(name="bob", country="US", area="*",
        description="some guy", aka="??")
    with pytest.raises(Missing):
        _ = data.modify(bob.name, bob)
```

<br>

<h2>6-5. 데이터 계층 테스트</h2>
<ul>
  <li>
    데이터 계층은 <strong>최하위 계층</strong>으로 더 낮은 계층의 함수를 호출할 염려가 없어 <strong>단독으로 테스트하기 간단</strong>하다.
  </li>
</ul>

```python
# 1. 데이터 계층에 대한 단위 테스트 (test/unit/data/test_creature.py)
#   ● 다른 환경 변수를 설정하여 메모리 전용 인스턴스를 사용하도록 한다.
import os
import pytest
from model.creature import Creature
from error import Missing, Duplicate

# 아래에서 data 모듈을 가져오기 전에 설정한다.
os.environ["CRYPTID_SQLITE_DB"] = ":memoery:"

from data import creature

@pytest.fixture
def sample() -> Creature:
    return Creature(name="yeti",
        aka="Abominable Snowman",
        country="CN",
        area="Himalayas",
        description="Hapless Himalayan")

def test_create(sample):
    resp = creature.create(sample)
    assert resp == sample

def test_create_duplicate(sample):
    with pytest.raises(Duplicate):
        _ = creature.create(sample)

def test_get_one(sample):
    resp = creature.get_one(sample.name)
    assert resp == sample

def test_get_one_missing():
    with pytest.raises(Missing):
        resp = creature.get_one("boxturtle")
    
def test_modify(sample):
    creature.country = "JP" # Japan!
    resp = creature.modify(sample.name, sample)
    assert resp == sample

def test_modify_missing():
    thing: Creature = Creature(name="snurfle",
        description="some thing", country="somewhere")
    with pytest.raises(Missing):
        _ = creature.modify(thing.name, thing)

def test_delete(sample):
    resp = creature.delete(sample.name)
    assert resp is None

def test_delete_missing(sample):
    with pytest.raises(Missing):
        _ = creature.delete(sample.name)
```

<br><br>

<h1>7. 통합 테스트 자동화</h1>
<ul>
  <li>
    통합 테스트는 서로 다른 계층에 있는 코드가 <strong>상호작용을 얼마나 잘 하는지 검증</strong>한다.
  </li>
  <li>
    순차적으로 테스트를 수행해 전체 테스트를 수행할 수 있다는 것과 특정 DB를 통해 테스트 할 수 있음을 언급한다.
  </li>
</ul>

<br><br>

<h1>8. 리포지터리 패턴</h1>
<ul>
  <li>
    리포지터리는 중간에 있는 간단한 인메모리 저장소이다. 
  </li>
  <li>
    리포지터리는 실제 DB에 대해 백엔드와 통신하는 역할을 한다. 백엔드는 플러그인처럼 다룰 수 있다.
  </li>
  <li>
    리포지터리 패턴에 작업 단위 패턴을 적용하여 한 세션 내에서 어떤 작업 그룹이 전체적으로 커핏되거나 롤백되도록 보장할 수 있다.
  </li>
</ul>

<br><br>

<h1>9. 전체 테스트 자동화</h1>
<ul>
  <li>
    전체 테스트는 가능한 한 프로덕션 환경처럼 <strong>모든 계층을 함께 실행</strong>한다.
  </li>
  <li>
    FastAPI는 속성 기반 테스트를 활용하며 이는 FastAPI의 <strong>자동 생성되는 문서</strong>를 이용한다.
  </li>
  <li>
    위 방식을 수행하기 위해서는 Hypothesis와 Schemathesis 두 패키지가 필요하다.
  </li>
</ul>

```python
# 1. main.py
from fastapi import FastAPI
from web import explorer, creature

app = FastAPI()
app.include_router(explorer.router)
app.include_router(creature.router)
```

```bash
# 2. Schemathesis 테스트 실행.
schemathesis run http://localhost:8000/openapi.json
```

<br><br>

<h1>10. 보안 테스트</h1>
<ul>
  <li>
    보안은 평범한 실수, 사용자가 통제할 수 없는 이벤트 등을 포함하는 개념이다.
  </li>
</ul>

<br><br>

<h1>11. 부하 테스트</h1>
<ul>
  <li>
    부하 테스트는 앱이 <strong>무거운 트래픽을 처리</strong>하는 방식을 테스트 한다.
  </li>
    <ul>
      <li>
        API 호출
      </li>
      <li>
        DB 읽기 또는 쓰기
      </li>
      <li>
        메모리 사용
      </li>
      <li>
        디스크 사용
      </li>
      <li>
        네트워크 지연 및 대역폭
      </li>
    </ul>
  <li>
    추천하는 방법으로는 <strong>Locust</strong>가 있다. Locust는 일반 파이썬 스크립트로 모든 테스트를 정의하여 <strong>여러 서버를 접속하는 상황을 시뮬레이션</strong> 할 수 있다. 
  </li>
</ul>