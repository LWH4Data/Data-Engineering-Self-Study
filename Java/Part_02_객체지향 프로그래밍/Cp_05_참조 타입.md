<h1>1. 데이터 타입 분류</h1>
<ul>
  <li>
    Java의 데이터 타입은 <strong>기본 타입(primitive type)</strong>과 <strong>참조 타입(reference type)</strong>으로 분류된다.
  </li>
  <li>
    참조 타입이란 <strong>객체(object)의 번지</strong>를 참조하는 타입으로 배열, 열거, 클래스, 인터페이스 타입이 있다.
  </li>
    <ul>
      <li>
        <strong>객체(object)</strong>: <strong>데이터(필드)</strong>와 <strong>메소드</strong>로 구성된 덩어리라고 생각하면 된다.
      </li>
    </ul>
  <li>
    <strong>기본 타입</strong>으로 선언된 변수는 <strong>값 자체</strong>를 저장하고 있지만 <strong>참조 타입</strong>으로 선언된 변수는 <strong>객체가 생성한 메모리 번지</strong>를 저장한다.
  </li>
  <li>
    변수들은 모두 <strong>stack 영역</strong>에 저장되며 기본 타입은 값 자체를 저장하고 있지만 <strong>참조 타입 변수(String)</strong>는 <strong>heap 메모리 영역의 객체</strong>를 참조한다.
  </li>
</ul>

<br><br>

<h1>2. 메모리 사용 영역</h1>
<ul>
  <li>
    java 명령어로 JVM이 구동되면 <strong>JVM</strong>은 운영체제에서 할당받은 <strong>메모리 영역(Runtime Data Area)을 구분해서 사용</strong>한다.
  </li>
    <ul>
      <li>
        <strong>메소드 영역</strong>
      </li>
        <ul>
          <li>
            <strong>바이트코드 파일</strong>을 읽은 내용이 저장된다.
          </li>
        </ul>
      <li>
        <strong>힙 영역</strong>
      </li>
        <ul>
          <li>
            <strong>객체가 생성</strong>되는 영역.
          </li>
          <li>
            객체의 번지는 메소드 영역과 스택 영역의 상수와 변수에서 <strong>참조</strong>할 수 있다.
          </li>
        </ul>
      <li>
        <strong>스택 영역</strong>
      </li>
        <ul>
          <strong>메소드를 호출</strong>할 때마다 생성되는 <strong>프레임(Prame)</strong>이 저장되는 영역.
        </ul>
        <li>
          호출이 끝나면 프레임은 자동 제거된다.
        </li>
        <li>
          기본 타입 변수와 참조 타입 변수가 생성되고 제거된다.
        </li>
    </ul>
</ul>

<br><br>

<h1>3. 참조 타입 변수의 ==, != 연산</h1>
<ul>
  <li>
    참조 타입에서 ==와 != 연산은 값의 비교가 아니라 <strong>동일한 객체(번지)를 참조</strong>하는지 확인한다. 
  </li>
</ul>

```java
// 1. ReferenceVariableCompareExample.java
package ch05.sec03;

public class ReferenceVariableCompareExample {
  public static void main(String[] args) {
    int[] arr1;    // 배열 변수 arr1 선언
    int[] arr2;    // 배열 변수 arr2 선언
    int[] arr3;    // 배열 변수 arr3 선언
    
    // 배열 { 1, 2, 3 }을 생성하고 arr1 변수에 대입
    arr1 = new int[] { 1, 2, 3 };
    // 배열 { 1, 2, 3 }을 생성하고 arr2 변수에 대입
    arr2 = new int[] { 1, 2, 3 };
    // 배열 변수 arr2의 값을 배열 변수 arr3에 대입
    arr3 = arr2;

    // arr1과 arr2가 같은 배열을 참조하는지 검사
    //   - arr1과 arr2는 개별 값을 갖기에 false가 반환된다.
    System.out.println(arr1 == arr2);
    // arr2와 arr3 변수가 같은 배열을 참조하는지 검사
    //   - arr3은 arr2를 참조하기에 true가 반환된다.
    System.out.println(arr2 == arr3);
  }
}
```

<br><br>

<h1>4. null과 NullPointerException</h1>
<ul>
  <li>
    참조 타입 변수는 아직 번지를 저장하지 않고 있다는 뜻이기에 <strong>null 값</strong>을 가질 수 있다.
  </li>
    <ul>
      <li>
        null로 초기화된 참조 변수는 <strong>스택 영역에 생성</strong>된다.
      </li>
      <li>
        <strong>null과의 비교 연산(==, !=)</strong>을 통해 참조 변수가 null인지 확인할 수 있다.
      </li>
      <li>
        <strong>참조 변수에 null</strong>을 할당하고 <strong>참조하고 있는 번지가 없다면</strong> 참조 변수를 사용하려 할 때 <strong>NullPointerException 예외</strong>가 발생한다.
      </li>
    </ul>
  <li>
    참조 변수에 <strong>다른 값을 할당</strong>하거나 <strong>일부러 null</strong>을 넣으면 <strong>기존의 번지를 잃어 버리고 객체를 사용할 수 없게</strong> 된다.
  </li>
    <ul>
      <li>
        Java는 <strong>Garbage Collector</strong>를 통해 이러한 객체를 제거하여 <strong>메모리를 관리</strong>한다.
      </li>
    </ul>
  <li>
    힙(Heap) 영역에서 <strong>더 이상 어떤 변수(참조)에도 연결되지 않은 객체</strong>(번지)가 가비지 컬렉션(Garbage Collection) 대상이 된다.
  </li>
</ul>

```java
// 1. NullPointerExceptionExample.java
package ch05.sec04;

public class NullPointerExceptionExample {
  public static void main(String[] args) {
    int[] intArray = null;
    // NullPointerException
    // intArray[0] = 10;
    
    String str = null;
    // NullPointerException
    // System.out.println("총 문자 수: " + str.length() );
  }
}
```

```java
// 2. GarbageObjectExample.java
package ch05.sec04;

public class GarbageObjectExample {
  public static void main(String[] args) {
    String hobby = "여행";
    // "여행"에 해당하는 String 객체를 Garbage로 만든다.
    hobby = null;

    String kind1 = "자동차";
    // kind1 변수에 저장되어 있는 번지를 kind2 변수에 대입한다.
    String kind2 = kind1; 
    // "자동차"에 해당하는 String 객체는 kind2에서 사용중이기에 Garbage가 아니다.
    //   - 단지 kind1만 어떠한 변수도 참조하지 않는 null을 갖는 변수가 된다.
    kind1 = null;
    System.out.println("kind2: " + kind2);
  }
}
```

<br><br>

<h1>5. 문자열(String) 타입</h1>
<ul>
  <li>
    Java의 문자열은 <strong>String 객체</strong>로 생성된다.
  </li>
</ul>

<br>

<h2>5-1. 문자열 비교</h2>
<ul>
  <li>
    자바는 <strong>문자열 리터럴이 동일</strong>하다면 <strong>String 객체를 공유(같은 번지를 참조)</strong>하도록 설계되어 있다.
  </li>
  <li>
    <strong>new 연산자</strong>는 <strong>객체 생성 연산자</strong>로 객체를 생성한다.
  </li>
    <ul>
      <li>
        new 연산자는 Heap 영역에 <strong>매번 새로운 객체를 생성</strong>하므로, 같은 내용(값)을 가진 문자열이라도 <strong>new로 생성할 때마다 서로 다른 번지(주소)</strong>를 가지며, <strong>참조 위치</strong> 또한 다르다.
      </li>
    </ul>
  <li>
    문자열에서 비교 연산을 통해 번지를 비교하는 게 아니라 <strong>값을 비교</strong>할 때에는 <strong>equals() 메소드</strong>를 사용한다.
  </li>
  <li>
    String 객체에 <strong>""(빈 문자열)</strong>이나 <strong>" "(공백 문자열)</strong>을 대입하더라도, 해당 문자열은 <strong>힙 영역의 String Constant Pool에 실제 객체로 존재</strong>한다. 따라서 값 비교 시 <strong>equals() 메서드</strong>를 사용할 수 있다.
  </li>
</ul>

```java
// 1. EqualsExample.java
package ch05.sec05;

public class EqualsExample {
  public static void main(String[] args) {
    String strVar1 = "홍길동";
    String strVar2 = "홍길동";

    if(strVar1 == strVar2) {
      System.out.println("strVar1과 strVar2는 참조가 같음.");
    } else {
      System.out.println("strVar1과 strVar2는 참조가 다름.");
    }

    if(strVar1.equals(strVar2)) {
      System.out.println("strVar1과 strVar2는 문자열이 같음.");
    }

    String strVar3 = new String("홍길동");
    String strVar4 = new String("홍길동");

    if(strVar3 == strVar4) {
      System.out.println("strVar3과 strVar4는 참조가 같음.");
    } else {
      System.out.println("strVar3과 strVar4는 참조가 다름.");
    }

    if(strVar3.equals(strVar4)) {
      System.out.println("strVar3과 strVar4는 문자열이 같음");
    }
  }
}
```

```java
// 2. EmptyStringExample.java
package ch05.sec05;

public class EmptyStringExample {
  public static void main(String[] args) {
    String hobby = "";
    if(hobby.equals("")) {
      System.out.println("hobby 변수가 참조하는 String 개체는 빈 문자열");
    }
  }
}
```

<br>

<h2>5-2. 문자 추출</h2>
<ul>
  <li>
    String은 배열이 아니라 <strong>객체</strong>이기에 문자열의 특정 위치의 문자를 얻을 때에는 <strong>charAt() 메서드</strong>를 사용한다.
  </li>
    <ul>
      <li>
        charAt() 메서드는 <strong>인덱스(index)</strong>를 매개변수로 받아, 문자열에서 해당 <strong>인덱스에 위치한 문자를 반환</strong>한다.
      </li>
    </ul>
</ul>

```java
// 1. CharAtExample.java
package ch05.sec05;

public class CharAtExample {
  public static void main(String[] args) {
    String ssn = "9506241230123";
    char sex = ssn.charAt(6);
    switch (sex) {
      case '1':
      case '3':
        System.out.println("남자입니다.");
        break;
      case '2':
      case '4':
        System.out.println("여자입니다.");
        break;
    }
  }
}
```

<br>

<h2>5-3. 문자열 길이</h2>
<ul>
  <li>
    문자열에서 <strong>문자의 개수</strong>를 얻고 싶다면 <strong>length() 메서드</strong>를 사용한다.
  </li>
</ul>

```java
// 1. LengthExample.java
package ch05.sec05;

public class LengthExample {
  public static void main(String[] args) {
    String ssn = "9506241230123";
    int length = ssn.length();
    if(length == 13) {
      System.out.println("주민등록번호 자릿수가 맞습니다.");
    } else {
      System.out.println("주민등록번호 자릿수가 틀립니다.");
    }
  }
}
```

<br>

<h2>5-4. 문자열 대체</h2>
<ul>
  <li>
    문자열에서 <strong>특정 문자열을 다른 문자열로 대체</strong>하고 싶다면 <strong>replace() 메서드</strong>를 사용한다.
  </li>
  <li>
    String 객체의 문자열은 <strong>불변성</strong>을 갖기 때문에 replace() 메서드가 리턴하는 문자열은 원래 문자열의 수정본이 아닌 <strong>완전히 새로운 문자열</strong>이다.
  </li>
    <ul>
      <li>
        즉, 완전히 새로운 문자열을 참조한다.
      </li>
    </ul>
</ul>

```java
// 1. ReplaceExample.java
package ch05.sec05;

public class ReplaceExample {
  public static void main(String[] args) {
    String oldStr = "자바 문자열은 불변입니다. 자바 문자열은 String입니다.";
    String newStr = oldStr.replace("자바", "JAVA");

    System.out.println(oldStr);
    System.out.println(newStr);
  }
}
```

<br>

<h2>5-5. 문자열 잘라내기</h2>
<ul>
  <li>
    문자열에서 <strong>특정 위치의 문자열</strong>을 잘라내어 가져오고 싶다면 <strong>substring() 메서드</strong>를 사용한다.
  </li>
    <ul>
      <li>
        <strong>substring(int beginIndex)</strong>: beginIndex를 포함하여 끝까지 잘란낸다.
      </li>
      <li>
        <strong>substring(int beginIndex, int endIndex)</strong>: beginIndex는 포함하여 endIndex 직전까지 잘라낸다.
      </li>
    </ul>
</ul>

```java
// 1. SubStringExample.java
package ch05.sec05;

public class SubStringExample {
  public static void main(String[] args) {
    String ssn = "880815-1234567";

    String firstNum = ssn.substring(0, 6);
    System.out.println(firstNum);

    String secondNum = ssn.substring(7);
    System.out.println(secondNum);
  }
}
```

<br>

<h2>5-6. 문자열 찾기</h2>
<ul>
  <li>
    문자열에서 <strong>특정 문자열의 위치</strong>를 찾고자 할 때에는 <strong>indexOf() 메서드</strong>를 사용한다.
  </li>
    <ul>
      <li>
        주어진 문자열이 <strong>시작되는 위치</strong>를 반환한다.
      </li>
    </ul>
  <li>
    주어진 <strong>문장열이 포함</strong>되어 있는지만 확인한다면 <strong>contains() 메서드</strong>를 사용한다. 결과는 true 혹은 false를 반환한다.
  </li>
</ul>

```java
// 1. IndexOfContainsExample.java
package ch05.sec05;

public class IndexOfContainsExample {
  public static void main(String[] args) {
    String subject = "자바 프로그래밍";

    int location = subject.indexOf("프로그래밍");
    System.out.println(location);
    String substring = subject.substring(location);
    System.out.println(substring);

    location = subject.indexOf("자바");
    if(location != -1) {
      System.out.println("자바와 관련된 책이군요.");
    } else {
      System.out.println("자바와 관련 없는 책이군요.");
    }
  }
}
```

<br>

<h2>5-7. 문자열 분리</h2>
<ul>
  <li>
    문자열이 <strong>구분자</strong>를 사용하여 <strong>여러 개의 문자열</strong>로 구분되어 있을 경우 <strong>split() 메서드</strong>를 통해 따로 분리해서 얻을 수 있다.
  </li>
</ul>

```java
// 1. SplitExample.java
package ch05.sec05;

public class SplitExample {
  public static void main(String[] args) {
    String board = "1,자바 학습,참조 타입 String을 학습합니다.,홍길동";

    // 문자열 분리
    String[] tokens = board.split(",");

    // 인덱스별로 읽기
    System.out.println("번호: " + tokens[0]);
    System.out.println("제목: " + tokens[1]);
    System.out.println("내용: " + tokens[2]);
    System.out.println("성명: " + tokens[3]);
    System.out.println();

    // for 문을 이용한 읽기
    for(int i=0; i<tokens.length; i++) {
      System.out.println(tokens[i]);
    }
  }
}
```

<br><br>

<h1>6. 배열(Array) 타입</h1>
<ul>
  <li>
    배열은 <strong>연속된 공간에 값을 나열</strong>하고, 각 값에 <strong>인덱스(index)를 부여</strong>해 놓은 자료구조이다.
  </li>
  <li>
    배열은 같은 타입의 값만 관리하며 배열의 길이를 늘리거나 줄일 수 없다.
  </li>
</ul>

<br>

<h2>6-1. 배열 변수 선언</h2>
<ul>
  <li>
    배열 변수 선언은 <strong>타입[] 변수;</strong>와 타입 변수[]; 두 가지 방식을 사용할 수 있지만 첫 번째 방법을 주로 사용한다.
  </li>
  <li>
    배열도 <strong>변수</strong>이기에 <strong>힙 영역에 생성</strong>되고 배열 변수는 힙 영역의 <strong>배열 주소를 저장</strong>한다. 참조할 배열이 없다면 배열 변수도 <strong>null로 초기화</strong>할 수 있다.
  </li>
  <li>
    마찬가지로 배열 변수가 null을 갖는 상태에서 변수[인덱스]로 값을 읽거나 저장하면 <strong>NullPointerException</strong>이 발생한다.
  </li>
</ul>

<br>

<h2>6-2. 값 목록으로 배열 생성</h2>
<ul>
  <li>
    배열은 <strong>타입[] 변수 = { 값0, 값1, 값2, ...};</strong> 형식으로 생성할 수 있다.
  </li>
  <li>
    배열을 힙에 생성하고 번지를 반환하며 배열 변수는 반환된 번지를 저장하여 참조가 이루어진다.
  </li>
  <li>
    배열 변수를 <strong>미리 선언</strong>하고 이후 값을 변수에 대입할 때에는 <strong>new 타입[]</strong>을 사용하여 대입하여야 한다.
  </li>
    <ul>
      <li>
        메서드의 매개변수가 배열 타입인 경우에도 동일하게 new 타입[]을 사용해야 한다.
      </li>
    </ul>
</ul>

```java
// 1. ArrayCreateByValueListExample.java
package ch05.sec06;

public class ArrayCreateByValueListExample {
  public static void main(String[] args) {
    // 배열 변수 선언과 배열 생성
    String[] season = { "Spring", "Summer", "Fall", "Winter" };

    // 배열의 항목값 읽기
    System.out.println("season[0]: " + season[0]);
    System.out.println("season[1]: " + season[1]);
    System.out.println("season[2]: " + season[2]);
    System.out.println("season[3]: " + season[3]);

    // 인덱스 1번 항목의 값 변경
    season[1] = "여름";
    System.out.println("season[1] :" + season[1]);
    System.out.println();

    // 배열 변수 선언과 배열 생성
    int[] scores = { 83, 90, 87 };

    // 총합과 평균 구하기
    int sum = 0;
    for(int i=0; i<3; i++) {
      sum += scores[i];
    }
    System.out.println("총합 : " + sum);
    double avg = (double) sum / 3;
    System.out.println("평균 : " + avg);
  }
}
```

```java
// 2. ArrayCreateByValueListExample2.java
package ch05.sec06;

public class ArrayCreateByValueListExample2 {
  public static void main(String[] args) {
    // 배열 변수 선언
    int[] scores;
    // 배열 변수에 배열을 대입
    scores = new int[] { 83, 90, 87 };
    // 배열 합의 총합을 구하고 출력.
    int sum1 = 0;
    for(int i=0; i<3; i++) {
      sum1 += scores[i];
    }
    System.out.println("총합 : " + sum1);

    // 배열을 매개값으로 주고, printItem() 메서드 호출.
    printItem( new int[] { 83, 90, 87 } );
  }

  // printItem() 메서드 선언
  public static void printItem( int[] scores ) {
    // 매개변수가 참조하는 배열의 항목을 출력
    for(int i=0; i<3; i++) {
      System.out.println("score[" + i + "]: " + scores[i]);
    }
  }
}
```

<br>

<h2>6-3. new 연산자로 배열 생성</h2>
<ul>
  <li>
    값 목록은 없지만 <strong>배열을 미리 생성</strong>할 수도 있다. 이때에는 <strong>new 연산자</strong>를 사용하여 배열 객체를 생성한다.
  </li>
    <ul>
      <li>
        <strong>타입[] 변수 = new 타입[배열의 길이];</strong>
      </li>
    </ul>
  <li>
    new 연산자는 지정한 길이와 타입으로 <strong>배열 객체를 힙 영역에 생성</strong>하고, 그 배열의 <strong>번지(참조값)를 반환</strong>한다. 따라서 배열 변수에 <strong>참조값을 대입</strong>하여 배열을 사용할 수 있다.
  </li>
  <li>
    new 연산자로 배열을 처음 생성하면 배열은 <strong>설정된 데이터 타입</strong>에 맞게 <strong>기본값으로 초기화</strong>된다. (p174 장표 참조).
  </li>
    <ul>
      <li>
        대부분의 타입들은 0, false 그리고 null 중의 하나로 초기화된다.
      </li>
    </ul>
</ul>

```java
// 1. ArrayCreateByNewExample.java
package ch05.sec06;

public class ArrayCreateByNewExample {
  public static void main(String[] args) {
    // 배열 변수 선언과 배열 생성.
    int[] arr1 = new int[3];
    // 배열 항목의 초기값 출력.
    for(int i=0; i<3; i++) {
      System.out.print("arr1[" + i + "] : " + arr1[i] + ", ");
    }
    System.out.println();
    // 배열 항목의 값 변경
    arr1[0] = 10;
    arr1[1] = 20;
    arr1[2] = 30;
    // 배열 항목의 변경 값 출력
    for(int i=0; i<3; i++) {
      System.out.print("arr1[" + i + "] : " + arr1[i] + ", ");
    }
    System.out.println("\n");

    // 배열 변수 선언과 배열 생성
    double[] arr2 = new double[3];
    // 배열 항목 초기값 출력
    for(int i=0; i<3; i++) {
      System.out.print("arr2[" + i + "] : " + arr2[i] + ", ");
    }
    System.out.println();
    // 배열 항목의 값 변경
    arr2[0] = 0.1;
    arr2[1] = 0.2;
    arr2[2] = 0.3;
    // 배열 항목의 변경 값 출력
    for(int i=0; i<3; i++) {
      System.out.print("arr2[" + i + "] : " + arr2[i] + ", ");
    }
    System.out.println("\n");

    // 배열 변수 선언과 배열 생성
    String[] arr3 = new String[3];
    // 배열 항목의 초기값 출력
    for(int i=0; i<3; i++) {
      System.out.print("arr3[" + i + "] : " + arr3[i] + ", ");
    }
    System.out.println();
    // 배열 항목의 값 변환
    arr3[0] = "1월";
    arr3[1] = "2월";
    arr3[2] = "3월";
    // 배열 항목의 변경값 출력
    for(int i=0; i<3; i++) {
      System.out.print("arr3[" + i + "] : " + arr3[i] + ", ");
    }
  }
}
```

<br>

<h2>6-4. 배열 길이</h2>
<ul>
  <li>
    배열의 길이란 <strong>배열에 저장할 수 있는 항목의 수</strong>를 의미하며 <strong>length 필드</strong>를 읽어서 얻을 수 있다.
  </li>
</ul>

```java
// 1. ArrayLengthExample.java
package ch05.sec06;

public class ArrayLengthExample {
  public static void main(String[] args) {
    // 배열 변수 선언과 배열 대입
    int[] scores = { 84, 90, 96 };

    // 배열 항목의 총합 구하기
    int sum = 0;
    for(int i=0; i<scores.length; i++) {
      sum += scores[i];
    }
    System.out.println("총합 : " + sum);
    
    // 배열 항목의 평균 구하기
    double avg = (double) sum / scores.length;
    System.out.println("평균 : " + avg);
  }
}
```

<br><br>

<h1>7. 다차원 배열</h1>
<ul>
  <li>
    배열에 또 다른 배열이 대입되는 경우 이를 <strong>다차원 배열</strong>이라 한다.
  </li>
    <ul>
      <li>
        정확히는 <strong>각 배열의 변수[0]</strong>은 <strong>특정 번지의 배열을 참조</strong>하는 형식으로 구성된다.
      </li>
    </ul>
</ul>

```java
// 1. MultidimensionalArrayByValueListExample.java
package ch05.sec07;

public class MultidimensionalArrayByValueListExample {
  public static void main(String[] args) {
    // 2차원 배열 생성
    int[][] scores = {
      { 80, 90, 96 },
      { 76, 88 }
    };

    // 배열의 길이
    System.out.println("1차원 배열 길이(반의 수): " + scores.length);
    System.out.println("2차원 배열 길이(첫 번째 반의 학생 수): " + scores[0].length);
    System.out.println("2차원 배열 길이(두 번째 반의 학생 수): " + scores[1].length);

    // 첫 번째 반의 세 번째 학생의 점수 읽기
    System.out.println("scores[0][2]: " + scores[0][2]);

    // 두 번째 반의 두 번째 학생의 점수 읽기
    System.out.println("scores[1][1]: " + scores[1][1]);

    // 첫 번째 반의 평균 점수 구하기
    int class1Sum = 0;
    for(int i=0; i<scores[0].length; i++) {
      class1Sum += scores[0][i];
    }
    double class1Avg = (double) class1Sum / scores[0].length;
    System.out.println("첫 번째 반의 평균 점수: " + class1Avg);

    // 두 번째 반의 평균 점수 구하기
    int class2Sum = 0;
    for(int i=0; i<scores[1].length; i++) {
      class2Sum += scores[1][i];
    }
    double class2Avg = (double) class2Sum / scores[1].length;
    System.out.println("두 번째 반의 평균 점수: " + class2Avg);

    // 전체 학생의 평균 점수 구하기
    int totalStudent = 0;
    int totalSum = 0;
    // 반의 수만큼 반복
    for(int i=0; i<scores.length; i++) {
      // 반의 학생 수 합산
      totalStudent += scores[i].length;
      // 해당 반의 학생 수만큼 반복
      for(int k=0; k<scores[i].length; k++) {
        // 학생 점수 합산
        totalSum += scores[i][k];
      } 
    }
    double totalAvg = (double) totalSum / totalStudent;
    System.out.println("전체 학생의 평균 점수: " + totalAvg);
  }
}
```

<br>

<h2>7-1. new 연산자로 다차원 배열 생성</h2>
<ul>
  <li>
    <strong>new 연산자로 다차원 배열을 생성</strong>할 때에는 타입과 new 타입의 뒤에 <strong>차원의 수만큼 []</strong>를 붙인다.
  </li>
</ul>

```java
// 1. MultidimensionalArrayByNewExample.java
package ch05.sec07;

public class MultidimensionalArrayByNewExample {
  public static void main(String[] args) {
    // 각 반의 학생 수가 3명으로 동일할 경우 점수 저장을 위한 2차원 배열 생성
    int[][] mathScores = new int[2][3];
    // 배열 항목 초기값 출력
    // 반의 수만큼 반복
    for(int i = 0; i < mathScores.length; i++) {
      // 해당 반의 학생 수만큼 반복
      for(int k = 0; k < mathScores[i].length; k++) {
        System.out.println("mathScores[" + i + "][" + k  + "]: " + mathScores[i][k]);
      }
    }
    System.out.println();
    // 배열 항목 값 변경
    mathScores[0][0] = 80;
    mathScores[0][1] = 83;
    mathScores[0][2] = 85;
    mathScores[1][0] = 86;
    mathScores[1][1] = 90;
    mathScores[1][2] = 92;
    // 전체 학생의 수학 평균 구하기
    int totalStudent = 0;
    int totalMathSum = 0;
    // 반의 수만큼 반복
    for (int i = 0; i < mathScores.length; i++) {
      // 반의 학생 수 합산
      totalStudent += mathScores[i].length;
      // 해당 반의 학생 수만큼 반복
      for(int k = 0; k < mathScores[i].length; k++) {
        // 학생 점수 합산
        totalMathSum += mathScores[i][k];
      }
    }
    double totalMathAvg = (double) totalMathSum / totalStudent;
    System.out.println("전체 학생의 수학 평균 점수: " + totalMathAvg);
    System.out.println();
    
    // 각 반의 학생 수가 다를 경우 점수 저장을 위한 2차원 배열 생성
    int[][] englishScores = new int[2][];
    englishScores[0] = new int[2];
    englishScores[1] = new int[3];
    // 배열 항목 초기값 출력
    // 반의 수만큼 반복
    for (int i = 0; i < englishScores.length; i++) {
      // 해당 반의 학생 수만큼 반복
      for (int k = 9; k < englishScores[i].length; k++) {
        System.out.println("englishScores[" + i + "][" + k + "]: " + englishScores[i][k]);
      }
    }
    System.out.println();
    // 배열 항목 값 변경
    englishScores[0][0] = 90;
    englishScores[0][1] = 91;
    englishScores[1][0] = 92;
    englishScores[1][1] = 93;
    englishScores[1][2] = 94;
    // 전체 학생의 영어 평균 구하기
    totalStudent = 0;
    int totalEnglishSum = 0;
    // 반의 수만큼 반복
    for (int i = 0; i < englishScores.length; i++) {
      // 반의 학생 수 합산
      totalStudent += englishScores[i].length;
      // 해당 반의 학생 수만큼 반복
      for(int k = 0; k < englishScores[i].length; k++) {
        // 학생 점수 합산
        totalEnglishSum += englishScores[i][k];
      }
    }
    double totalEnglishAvg = (double) totalEnglishSum / totalStudent;
    System.out.println("전체 학생의 영어 평균 점수: " + totalEnglishAvg);
  }
}
```

<br><br>

<h1>8. 객체를 참조하는 배열</h1>
<ul>
  <li>
    <strong>기본 타입(byte, char, short, int, long, float, double, boolan) 배열</strong>은 각 항목에 <strong>값을 직접 저장</strong>하지만 <strong>참조 타입(클래스, 인터페이스) 배열</strong>은 각 항목에 <strong>객체의 번지</strong>를 저장한다.
  </li>
</ul>

```java
// 1. ArrayReferenceObjectExample.java
package ch05.sec08;

public class ArrayReferenceObjectExample {
  public static void main(String[] args) {
    String[] strArray = new String[3];
    strArray[0] = "Java";
    strArray[1] = "Java";
    strArray[2] = new String("Java");

    // 같은 객체 참조 → true
    System.out.println( strArray[0] == strArray[1] );
    // 다른 객체를 참조 → false
    System.out.println( strArray[0] == strArray[2] );
    // 문자열 동일 → true
    System.out.println( strArray[0].equals(strArray[2]) );
  }
}
```

<br><br>

<h1>9. 배열 복사</h1>
<ul>
  <li>
    배열은 <strong>불변성</strong>을 갖는다. 따라서 <strong>더 많은 저장 공간</strong>이 필요하다면 <strong>더 큰 길이의 배열을 생성</strong>하고 이전 배열로부터 <strong>값들을 복사</strong>해야 한다.
  </li>
    <ul>
      <li>
        가장 기본적인 방법은 for 문을 통해 항목을 하나씩 읽어 새로운 배열에 저장하는 것이다.
      </li>
    </ul>
  <li>
    System의 <strong>arraycopy() 메서드</strong>를 사용하면 <strong>한 줄로 배열을 복사</strong>할 수 있다.
  </li>
    <ul>
      <li>
        <strong>System.arraycopy(<원본 배열>, <원본 배열 복사 시작 인덱스>, <새 배열>, <새 배열 붙여넣기 시작 인덱스>, <복사 항목 수>);</strong>
      </li>
    </ul>
</ul>

```java
// 1. ArrayCopyByForExample.java
package ch05.sec09;

public class ArrayCopyByForExample {
  public static void main(String[] args) {
    // 길이 3인 배열
    int[] oldIntArray = { 1, 2, 3 };
    // 길이 5인 배열을 새로 생성
    int[] newIntArray = new int[5];
    // 배열 항목 복사
    for (int i = 0; i < oldIntArray.length; i++) {
      newIntArray[i] = oldIntArray[i]; 
    }
    // 배열 항목 출력
    for (int i = 0; i < newIntArray.length; i++) {
      System.out.print(newIntArray[i] + ", ");
    }
  }
}
```

```java
// 2. ArrayCopyExample.java
package ch05.sec09;

public class ArrayCopyExample {
  public static void main(String[] args) {
    // 길이 3인 배열
    String[] oldStrArray = { "java", "array", "copy" };
    // 길이 5인 배열을 새로 생성
    String[] newStrArray = new String[5];
    // 배열 항목 복사
    //   - 복사할 배열, 복사 시작 인덱스, 복사 적용 배열, 복사 적용 시작 인덱스, 복사 항목 
    //     수
    System.arraycopy( oldStrArray, 0, newStrArray, 0, oldStrArray.length);
    // 배열 항목 출력
    for(int i = 0; i < newStrArray.length; i++) {
      System.out.print(newStrArray[i] + ", ");
    }
  }
}
```

<br><br>

<h1>10. 배열 항목 반복을 위한 향상된 for 문</h1>
<ul>
  <li>
    Java에서는 for 문을 사용할 때 카운터 변수와 증감식을 사용하지 않고 <strong>배열의 항목 개수만큼 반복</strong>한 후 자동으로 종료되는 방식을 지원한다.
  </li>
    <ul>
      <li>
        for ( 타입 변수; 배열)
      </li>
    </ul>
</ul>

```java
// 1. AdvancedForExample.java
package ch05.sec10;

public class AdvancedForExample {
  public static void main(String[] args) {
    // 배열 변수 선언과 배열 생성
    int[] scores = { 95, 71, 84, 93, 87 };
    // 배열 항목 전체 합 구하기
    int sum = 0;
    // 항목들이 누적합 된다.
    for (int socre : scores) {
      sum = sum + socre;
    }
    System.out.println("점수 총합 = " + sum);
    // 배열 항목 전체 평균 구하기
    double avg = (double) sum / scores.length;
    System.out.println("점수 평균 = " + avg);
  }
}
```

<br><br>

<h1>11. main() 메소드의 String[] 매개변수 용도</h1>
<ul>
  <li>
    <strong>String[] args</strong>는 프로그램 실행 시 전달받는 문자열 인자들을 저장하는 배열로, <strong>main 메서드의 매개변수</strong> 역할을 한다.
  </li>
  <li>
    이클립스에서 입력값을 줄 때에는 다음과 같다. 
    <br>→ [Run] - [Run Configurations]를 선택한 다.
    <br>→ Project 입력란에 'thisisjava'를, Main class 입력란에 입력값을 전달한 클래스를 설정한다.
    <br>→ [Arguments] 탭을 클릭하고 Program arguments 입력란에 입력값을 입력한다.
  </li>
  <li>
    명령 프롬프트 혹은 터미널에서 입력값을 줄 경우에는 thisisjava 프로젝트의 <strong>bin 폴더</strong>까지 이동한 뒤 <strong>java <패키지명><클래스명><입력값(들)></strong> 순으로 입력한다.
  </li>
</ul>

```java
// 1. MainStringArrayArgument.java
package ch05.sec11;

public class MainStringArrayArgument {
  public static void main(String[] args) {
    if(args.length != 2) {
      System.out.println("프로그램 입력값이 부족");
      System.exit(0);
    }

    String strNum1 = args[0];
    String strNum2 = args[1];

    int num1 = Integer.parseInt(strNum1);
    int num2 = Integer.parseInt(strNum2);

    int result = num1 + num2;
    System.out.print(num1 + " + " + num2 + " = " + result);
  }
}
```

<br><br>

<h1>12. 열거(Enum) 타입</h1>
<ul>
  <li>
    데이터 중에는 몇 가지 <strong>한정된 값</strong>을 갖는 경우가 있는데 이렇게 한정된 값을 갖는 타입을 <strong>열거 타입(enumeration type)</strong>이라 한다.
  </li>
  <li>
    열거 타입을 사용하기 위해서는 먼저 열거 타입 이름으로 <strong>소스파일(.java)을 생성</strong>하고 한정된 값을 <strong>코드로 정의</strong> 해야한다.
  </li>
    <ul>
      <li>
        열거 타입 이름은 <strong>첫 문자를 대문자</strong>로 하고 <strong>캐멀(camel) 스타일</strong>로 작성한다.
      </li>
    </ul>
  <li>
    교재 내용을 따라 열거 타입 Week을 생성.
  </li>
  <li>
    <strong>열거 상수</strong>는 열거 타입으로 사용할 수 있는 <strong>한정된 값</strong>을 의미한다.
  </li>
  <li>
    열거 상수가 <strong>여러 단어</strong>로 구성된다면 단어와 단어 사이를 <strong>언더바(_)로 연결</strong>하는 것이 관례이다.
  </li>
  <li>
    열거 타입도 <strong>하나의 데이터 타입</strong>이므로 <strong>변수를 선언</strong>하고 사용해야 한다.
  </li>
  <li>
    열거 타입은 참조 타입이기에 <strong>null</strong>도 대입할 수 있다.
  </li>
  <li>
    열거 변수의 값이 특정 열거 상수인지 비교할 때에는 <strong>==</strong>와 <strong>!= 연산자</strong>를 사용한다.
  </li>
  <li>
    컴퓨터의 날짜 및 요일, 시간을 얻을 때에는 Calendar를 활용한다.
  </li>
</ul>

```java
// 1. WeekExample.java
package ch05.sec12;

// Calendar는 java.util 패키지에 있기에 import가 필요하다.
import java.util.Calendar;

public class WeekExample {
  public static void main(String[] args) {
    // Week 열거 타입 변수 선언
    Week today = null;

    // Calendar 열기
    Calendar cal = Calendar.getInstance();

    // 오늘의 요일 얻기(1 ~ 7)
    int week = cal.get(Calendar.DAY_OF_WEEK);

    // 숫자를 열거 상수로 변환해서 변수에 대입
    switch(week) {
      case 1: today = Week.SUNDAY    ;    break;
      case 2: today = Week.MONDAY    ;    break;
      case 3: today = Week.TUESDAY   ;    break;
      case 4: today = Week.WEDNESDAY ;    break;
      case 5: today = Week.THURSDAY  ;    break;
      case 6: today = Week.FRIDAY    ;    break;
      case 7: today = Week.SATURDAY  ;    break;
    }

    // 열거 타입 변수를 사용
    if(today == Week.SUNDAY) {
      System.out.println("일요일에는 축구를 합니다.");
    } else {
      System.out.println("열심히 자바를 공부합니다.");
    }
  }
}
```