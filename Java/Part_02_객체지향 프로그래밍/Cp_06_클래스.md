<h1>1. 객체지향 프로그래밍</h1>
<ul>
  <li>
    소프트웨어를 개발할 때 <strong>부품에 해당하는 객체</strong>를 먼저 만들고, 해당 객체를 하나씩 <strong>조립</strong>해서 완성된 프로그램을 만드는 기법을 <strong>객체지향 프로그래밍(Ojbect Oriented Programming, OOP)</strong>이라 한다.
  </li>
</ul>

<br>

<h2>1-1. 객체란?</h2>
<ul>
  <li>
    <strong>객체(object)</strong>란 물리적으로 존재하거나 개념적인 것 중에서 <strong>다른 것과 식별 가능한 것</strong>을 의미한다.
  </li>
  <li>
    객체는 <strong>속성</strong>과 <strong>동작</strong>으로 구성된다. 
  </li>
    <ul>
      <li>
        속성은 <strong>필드(field)</strong>라 하고, 동작은 <strong>메서드(method)</strong>라 한다.
      </li>
      <li>
        편하게 이해하는 방법은 필드란 <strong>변수 선언 단계</strong>를 의미하고, 메서드란 <strong>함수 작성 단계</strong>라 이해할 수 있다.
      </li>
    </ul>
  <li>
    현실 세계의 객체를 소프트웨어 객체로 설계하는 것을 <strong>모델링(object modeling)</strong>이라 한다.
  </li>
</ul>

<br>

<h2>1-2. 객체의 상호작용</h2>
<ul>
  <li>
    현실 세계의 모든 현상은 <strong>객체와 객체 간의 상호작용</strong>으로 이루어진다. 객체지향 프로그램에서 상호작용은 <strong>메서드</strong>를 의미하며 객체 간의 기능을 이용할 때 메서드를 호출한다.
  </li>
    <ul>
      <li>
        메서드 호출 시 객체들은 데이터를 주고받는데 <strong>메서드 이름</strong>과 <strong>매개값</strong>을 주고 받는다.
      </li>
      <li>
        <strong>매개값</strong>이란 메서드가 <strong>실행할 때 필요한 값</strong>이며 <strong>리턴값</strong>은 메서드의 <strong>실행 결과</strong>이고, 호출한 곳으로 <strong>돌려주는 값</strong>이다.
      </li>
    </ul>
</ul>

<br>

<h2>1-3. 객체 간의 관계</h2>
<ul>
  <li>
    객체는 단독으로 존재할 수 있지만 대부분 <strong>다른 객체와 관계</strong>를 맺고 있다.
  </li>
</ul>

<h3>1-3-1. 집합 관계</h3>
<ul>
  <li>
    집합 관계란 <strong>완성품</strong>과 <strong>부품</strong>의 관계를 의미한다.
  </li>
</ul>

<h3>1-3-2. 사용 관계</h3>
<ul>
  <li>
    <strong>다른 객체의 필드</strong>를 읽고 변경하거나 <strong>메서드를 호출</strong>하는 관계를 의미한다.
  </li>
</ul>

<h3>1-3-3. 상속 관계</h3>
<ul>
  <li>
    <strong>부모와 자식 관계</strong>를 의미한다.
  </li>
</ul>

<br>

<h2>1-4. 객체지향 프로그래밍의 특징</h2>
<h3>1-4-1. 캡슐화</h3>
<ul>
  <li>
    <strong>캡슐화(Encapsulation)</strong>란 객체의 데이터(필드), 동작(메서드)을 <strong>하나로 묶고</strong> 실제 구현 내용을 <strong>외부에 감추는 것을 의미</strong>한다.
  </li>
  <li>
    외부에 감추는 이유는 외부의 잘못된 사용으로 인해 <strong>객체가 손상</strong>되지 않도록 하기 위함이다.
  </li>
  <li>
    Java는 캡슐화된 멤버를 노출시킬 것인지 숨길 것인지 결정하기 위해 <strong>접근 제한자(Access Modifier)</strong>를 사용한다.
  </li>
</ul>

<h3>1-4-2. 상속</h3>
<ul>
  <li>
    객체 지향에서는 부모 역할의 <strong>상위 객체</strong>와 자식 역할의 <strong>하위 객체</strong>가 있다.
  </li>
  <li>
    부모 객체는 자신이 갖는 필드와 메서드를 자식 객체가 사용할 수 있도록 물려주는데 이를 <strong>상속(Inheritance)</strong>이라 한다.
  </li>
  <li>
    상속을 하는 이유는 두 가지로 첫 번째는 <strong>코드의 재사용성</strong>을 높여 준다는 것이고, 두 번째는 <strong>유지 보수 시간을 최소화</strong> 시켜준다는 것이다.
  </li>
</ul>

<h3>1-4-3. 다형성</h3>
<ul>
  <li>
    <strong>다형성(Polymorphism)</strong>이란 사용 방법은 동일하지만 <strong>실행 결과가 다양하게 나오는 성질</strong>을 의미한다. 
  </li>
    <ul>
      <li>
        프로그램을 구성하는 <strong>객체</strong>를 바꾸면 프로그램의 <strong>실행 성능</strong>이 다르게 나올 수 있다.
      </li>
    </ul>
  <li>
    다형성을 구현하기 위해서는 자동 타입 변환과 재정의 가술이 필요하며 7장 상속과 8장 인터페이스에서 설명한다.
  </li>
</ul>

<br><br>

<h1>2. 객체와 클래스</h1>
<ul>
  <li>
    객체를 생성할 때에는 <strong>설계도</strong>가 필요하며 설계도에 해당하는 것이 <strong>클래스(class)</strong>이다.
  </li>
  <li>
    클래스로부터 생성된 객체를 해당 클래스의 <strong>인스턴스(instance)</strong>라 하며 클래스로부터 객체를 만드는 과정을 <strong>인스턴스화</strong>라 한다.
  </li>
    <ul>
      <li>
        동일한 클래스로 <strong>여러 개의 인스턴스를 생성</strong>할 수 있다.
      </li>
    </ul>
</ul>

<br><br>

<h1>3. 클래스 선언</h1>
<ul>
  <li>
    클래스 선언은 <strong>소스 파일명</strong>과 동일하게 작성한다.
  </li>
  <li>
    <strong>public class</strong>는 <strong>공개 클래스를 선언</strong>한다는 의미이며 클래스명은 <strong>첫 문자를 대문자</strong>로 하고 <strong>캐멀 스타일</strong>로 작성한다.
  </li>
  <li>
    하나의 파일은 <strong>복수 개의 클래스 선언</strong>을 포함할 수 있다.
  </li>
    <ul>
      <li>
        복수 개의 클래스 선언이 포함된 소프 파일을 컴파일하면 바이트코드 파일(.class)은 <strong>클래스 선언 수만큼</strong> 생성된다.
      </li>
      <li>
        단, 복수 개의 클래스를 선언할 때에는 <strong>파일명과 동일한 클래스</strong>만 <strong>공개 클래스(public class)</strong>로 선언할 수 있다.
      </li>
      <li>
        따라서 가급적 소스 파일 하나당 클래스 하나를 선언하는 것이 좋다.
      </li>
    </ul>
  <li>
    공개 클래스(public class)란 <strong>어느 위치에서든 패키지와 상관없이 사용할 수 있는 클래스</strong>를 의미한다.
  </li>
</ul>

<br><br>

<h1>4. 객체 생성과 클래스 변수</h1>
<ul>
  <li>
    클래스로부터 객체를 생성하려면 <strong>new 연산자</strong>가 필요하다.
  </li>
  <li>
    new 연산자 뒤에는 생성자 호출 코드가 오며 <strong>클래스() 형태</strong>를 갖는다.
  </li>
  <li>
    new 연산자는 <strong>메모리에 객체를 생성</strong>하고 JVM의 <strong>Heap 영역에 클래스 인스턴스</strong>를 생성한다.
  </li>
  <li>
    메모리에 생성된 객체는 <strong>메모리 주소</strong>를 가지며 new 연산자는 해당 <strong>메모리 주소를 리턴</strong>한다.
  </li>
  <li>
    따라서 클래스 타입의 변수에는 <strong>객체의 주소(참조값)가 대입</strong>된다.
  </li>
  <li>
    클래스의 두 가지 용도는 다음과 같다.
  </li>
    <ul>
      <li>
        <strong>라이브러리(library) 클래스</strong>: 실행할 수 없으며 <strong>다른 클래스에서 이용</strong>하는 클래스.
      </li>
      <li>
        <strong>실행 클래스</strong>: <strong>main() 메서드</strong>를 갖고 있는 <strong>실행 가능한 클래스</strong>.
      </li>
    </ul>
  <li>
    일반적으로 자바 프로그램은 <strong>하나의 실행 클래스</strong>와 <strong>다수의 라이브러리 클래스</strong>들로 구성되며 실행 클래스는 실행 하면서 라이브러리 클래스를 <strong>내부에서 이용</strong>한다.
  </li>
</ul>

```java
// 1. Student.java
//   - Student 클래스 선언
package ch06.sec04;

public class Student {

}
```

```java
// 2. StudentExample.java
package ch06.sec04;

public class StudentExample {
  public static void main(String[] args) {
    Student s1 = new Student();
    System.out.println("s1 변수가 Student 객체를 참조합니다.");

    Student s2 = new Student();
    System.out.println("s2 변수가 또 다른 Student 객체를 참조합니다.");
  }
}
```

<br><br>

<h1>5. 클래스의 구성 멤버</h1>
<h2>5-1. 필드</h2>
<ul>
  <li>
    <strong>필드(Feild)</strong>는 <strong>객체의 데이터를 저장</strong>하는 역할을 한다.
  </li>
  <li>
    선언 형태는 변수 선언과 비슷하지만 쓰임새가 다르다.
  </li>
</ul>

<br>

<h2>5-2. 생성자</h2>
<ul>
  <li>
    <strong>생성자(Constructor)</strong>는 <strong>new 연산자</strong>로 객체를 생성할 때 <strong>객체의 초기화 역할</strong>을 수행한다.
  </li>
  <li>
    선언 형태는 메서드와 비슷하지만, <strong>리턴 타입이 없고</strong> 이름은 <strong>클래스 이름과 동일</strong>하다.
  </li>
</ul>

<br>

<h2>5-3. 메소드</h2>
<ul>
  <li>
    메서드(Method)는 <strong>객체가 수행할 동작</strong>이다. 
  </li>
  <li>
    다른 언어에서는 함수라하지만 <strong>객체 내부의 함수는 메서드</strong>라 부른다.
  </li>
  <li>
    <strong>객체와 객체간의 상호작용</strong>을 위해 호출된다.
  </li>
</ul>

<br><br>

<h1>6. 필드 선언과 사용</h1>
<ul>
  <li>
    필드는 <strong>객체의 데이터를 저장</strong>하며 <strong>고유 데이터, 현재 상태 데이터 그리고 부품 데이터</strong>가 있다.
  </li>
  <li>
    필드 선언은 변수 선언과 동일하지만 반드시 <strong>클래스 블록에서 선언</strong>되어야 한다.
  </li>
  <li>
    <strong>로컬변수</strong>는 <strong>생성자와 메서드 블록</strong>에서 선언되어 생성자와 메서드 <strong>호출 시</strong>에만 생성되고 사용되지만, <strong>필드</strong>는 클래스 블록에 선언되어 객체 내부에 존재하며 <strong>객체 내부와 외부 모두 사용 가능</strong>하다.
  </li>
  <li>
    초기값을 제공하지 않을 경우 필드는 객체 생성 시 <strong>자동으로 기본값을 초기화</strong> 한다. (p216 장표 참고).
  </li>
</ul>

```java
// 1. Car.java
//   - 클래스 생성.
package ch06.sec06.exam01;

public class Car {
  // 필드 선언
  String model;
  boolean start;
  int speed;
}
```

```java
// 2. CarExample.java
package ch06.sec06.exam01;

public class CarExample {
  public static void main(String[] args) {
    // Car 객체 생성
    Car myCar = new Car();

    // Car 객체의 필드값 읽기
    System.out.println("모델명: " + myCar.model);
    System.out.println("시동여부: " + myCar.start);
    System.out.println("현재속도: " + myCar.speed);
  }
}
```

<br>

<h2>6-1. 필드 사용</h2>
<ul>
  <li>
    필드를 사용한다는 의미는 <strong>필드값을 읽고 변경</strong>하는 것을 의미한다.
  </li>
  <li>
    필드는 객체의 데이터이기에 객체가 존재하지 않으면 필드도 존재하지 않는다. 따라서 클래스로부터 <strong>객체가 생성된 후</strong>에 필드를 사용할 수 있다.
  </li>
    <ul>
      <li>
        필드는 객체 내부의 <strong>생성자</strong>와 <strong>메서드 내부</strong>에서 사용할 수 있으며 <strong>객체 외부에서도 접근</strong>하여 사용할 수 있다.
      </li>
    </ul>
  <li>
    <strong>객체 내부</strong>에서는 단순히 <strong>필드명</strong>으로 읽고 변경할 수 있지만, <strong>외부 객체</strong>에서는 <strong>참조 변수와 도트(.) 연산자</strong>를 이용해 필드를 읽고 변경해야 한다.
  </li>
    <ul>
      <li>
        도트 연산자(.)는 <strong>객체 접근 연산자</strong>로 객체가 갖고 있는 필드나 메소드에 접근하고자 할 때 <strong>참조 변수 뒤</strong>에 붙인다.
      </li>
    </ul>
</ul>

```java
// 1. Car.java
package ch06.sec06.exam02;

public class Car {
  // 필드 선언
  String company = "현대자동차";
  String model = "그랜저";
  String color = "검정";
  int maxSpeed = 350;
  int speed;
}
```

```java
// 2. CarExample.java
package ch06.sec06.exam02;

public class CarExample {
  public static void main(String[] args) {
    // Car 객체 생성
    Car myCar = new Car();

    // Car 객체의 필드값 읽기
    System.out.println("제작회사: " + myCar.company);
    System.out.println("모델명: " + myCar.model);
    System.out.println("색깔: " + myCar.color);
    System.out.println("최고속도: " + myCar.maxSpeed);
    System.out.println("현재속도: " + myCar.speed);

    // Car 객체의 필드값 변경
    myCar.speed = 60;
    System.out.println("수정된 속도: " + myCar.speed);
  }
}
```

<br><br>

<h1>7. 생성자 선언과 호출</h1>
<ul>
  <li>
    <strong>new 연산자</strong>는 객체를 생성한 후 <strong>생성자(Constructor)를 호출</strong>해서 <strong>객체를 초기화</strong>하는 역할을 수행한다.
  </li>
    <ul>
      <li>
        객체 초기화란 <strong>필드 초기화</strong>를 하거나 <strong>메서드를 호출</strong>해서 객체를 사용할 준비를 하는 것을 의미한다.
      </li>
    </ul>
  <li>
    생성자가 실행되면 new 연산자는 <strong>객체의 주소</strong>를 반환한다.
  </li>
  <li>
    반환된 주소는 클래스 변수에 대입되어 <strong>객체의 필드나 메서드에 접근</strong>할 때 이용된다.
  </li>
</ul>

<br>

<h2>7-1. 기본 생성자</h2>
<ul>
  <li>
    모든 클래스에는 생성자가 존재하며 하나 이상의 생성자를 가질 수 있다. 만약 생성자가 없다면 컴파일러는 <strong>기본 생성자(Default Constructor)</strong>를 바이트코드 파일에 자동으로 추가한다.
  </li>
  <li>
    클래스가 <strong>public class</strong>로 선언되면 기본 생성자도 public 이지만 <strong>class</strong>로만 선언되면 생성자도 public이 붙지 않는다.
  </li>
</ul>

<br>

<h2>7-2. 생성자 선언</h2>
<ul>
  <li>
    객체를 <strong>다양하게 초기화</strong>하기 위해서 개발자는 생성자를 직접 선언할 수 있다.
  </li>
  <li>
    생성자는 메서드와 비슷한 모양을 갖고 있지만, <strong>리턴 타입</strong>이 없고 <strong>클래스 이름과 동일</strong>하다.
  </li>
  <li>
    <strong>매개변수</strong>는 new 연산자로 생성자를 호출할 때 <strong>매개값을 생성자 블록 내부로 전달</strong>하는 역할을 한다.
  </li>
    <ul>
      <li>
        생성자가 <strong>선언된 순서</strong>대로 매개변수에 값이 전달된다.
      </li>
    </ul>
</ul>

```java
// 1. Car.java
package ch06.sec07.exam01;

public class Car {
  // 생성자 선언
  Car(String model, String color, int maxSpeed); {
  }
}
```

```java
// 2. CarExample.java
package ch06.sec07.exam01;

public class CarExample {
  public static void main(String[] args) {
    Car myCar = new Car("그랜저", "검정", 250);
    // 사용자가 명시적으로 생성자를 정의하였기에 컴파일러가 자동으로 생성자를 만들지 않는다.
    // → 따라서 아래와 같은 코드로 기본 생성자를 호출할 수 없다.
    // Car myCar = new Car();
  }
}
```

<br>

<h2>7-3. 필드 초기화</h2>
<ul>
  <li>
    객체마다 <strong>동일한 값</strong>을 갖고 있다면 <strong>필드 선언 시 초기값을 대입</strong>하는 것이 좋고, 객체마다 <strong>다른 값</strong>을 가져야 한다면 <strong>생성자에서 필드를 초기화</strong>하는 것이 좋다.
  </li>
    <ul>
      <li>
        필드에서 초기화를 하지 않았다면 생성자의 매개값은 <strong>new 연산자로 생성자를 호출할 때</strong> 주어진다.
      </li>
    </ul>
  <li>
    매개변수 이름이 너무 짧으면 가독성이 좋지 않아 보통 <strong>초기화시킬 필드명과 동일한 이름</strong>을 사용한다.
  </li>
    <ul>
      <li>
        매개변수명이 필드명과 동일한 경우 필드임을 구분하기 위해 <strong>this 키워드를 필드명 앞</strong>에 붙인다.
      </li>
      <li>
        <strong>this</strong>는 현재 객체 자신을 참조하는 키워드이다.
      </li>
      <li>
        클래스 내부에서 자신의 필드나 메서드를 명시적으로 가리킬 때 사용한다.
      </li>
      <li>
        필드명과 매개변수명이 동일한 경우, 필드임을 구분하기 위해 <strong>this</strong> 키워드를 필드명 앞에 붙인다.
      </li>
      <li>
        <strong>this</strong>는 클래스 자체가 아닌, <strong>현재 생성된 객체(instance)</strong>를 의미한다.
      </li>
      <li>
        <strong>this</strong>는 클래스 내부에서만 사용 가능하며, <strong>외부나 static 메서드에서는 사용할 수 없다.</strong>
      </li>
    </ul>
  <li>
    자동(기본) 초기값은 “값은 있지만 의미가 없기” 때문에, 실제 프로그램에서는 우리가 의도한 상태를 보장하기 위해 직접 초기화해야 한다.
  </li>
</ul>

```java
// 1. Korean.java
package ch06.sec07.exam02;

public class Korean {
  // 필드 선언
  String nation = "대한민국";
  String name;
  String ssn;

  // 생성자 선언. (public X).
  public Korean(String n, String s) {
    name = n;
    ssn = s;
  }
}
```

```java
// 2. KoreanExample.java
package ch06.sec07.exam02;

public class KoreanExample {
  public static void main(String[] args) {
    // Korean 객체 생성.
    Korean k1 = new Korean("박자바", "011225-1234567");
    // Korean 객체 데이터 읽기
    System.out.println("k1.nation : " + k1.nation);
    System.out.println("k1.name : " + k1.name);
    System.out.println("k1.ssn : " + k1.ssn);
    System.out.println();

    // 또 다른 Korean 객체 생성
    Korean k2 = new Korean("김자바", "930525-0654321");
    // 또 다른 Korean 객체 데이터 읽기
    System.out.println("k2.nation : " + k2.nation);
    System.out.println("k2.name : " + k2.name);
    System.out.println("k2.ssn : " + k2.ssn)
  }
}
```