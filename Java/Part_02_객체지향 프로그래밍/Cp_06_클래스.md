<h1>1. 객체지향 프로그래밍</h1>
<ul>
  <li>
    소프트웨어를 개발할 때 <strong>부품에 해당하는 객체</strong>를 먼저 만들고, 해당 객체를 하나씩 <strong>조립</strong>해서 완성된 프로그램을 만드는 기법을 <strong>객체지향 프로그래밍(Ojbect Oriented Programming, OOP)</strong>이라 한다.
  </li>
</ul>

<br>

<h2>1-1. 객체란?</h2>
<ul>
  <li>
    <strong>객체(object)</strong>란 물리적으로 존재하거나 개념적인 것 중에서 <strong>다른 것과 식별 가능한 것</strong>을 의미한다.
  </li>
  <li>
    객체는 <strong>속성</strong>과 <strong>동작</strong>으로 구성된다. 
  </li>
    <ul>
      <li>
        속성은 <strong>필드(field)</strong>라 하고, 동작은 <strong>메서드(method)</strong>라 한다.
      </li>
      <li>
        편하게 이해하는 방법은 필드란 <strong>변수 선언 단계</strong>를 의미하고, 메서드란 <strong>함수 작성 단계</strong>라 이해할 수 있다.
      </li>
    </ul>
  <li>
    현실 세계의 객체를 소프트웨어 객체로 설계하는 것을 <strong>모델링(object modeling)</strong>이라 한다.
  </li>
</ul>

<br>

<h2>1-2. 객체의 상호작용</h2>
<ul>
  <li>
    현실 세계의 모든 현상은 <strong>객체와 객체 간의 상호작용</strong>으로 이루어진다. 객체지향 프로그램에서 상호작용은 <strong>메서드</strong>를 의미하며 객체 간의 기능을 이용할 때 메서드를 호출한다.
  </li>
    <ul>
      <li>
        메서드 호출 시 객체들은 데이터를 주고받는데 <strong>메서드 이름</strong>과 <strong>매개값</strong>을 주고 받는다.
      </li>
      <li>
        <strong>매개값</strong>이란 메서드가 <strong>실행할 때 필요한 값</strong>이며 <strong>리턴값</strong>은 메서드의 <strong>실행 결과</strong>이고, 호출한 곳으로 <strong>돌려주는 값</strong>이다.
      </li>
    </ul>
</ul>

<br>

<h2>1-3. 객체 간의 관계</h2>
<ul>
  <li>
    객체는 단독으로 존재할 수 있지만 대부분 <strong>다른 객체와 관계</strong>를 맺고 있다.
  </li>
</ul>

<h3>1-3-1. 집합 관계</h3>
<ul>
  <li>
    집합 관계란 <strong>완성품</strong>과 <strong>부품</strong>의 관계를 의미한다.
  </li>
</ul>

<h3>1-3-2. 사용 관계</h3>
<ul>
  <li>
    <strong>다른 객체의 필드</strong>를 읽고 변경하거나 <strong>메서드를 호출</strong>하는 관계를 의미한다.
  </li>
</ul>

<h3>1-3-3. 상속 관계</h3>
<ul>
  <li>
    <strong>부모와 자식 관계</strong>를 의미한다.
  </li>
</ul>

<br>

<h2>1-4. 객체지향 프로그래밍의 특징</h2>
<h3>1-4-1. 캡슐화</h3>
<ul>
  <li>
    <strong>캡슐화(Encapsulation)</strong>란 객체의 데이터(필드), 동작(메서드)을 <strong>하나로 묶고</strong> 실제 구현 내용을 <strong>외부에 감추는 것을 의미</strong>한다.
  </li>
  <li>
    외부에 감추는 이유는 외부의 잘못된 사용으로 인해 <strong>객체가 손상</strong>되지 않도록 하기 위함이다.
  </li>
  <li>
    Java는 캡슐화된 멤버를 노출시킬 것인지 숨길 것인지 결정하기 위해 <strong>접근 제한자(Access Modifier)</strong>를 사용한다.
  </li>
</ul>

<h3>1-4-2. 상속</h3>
<ul>
  <li>
    객체 지향에서는 부모 역할의 <strong>상위 객체</strong>와 자식 역할의 <strong>하위 객체</strong>가 있다.
  </li>
  <li>
    부모 객체는 자신이 갖는 필드와 메서드를 자식 객체가 사용할 수 있도록 물려주는데 이를 <strong>상속(Inheritance)</strong>이라 한다.
  </li>
  <li>
    상속을 하는 이유는 두 가지로 첫 번째는 <strong>코드의 재사용성</strong>을 높여 준다는 것이고, 두 번째는 <strong>유지 보수 시간을 최소화</strong> 시켜준다는 것이다.
  </li>
</ul>

<h3>1-4-3. 다형성</h3>
<ul>
  <li>
    <strong>다형성(Polymorphism)</strong>이란 사용 방법은 동일하지만 <strong>실행 결과가 다양하게 나오는 성질</strong>을 의미한다. 
  </li>
    <ul>
      <li>
        프로그램을 구성하는 <strong>객체</strong>를 바꾸면 프로그램의 <strong>실행 성능</strong>이 다르게 나올 수 있다.
      </li>
    </ul>
  <li>
    다형성을 구현하기 위해서는 자동 타입 변환과 재정의 가술이 필요하며 7장 상속과 8장 인터페이스에서 설명한다.
  </li>
</ul>

<br><br>

<h1>2. 객체와 클래스</h1>
<ul>
  <li>
    객체를 생성할 때에는 <strong>설계도</strong>가 필요하며 설계도에 해당하는 것이 <strong>클래스(class)</strong>이다.
  </li>
  <li>
    클래스로부터 생성된 객체를 해당 클래스의 <strong>인스턴스(instance)</strong>라 하며 클래스로부터 객체를 만드는 과정을 <strong>인스턴스화</strong>라 한다.
  </li>
    <ul>
      <li>
        동일한 클래스로 <strong>여러 개의 인스턴스를 생성</strong>할 수 있다.
      </li>
    </ul>
</ul>

<br><br>

<h1>3. 클래스 선언</h1>
<ul>
  <li>
    클래스 선언은 <strong>소스 파일명</strong>과 동일하게 작성한다.
  </li>
  <li>
    <strong>public class</strong>는 <strong>공개 클래스를 선언</strong>한다는 의미이며 클래스명은 <strong>첫 문자를 대문자</strong>로 하고 <strong>캐멀 스타일</strong>로 작성한다.
  </li>
  <li>
    하나의 파일은 <strong>복수 개의 클래스 선언</strong>을 포함할 수 있다.
  </li>
    <ul>
      <li>
        복수 개의 클래스 선언이 포함된 소프 파일을 컴파일하면 바이트코드 파일(.class)은 <strong>클래스 선언 수만큼</strong> 생성된다.
      </li>
      <li>
        단, 복수 개의 클래스를 선언할 때에는 <strong>파일명과 동일한 클래스</strong>만 <strong>공개 클래스(public class)</strong>로 선언할 수 있다.
      </li>
      <li>
        따라서 가급적 소스 파일 하나당 클래스 하나를 선언하는 것이 좋다.
      </li>
    </ul>
  <li>
    공개 클래스(public class)란 <strong>어느 위치에서든 패키지와 상관없이 사용할 수 있는 클래스</strong>를 의미한다.
  </li>
</ul>

<br><br>

<h1>4. 객체 생성과 클래스 변수</h1>
<ul>
  <li>
    클래스로부터 객체를 생성하려면 <strong>new 연산자</strong>가 필요하다.
  </li>
  <li>
    new 연산자 뒤에는 생성자 호출 코드가 오며 <strong>클래스() 형태</strong>를 갖는다.
  </li>
  <li>
    new 연산자는 <strong>메모리에 객체를 생성</strong>하고 JVM의 <strong>Heap 영역에 클래스 인스턴스</strong>를 생성한다.
  </li>
  <li>
    메모리에 생성된 객체는 <strong>메모리 주소</strong>를 가지며 new 연산자는 해당 <strong>메모리 주소를 리턴</strong>한다.
  </li>
  <li>
    따라서 클래스 타입의 변수에는 <strong>객체의 주소(참조값)가 대입</strong>된다.
  </li>
  <li>
    클래스의 두 가지 용도는 다음과 같다.
  </li>
    <ul>
      <li>
        <strong>라이브러리(library) 클래스</strong>: 실행할 수 없으며 <strong>다른 클래스에서 이용</strong>하는 클래스.
      </li>
      <li>
        <strong>실행 클래스</strong>: <strong>main() 메서드</strong>를 갖고 있는 <strong>실행 가능한 클래스</strong>.
      </li>
    </ul>
  <li>
    일반적으로 자바 프로그램은 <strong>하나의 실행 클래스</strong>와 <strong>다수의 라이브러리 클래스</strong>들로 구성되며 실행 클래스는 실행 하면서 라이브러리 클래스를 <strong>내부에서 이용</strong>한다.
  </li>
</ul>

```java
// 1. Student.java
//   - Student 클래스 선언
package ch06.sec04;

public class Student {

}
```

```java
// 2. StudentExample.java
package ch06.sec04;

public class StudentExample {
  public static void main(String[] args) {
    Student s1 = new Student();
    System.out.println("s1 변수가 Student 객체를 참조합니다.");

    Student s2 = new Student();
    System.out.println("s2 변수가 또 다른 Student 객체를 참조합니다.");
  }
}
```

<br><br>

<h1>5. 클래스의 구성 멤버</h1>
<h2>5-1. 필드</h2>
<ul>
  <li>
    <strong>필드(Feild)</strong>는 <strong>객체의 데이터를 저장</strong>하는 역할을 한다.
  </li>
  <li>
    선언 형태는 변수 선언과 비슷하지만 쓰임새가 다르다.
  </li>
</ul>

<br>

<h2>5-2. 생성자</h2>
<ul>
  <li>
    <strong>생성자(Constructor)</strong>는 <strong>new 연산자</strong>로 객체를 생성할 때 <strong>객체의 초기화 역할</strong>을 수행한다.
  </li>
  <li>
    선언 형태는 메서드와 비슷하지만, <strong>리턴 타입이 없고</strong> 이름은 <strong>클래스 이름과 동일</strong>하다.
  </li>
</ul>

<br>

<h2>5-3. 메소드</h2>
<ul>
  <li>
    메서드(Method)는 <strong>객체가 수행할 동작</strong>이다. 
  </li>
  <li>
    다른 언어에서는 함수라하지만 <strong>객체 내부의 함수는 메서드</strong>라 부른다.
  </li>
  <li>
    <strong>객체와 객체간의 상호작용</strong>을 위해 호출된다.
  </li>
</ul>

<br><br>

<h1>6. 필드 선언과 사용</h1>
<ul>
  <li>
    필드는 <strong>객체의 데이터를 저장</strong>하며 <strong>고유 데이터, 현재 상태 데이터 그리고 부품 데이터</strong>가 있다.
  </li>
  <li>
    필드 선언은 변수 선언과 동일하지만 반드시 <strong>클래스 블록에서 선언</strong>되어야 한다.
  </li>
  <li>
    <strong>로컬변수</strong>는 <strong>생성자와 메서드 블록</strong>에서 선언되어 생성자와 메서드 <strong>호출 시</strong>에만 생성되고 사용되지만, <strong>필드</strong>는 클래스 블록에 선언되어 객체 내부에 존재하며 <strong>객체 내부와 외부 모두 사용 가능</strong>하다.
  </li>
  <li>
    초기값을 제공하지 않을 경우 필드는 객체 생성 시 <strong>자동으로 기본값을 초기화</strong> 한다. (p216 장표 참고).
  </li>
</ul>

```java
// 1. Car.java
//   - 클래스 생성.
package ch06.sec06.exam01;

public class Car {
  // 필드 선언
  String model;
  boolean start;
  int speed;
}
```

```java
// 2. CarExample.java
package ch06.sec06.exam01;

public class CarExample {
  public static void main(String[] args) {
    // Car 객체 생성
    Car myCar = new Car();

    // Car 객체의 필드값 읽기
    System.out.println("모델명: " + myCar.model);
    System.out.println("시동여부: " + myCar.start);
    System.out.println("현재속도: " + myCar.speed);
  }
}
```

<br>

<h2>6-1. 필드 사용</h2>
<ul>
  <li>
    필드를 사용한다는 의미는 <strong>필드값을 읽고 변경</strong>하는 것을 의미한다.
  </li>
  <li>
    필드는 객체의 데이터이기에 객체가 존재하지 않으면 필드도 존재하지 않는다. 따라서 클래스로부터 <strong>객체가 생성된 후</strong>에 필드를 사용할 수 있다.
  </li>
    <ul>
      <li>
        필드는 객체 내부의 <strong>생성자</strong>와 <strong>메서드 내부</strong>에서 사용할 수 있으며 <strong>객체 외부에서도 접근</strong>하여 사용할 수 있다.
      </li>
    </ul>
  <li>
    <strong>객체 내부</strong>에서는 단순히 <strong>필드명</strong>으로 읽고 변경할 수 있지만, <strong>외부 객체</strong>에서는 <strong>참조 변수와 도트(.) 연산자</strong>를 이용해 필드를 읽고 변경해야 한다.
  </li>
    <ul>
      <li>
        도트 연산자(.)는 <strong>객체 접근 연산자</strong>로 객체가 갖고 있는 필드나 메소드에 접근하고자 할 때 <strong>참조 변수 뒤</strong>에 붙인다.
      </li>
    </ul>
</ul>

```java
// 1. Car.java
package ch06.sec06.exam02;

public class Car {
  // 필드 선언
  String company = "현대자동차";
  String model = "그랜저";
  String color = "검정";
  int maxSpeed = 350;
  int speed;
}
```

```java
// 2. CarExample.java
package ch06.sec06.exam02;

public class CarExample {
  public static void main(String[] args) {
    // Car 객체 생성
    Car myCar = new Car();

    // Car 객체의 필드값 읽기
    System.out.println("제작회사: " + myCar.company);
    System.out.println("모델명: " + myCar.model);
    System.out.println("색깔: " + myCar.color);
    System.out.println("최고속도: " + myCar.maxSpeed);
    System.out.println("현재속도: " + myCar.speed);

    // Car 객체의 필드값 변경
    myCar.speed = 60;
    System.out.println("수정된 속도: " + myCar.speed);
  }
}
```

<br><br>

<h1>7. 생성자 선언과 호출</h1>
<ul>
  <li>
    <strong>new 연산자</strong>는 객체를 생성한 후 <strong>생성자(Constructor)를 호출</strong>해서 <strong>객체를 초기화</strong>하는 역할을 수행한다.
  </li>
    <ul>
      <li>
        객체 초기화란 <strong>필드 초기화</strong>를 하거나 <strong>메서드를 호출</strong>해서 객체를 사용할 준비를 하는 것을 의미한다.
      </li>
    </ul>
  <li>
    생성자가 실행되면 new 연산자는 <strong>객체의 주소</strong>를 반환한다.
  </li>
  <li>
    반환된 주소는 클래스 변수에 대입되어 <strong>객체의 필드나 메서드에 접근</strong>할 때 이용된다.
  </li>
</ul>

<br>

<h2>7-1. 기본 생성자</h2>
<ul>
  <li>
    모든 클래스에는 생성자가 존재하며 하나 이상의 생성자를 가질 수 있다. 만약 생성자가 없다면 컴파일러는 <strong>기본 생성자(Default Constructor)</strong>를 바이트코드 파일에 자동으로 추가한다.
  </li>
  <li>
    클래스가 <strong>public class</strong>로 선언되면 기본 생성자도 public 이지만 <strong>class</strong>로만 선언되면 생성자도 public이 붙지 않는다.
  </li>
</ul>

<br>

<h2>7-2. 생성자 선언</h2>
<ul>
  <li>
    객체를 <strong>다양하게 초기화</strong>하기 위해서 개발자는 생성자를 직접 선언할 수 있다.
  </li>
  <li>
    생성자는 메서드와 비슷한 모양을 갖고 있지만, <strong>리턴 타입</strong>이 없고 <strong>클래스 이름과 동일</strong>하다.
  </li>
  <li>
    <strong>매개변수</strong>는 new 연산자로 생성자를 호출할 때 <strong>매개값을 생성자 블록 내부로 전달</strong>하는 역할을 한다.
  </li>
    <ul>
      <li>
        생성자가 <strong>선언된 순서</strong>대로 매개변수에 값이 전달된다.
      </li>
    </ul>
</ul>

```java
// 1. Car.java
package ch06.sec07.exam01;

public class Car {
  // 생성자 선언
  Car(String model, String color, int maxSpeed); {
  }
}
```

```java
// 2. CarExample.java
package ch06.sec07.exam01;

public class CarExample {
  public static void main(String[] args) {
    Car myCar = new Car("그랜저", "검정", 250);
    // 사용자가 명시적으로 생성자를 정의하였기에 컴파일러가 자동으로 생성자를 만들지 않는다.
    // → 따라서 아래와 같은 코드로 기본 생성자를 호출할 수 없다.
    // Car myCar = new Car();
  }
}
```

<br>

<h2>7-3. 필드 초기화</h2>
<ul>
  <li>
    객체마다 <strong>동일한 값</strong>을 갖고 있다면 <strong>필드 선언 시 초기값을 대입</strong>하는 것이 좋고, 객체마다 <strong>다른 값</strong>을 가져야 한다면 <strong>생성자에서 필드를 초기화</strong>하는 것이 좋다.
  </li>
    <ul>
      <li>
        필드에서 초기화를 하지 않았다면 생성자의 매개값은 <strong>new 연산자로 생성자를 호출할 때</strong> 주어진다.
      </li>
    </ul>
  <li>
    매개변수 이름이 너무 짧으면 가독성이 좋지 않아 보통 <strong>초기화시킬 필드명과 동일한 이름</strong>을 사용한다.
  </li>
    <ul>
      <li>
        매개변수명이 필드명과 동일한 경우 필드임을 구분하기 위해 <strong>this 키워드를 필드명 앞</strong>에 붙인다.
      </li>
      <li>
        <strong>this</strong>는 현재 객체 자신을 참조하는 키워드이다.
      </li>
      <li>
        클래스 내부에서 자신의 필드나 메서드를 명시적으로 가리킬 때 사용한다.
      </li>
      <li>
        필드명과 매개변수명이 동일한 경우, 필드임을 구분하기 위해 <strong>this</strong> 키워드를 필드명 앞에 붙인다.
      </li>
      <li>
        <strong>this</strong>는 클래스 자체가 아닌, <strong>현재 생성된 객체(instance)</strong>를 의미한다.
      </li>
      <li>
        <strong>this</strong>는 클래스 내부에서만 사용 가능하며, <strong>외부나 static 메서드에서는 사용할 수 없다.</strong>
      </li>
    </ul>
  <li>
    자동(기본) 초기값은 “값은 있지만 의미가 없기” 때문에, 실제 프로그램에서는 우리가 의도한 상태를 보장하기 위해 직접 초기화해야 한다.
  </li>
</ul>

```java
// 1. Korean.java
package ch06.sec07.exam02;

public class Korean {
  // 필드 선언
  String nation = "대한민국";
  String name;
  String ssn;

  // 생성자 선언. (public X).
  public Korean(String n, String s) {
    name = n;
    ssn = s;
  }
}
```

```java
// 2. KoreanExample.java
package ch06.sec07.exam02;

public class KoreanExample {
  public static void main(String[] args) {
    // Korean 객체 생성.
    Korean k1 = new Korean("박자바", "011225-1234567");
    // Korean 객체 데이터 읽기
    System.out.println("k1.nation : " + k1.nation);
    System.out.println("k1.name : " + k1.name);
    System.out.println("k1.ssn : " + k1.ssn);
    System.out.println();

    // 또 다른 Korean 객체 생성
    Korean k2 = new Korean("김자바", "930525-0654321");
    // 또 다른 Korean 객체 데이터 읽기
    System.out.println("k2.nation : " + k2.nation);
    System.out.println("k2.name : " + k2.name);
    System.out.println("k2.ssn : " + k2.ssn)
  }
}
```

```java
// 3. Korean.java
package ch06.sec07.exam03;

public class Korean {
  // ------------------- [필드 영역] -------------------
  // 아래의 세 필드는 객체가 생성될 때마다 힙(Heap) 영역에 만들어진다.
  // "대한민국" 문자열 리터럴은 메서드 영역(Method Area)의 String Constant Pool에 저장된다.
  // 즉, 프로그램 전체에서 한 번만 생성되고 모든 객체가 이 리터럴을 공유합니다.
  // nation 필드 자체는 힙에 존재하며, 이 리터럴을 참조(reference)합니다.
  String nation = "대한민국";

  // name, ssn은 아직 값이 없으므로 힙에 생성될 때 자동으로 기본값(null)으로 초기화됩니다.
  String name;
  String ssn;

  // ------------------- [생성자 영역] -------------------
  // 생성자는 new 연산자를 통해 객체가 힙에 생성된 후 호출됩니다.
  // this는 새로 만들어진 힙의 객체 자신을 가리킵니다.
  // 매개변수로 받은 값(name, ssn)을 힙의 필드에 대입합니다.
  public Korean(String name, String ssn) {
    this.name = name; // 힙에 있는 인스턴스 변수 name에 매개변수 값을 저장
    this.ssn = ssn; // 힙에 있는 인스턴스 변수 ssn에 매개변수 값을 저장
  }
}

/*
🧠 메모리 구조 요약

[메서드 영역(Method Area)]
 ├─ 클래스 정보(Korean의 필드, 메서드 등)
 ├─ 문자열 상수 풀(String Constant Pool)
 │    └─ "대한민국"  ← 프로그램 전체에서 1회만 저장, 불변(immutable)

[힙 영역(Heap)]
 ├─ new Korean(...) 호출 시 객체 생성
 │    ├─ nation → "대한민국" (메서드 영역 리터럴 참조)
 │    ├─ name   → null (기본값, 이후 생성자에서 덮어씀)
 │    └─ ssn    → null (기본값, 이후 생성자에서 덮어씀)

📌 참고:
- "대한민국" 자체는 수정 불가 (String은 불변)
- 그러나 nation 필드는 힙의 참조 변수이므로 다른 문자열로 변경 가능:
    k1.nation = "미국";  // 기존 리터럴을 바꾸는 게 아니라, 참조가 다른 리터럴로 이동
*/
```

<h3>7-3-1. 생성자</h3>
<ul>
  <li>
    클래스에 필드와 생성자를 정의한다.
    <br>→ 클래스 로딩 시, 클래스의 구조 정보(필드, 메서드, 생성자 등)가 JVM의 <strong>메서드 영역(Method Area)</strong>에 로드된다.
    <br>→ <strong>new</strong> 연산자를 통해 객체를 생성하면, 객체의 공간이 <strong>힙(Heap)</strong>에 만들어지고 필드들이 기본값(null, 0, false 등)으로 초기화된다.
    <br>→ 클래스의 생성자가 호출되며, 전달받은 <strong>매개변수 값</strong>이 <strong>스택(Stack)</strong>에 저장된다.
    <br>→ 생성자 내부에서 <strong>this.field = parameter;</strong>를 통해 스택의 매개변수 값을 힙의 필드로 복사한다. (Stack → Heap)
    <br>→ 객체의 참조 변수(reference)가 힙에 생성된 객체의 주소값을 저장한다. (Stack)
    <br>→ 모든 초기화가 완료되면, 필드 값이 완성된 객체가 힙에 존재하고 스택의 참조 변수가 이를 가리킨다. (Heap + Stack)
  </li>
  <li>
    생성자에서 값을 대입하는 이유는 필드의 값이 기본값(null, 0 등)으로 남지 않도록 하기 위함이며,
    이를 통해 <b>객체의 무결성(데이터 일관성)</b>을 보장한다.
  </li>
</ul>
<br>

<h2>7-4. 생성자 오버로딩</h2>
<ul>
  <li>
    매개값으로 객체의 필드를 다양하게 초기화하려면 <strong>생성자 오버로딩(Overloading)</strong>이 필요하다.
  </li>
    <ul>
      <li>
        오버로딩이랑 <strong>매개변수를 달리하는 생성자</strong>를 여러 개 선언하는 것을 의미한다.
      </li>
    </ul>
  <li>
    <strong>매개변수의 타입</strong>과 <strong>개수</strong> 그리고 <strong>선언된 순서</strong>가 동일한 경우 매개변수 이름만 바꾸는 것은 생성자 오버로딩이 아니다.
  </li>
  <li>
    생성자가 오버로딩되어 있을 경우 new 연산자로 생성자를 호출할 때 제공되는 <strong>매개값의 타입</strong>과 <strong>수</strong>에 따라 실행될 생성자가 결정된다.
  </li>
</ul>

```java
// 1. Car.java
package ch06.sec07.exam04;

public class Car {
  // 필드 선언
  String company = "현대자동차";
  String model;
  String color;
  int maxSpeed;

  // 생성자 선언
  Car() {}

  // 생성자
  Car(String model) {
    this.model = model;
  }

  // 생성자
  Car(String model, String color) {
    this.model = model;
    this.color = color;
  }

  // 생성자
  Car(String model, String color, int maxSpeed) {
    this.model = model;
    this.color = color;
    this.maxSpeed = maxSpeed;
  }
}
```

```java
// 2. CarExample.java
package ch06.sec07.exam04;

public class CarExample {
  public static void main(String[] args) {

    // 생성자 호출
    Car car1 = new Car();
    System.out.println("car1.company : " + car1.company);
    System.out.println();

    // 생성자 호출
    Car car2 = new Car("자가용");
    System.out.println("car2.company : " + car2.company);
    System.out.println("car2.model : " + car2.model);
    System.out.println();

    // 생성자 호출
    Car car3 = new Car("자가용", "빨강");
    System.out.println("car3.company : " + car3.company);
    System.out.println("car3.model : " + car3.model);
    System.out.println("car3.color : " + car3.color);
    System.out.println();

    // 생성자 호출
    Car car4 = new Car("택시", "검정", 200);
    System.out.println("car4.company : " + car4.company);
    System.out.println("car4.model : " + car4.model);
    System.out.println("car4.maxSpeed : " + car4.maxSpeed);
    System.out.println();
  }
}
```

<br>

<h2>7-5. 다른 생성자 호출</h2>
<ul>
  <li>
    생성자 오버로딩이 많은 경우 <strong>생성자 간의 중복 코드</strong>가 발생할 가능성이 높아진다. 특히 매개변수의 수만 달리하고 필드 초기화 내용이 비슷한 경우가 해당한다.
  </li>
  <li>
    이 경우 <strong>하나의 생성자</strong>에만 집중적으로 공통 코드를 작성하고, 나머지 생성자는 <strong>this(...)</strong>를 통해 공통 코드를 갖는 생성자를 호출하는 방법으로 개선할 수 있다. 
  </li>
  <li>
    <strong>this(매개값, ...)</strong>는 생성자의 <strong>첫 줄</strong>에 작성되며 <strong>다른 생성자를 호출</strong>하는 역할을 한다.
  </li>
    <ul>
      <li>
        호출하고 싶은 생성자에 맞게 <strong>매개값을 전달</strong>하면 된다.
      </li>
      <li>
        호출 후에는 <strong>원래 생성자로 돌아와</strong> 코드를 실행한다.
      </li>
    </ul>
  <li>
    하단의 생서자가 아직 실행되지 않았는데도 상단의 생성자가 호출이 가능한 것은 <strong>컴파일러가 미리 알고 연결</strong> 해두기 때문이다.
  </li>
    <ul>
      <li>
        컴파일 단계에서 미리 모든 생성자와 메서드를 메서드 영역(Method Area)에 등록해 준다.
      </li>
    </ul>
</ul>

```java
// 1. Car.java
package ch06.sec07.exam05;

public class Car {
  // 필드 선언
  String company = "현대자동차";
  String model;
  String color;
  int maxSpeed;

  // 생성자
  Car(String model) {
    // 20라인 생성자 호출
    this(model, "은색", 250);
  }

  // 생성자
  Car(String model, String color) {
    // 20라인 생성자 호출
    this(model, "color", 20);
  }

  // 생성자
  Car(String model, String color, int maxSpeed) {
    this.model = model;
    this.color = color;
    this.maxSpeed = maxSpeed;
  }
}
```

```java
// 2. CarExample.java
package ch06.sec07.exam05;

public class CarExample {
  public static void main(String[] args) {
    Car car1 = new Car("자가용");
    System.out.println("car1.company : " + car1.company);
    System.out.println("car1.model : " + car1.model);
    System.out.println();

    Car car2 = new Car("자가용", "빨강");
    System.out.println("car2.company : " + car2.company);
    System.out.println("car2.model : " + car2.model);
    System.out.println("car2.color : " + car2.color);
    System.out.println();

    Car car3 = new Car("택시", "검정", 200);
    System.out.println("car3.company : " + car3.company);
    System.out.println("car3.model : " + car3.model);
    System.out.println("car3.color : " + car3.color);
    System.out.println("car3.maxSpeed : " + car3.maxSpeed);
  }
}
```

<br><br>

<h1>8. 메소드 선언과 호출</h1>
<ul>
  <li>
    <strong>메서드 선언</strong>은 객체의 동작을 <strong>실행 블록으로 정의</strong>하는 것을 의미하고, <strong>메서드 호출</strong>은 실행 블록을 <strong>실제로 실행</strong>하는 것을 의미한다.
  </li>
  <li>
    메서드는 <strong>객체 내부에서도 호출</strong> 되지만 <strong>다른 객체에서도 호출</strong>될 수 있기에 <strong>객체 간의 상호작용</strong> 방법을 정의한다고 볼 수 있다.
  </li>
</ul>

<br>

<h2>8-1.메소드 선언</h2>

```java
/* 
리턴 타입 메서드명(매개변수, ...) {
  
        .
        .
        .
  실행할 코드 작성
        .
        .
        .
}
*/
```

<h3>8-1-1. 리턴 타입</h3>
<ul>
  <li>
    라턴 타입은 메서드가 실행 후 호출한 곳으로 전달하는 <strong>결과값의 타입</strong>을 의미한다.
  </li>
    <ul>
      <li>
        리턴값이 없는 메서드의 경우 <strong>void</strong>로 작성한다.
      </li>
    </ul>
</ul>

<h3>8-1-2. 메소드명</h3>
<ul>
  <li>
    메서드명은 <strong>첫 문자를 소문자</strong>로 시작하고, <strong>캐멀 스타일</strong>로 작성한다.
  </li>
</ul>

<h3>8-1-3. 매개변수</h3>
<ul>
  <li>
    매개변수는 메서드를 호출할 때 <strong>전달할 매개값</strong>을 받기 위해 사용한다. 전달할 매개값이 없다면 생략이 가능하다.
  </li>
</ul>

<h3>8-1-4. 실행 블록</h3>
<ul>
  <li>
    메서드 호출 시 실행되는 블록이다.
  </li>
</ul>

```java
// 1. Calculator.java
package ch06.sec08.exam01;

public class Calculator {
  // 리턴값이 없는 메서드 선언
  void powerOn() {
    System.out.println("전원을 켭니다.");
  }

  // 리턴값이 없는 메서드 선언
  void powerOff() {
    System.out.println("전원을 끕니다.");
  }

  // 호출 시 두 정수 값을 전달받고, 
  // 호출한 곳으로 결과값 int를 리턴하는 메서드.
  int plus(int x, int y) {
    int result = x + y;
    // 리턴값 지정
    return result;
  }

  // 호출 시 두 정수 값을 전달받고,
  // 호출한 곳으로 결과값 double을 리턴하는 메서드 선언.
  double divide(int x, int y) {
    double result = (double) x / (double) y;
    // 리턴값 지정
    return result;
  }
}
```

<br>

<h2>8-2. 메소드 호출</h2>
<ul>
  <li>
    메서드를 호출한다는 것은 <strong>메서드를 실행</strong>하는 것을 의미한다.
  </li>
  <li>
    메서드는 객체의 동작이기에 <strong>객체가 없다면 호출할 수 없다</strong>.
  </li>
    <ul>
      <li>
        클래스로부터 객체가 생성된 후에 <strong>생성자</strong>와 <strong>다른 메서드 내부</strong> 및 <strong>객체 외부</strong>에서도 호출될 수 있다.
      </li>
    </ul>
  <li>
    <strong>객체 내부</strong>에서는 <strong>메서드명</strong>으로 호출을 하지만 <strong>외부 객체</strong>에서는 <strong>변수</strong>와 <strong>도트(.) 연산자</strong>를 이용해 호출해야 한다.
  </li>
    <ul>
      <li>
        메서드가 매개변수를 갖고 있는 경우 호출할 때 <strong>매개변수의 타입과 수</strong>에 맞게 매개값을 제공해야 한다.
      </li>
    </ul>
</ul>

```java
// 1. CalculatorExample.java
package ch06.sec08.exam01;

public class CalculatorExample {
  public static void main(String[] args) {
    // Calculator 객체 생성.
    Calculator myCalc = new Calculator();

    // 리턴값이 없는 powerOn() 메서드 호출.
    myCalc.powerOn();

    // plus 메서드 호출 시 5와 6을 매개값으로 전잘하고,
    // 덧셈 결과를 리턴받아 result1 변수에 대입.
    int result1 = myCalc.plus(5, 6);
    System.out.println("result1 : " + result1);
    
    int x = 10;
    int y = 4;
    // divide() 메서드 호출 시 변수 x와 y의 값을 매개값으로 제공하고,
    // 나눗셈 결과를 리턴받아 result2 변수에 대입
    double result2 = myCalc.divide(x, y);
    System.out.println("result2 : " + result2);

    // 리턴값이 없는 powerOff() 메서드 호출.
    myCalc.powerOff();
  }
}
```

<br>

<h2>8-3. 가변길이 매개변수</h2>
<ul>
  <li>
    만약 메서드가 <strong>가변길이 매개변수</strong>를 갖고 있다면 <strong>매개변수의 개수</strong>와 상관없이 매개값을 전달 할 수 있다.
  </li>
  <li>
    가변길이 매개변수는 <strong>int sum(int ... values) {}</strong> 와 같이 선언한다.
  </li>
  <li>
    매개값들은 자동으로 <strong>배열 항목</strong>으로 변환되어 전달되기에 메서드 호출 시 직접 <strong>배열을 매개값</strong>으로 제공해도 된다.
  </li>
</ul>

```java
// 1. Computer.java
package ch06.sec08.exam02;

public class Computer {
  // 가변길이 매개변수를 갖는 메서드 선언
  int sum(int ... values) {
    // sum 변수 선언
    int sum = 0;

    // values는 배열 타입의 변수처럼 사용.
    for (int i = 0; i < values.length; i++) {
      sum += values[i];
    }

    // 합산 결과를 리턴
    return sum;
  }
}
```

```java
// 2. ComputerExample.java
package ch06.sec08.exam02;

public class ComputerExample {
  public static void main(String[] args) {
    // Computer 객체 생성
    Computer myCom = new Computer();

    // sum() 메서드 호출 시 매개값 1, 2, 3을 제공하고 
    // 합산 결과를 리턴받아 result1 변수에 대입
    int result1 = myCom.sum(1, 2, 3);
    System.out.println("result1: " + result1);

    // sum() 메서드 호출 시 매개값 1, 2, 3, 4, 5를 제공하고
    // 합산 결과를 리턴받아 result2 변수에 대입
    int result2 = myCom.sum(1, 2, 3, 4, 5);
    System.out.println("result2: " + result2);

    // sum() 메서드 호출 시 배열을 제공하고
    // 합산 결과를 리턴받아 result3 변수에 대입
    int[] values = { 1, 2, 3, 4, 5 };
    int result3 = myCom.sum(values);
    System.out.println("result3: " + result3);

    // sum() 메서드 호출 시 배열을 제공하고
    // 합산 결과를 리턴받아 result4 변수에 대입
    int result4 = myCom.sum(new int[] { 1, 2, 3, 4, 5 });
    System.out.println("result4: " + result4);
  }
}
```

<br>

<h2>8-4. return 문</h2>
<ul>
  <li>
    return 문은 메서드의 <strong>실행을 강제 종료</strong>하고 <strong>호출한 곳으로 돌아간다</strong>는 의미이다.
  </li>
    <ul>
      <li>
        메서드 선언에 <strong>리턴 타입</strong>이 있는 경우 <strong>return 문 뒤에 리턴값</strong>을 추가로 지정해야 한다.
      </li>
    </ul>
  <li>
    return 문 이후에 실행문은 <strong>절대 실행되지 않기에</strong> 실행문을 작성하면 <strong>Unreachable code라는 컴파일 에러</strong>가 발생한다.
  </li>
</ul>

```java
// 1. Car.java
package ch06.sec08.exam03;

public class Car {
  // 필드 선언
  int gas;

  // 리턴값이 없는 메서드로 매개값을 받아서 gas 필드값을 변경.
  void setGas(int gas) {
    this.gas = gas;
  }

  // 리턴값이 boolean인 메서드로 gas 필드값이 0이면 false를, 
  // 0이 아니면 true를 리턴
  boolean isLeftGas() {
    if (gas == 0) {
      System.out.println("gas가 없습니다.");
      // false를 리턴하고 메서드 종료
      return false;
    }
    System.out.println("gas가 있습니다.");
    // true를 리턴하고 메서드 종료
    return true;
  }
  
  // 리턴값이 없는 메서드로 gas 필드값이 0이면 return 문으로 메서드 종료
  void run() {
    while (true) {
      if (gas > 0) {
        System.out.println("달립니다.(gas잔량:" + gas + ")");
        gas -= 1;
      } else {
        System.out.println("멈춥니다.(gas잔량:" + gas + ")");
        // 메서드 종료
        return;
      }
    }
  }
}
```

```java
// 2. CarExample.java
package ch06.sec08.exam03;

public class CarExample {
  public static void main(String[] args) {
    // Car 객체 갱성.
    Car myCar = new Car();

    // 리턴값이 없는 setGas() 메서드 호출.
    myCar.setGas(5);

    // isLeftGas() 메서드를 호출해 받은 리턴값이 true일 경우 if 블록 실행.
    if(myCar.isLeftGas()) {
      System.out.println("출발합니다.");

      // 리턴값이 없는 run() 메서드 호출.
      myCar.run();
    }

    System.out.println("gas를 주입하세요.");
  }
}
```

<br>

<h2>8-5. 메소드 오버로딩</h2>
<ul>
  <li>
    <strong>메서드 오버로딩(overloading)</strong>이란 메서드 <strong>이름</strong>은 같되 <strong>매개변수의 타입</strong>, <strong>개수</strong>, <strong>순서</strong>가 다른 메서드를 여러 개 선언하는 것을 의미한다.
  </li>
  <li>
    메서드를 오버로딩하는 이유는 다양한 매개값을 처리하기 위해서이다.
  </li>
</ul>

```java
// 1. Calculator.java
package ch06.sec08.exam04;

public class Calculator {
  // 정사각형 넓이.
  double areaRectangle(double width) {
    return width * width;
  }

  // 직사각형 넓이. (오버로딩).
  double areaRectangle(double width, double height) {
    return width * height;
  }
}
```

```java
// 2. CalculatorExample.java
package ch06.sec08.exam04;

public class CalculatorExample {
  public static void main(String[] args) {
    // 객체 생성.
    Calculator myCalcu = new Calculator();

    // 정사각형의 넓이 구하기.
    double result1 = myCalcu.areaRectangle(10);

    // 직사각형의 넓이 구하기.
    double result2 = myCalcu.areaRectangle(10, 20);
    
    System.out.println("정사각형의 넓이=" + result1);
    System.out.println("직사각형의 넓이=" + result2);
  }
}
```

<br><br>

<h1>9. 인스턴스 멤버</h1>
<ul>
  <li>
    필드와 메서드는 선언 방법에 따라 <strong>인스턴스 멤버</strong>와 <strong>정적 멤버</strong>로 분류할 수 있다. 인스턴스 멤버는 <strong>객체 생성 후</strong> 사용이 가능한 반면, 정적 멤버는 <strong>객체 생성 없이</strong> 사용할 수 있다.
  </li>
  <li>
    인스턴스 멤버(intance)는 객체에 소속된 멤버이고, 정적(static) 멤버는 클래스에 고정된 멤버이다.
  </li>
</ul>

<br>

<h2>9-1. 인스턴스 멤버 선언 및 사용</h2>
<ul>
  <li>
    인스턴스(instance) 멤버란 객체에 소속된 멤버를 의미하여 객체가 있어야만 사용할 수 있다.
  </li>
  <li>
    메서드는 <strong>객체에 포함되지 않는다</strong>. 메서드는 코드 덩어리이기에 객체마다 저장한다면 중복 저장으로 인해 <strong>메모리 효율</strong>이 떨어진다.
  </li>
</ul>

<br>

<h2>9-2. this 키워드</h2>
<ul>
  <li>
    객체 내부에서는 <strong>인스턴스 멤버에 접근</strong>하기 위해 <strong>this</strong>를 사용한다.
  </li>
  <li>
    객체는 자신을 <strong>this</strong>라 하며 인스턴스 멤버인 필드명과 메서드와 생성자의 매개변수명이 동일한 경우 <strong>인스턴스 필드임을 강조</strong>한다.
  </li>
</ul>

```java
// 1. Car.java
package ch06.sec09;

public class Car {
  // 필드 선언
  String model;
  int speed;

  // 생성자 선언
  Car(String model) {
    // 매개변수 필드에 대입(this 생략 불가)
    this.model = model;
  }

  // 메서드 선언
  void setSpeed(int speed) {
    // 매개변수를 필드에 대입(this 생략 불가)
    this.speed = speed;
  }

  void run() {
    this.setSpeed(100);
    System.out.println(this.model + "가 달립니다.(시속" + this.speed + "km/h)");
  }
}
```

```java
// 2. CarExample.java
package ch06.sec09;

public class CarExample {
  public static void main(String[] args) {
    Car myCar = new Car("포르쉐");
    Car yourCar = new Car("벤츠");

    myCar.run();
    yourCar.run();
  }
}
```

<br><br>

<h1>10. 정적 멤버</h1>
<ul>
  <li>
    자바는 <strong>클래스 로더(loader)</strong>를 사용해 클래스를 <strong>메서드 영역</strong>에 저장하고 사용한다.
  </li>
  <li>
    <strong>정적(static) 멤버</strong>란 메서드 영역의 클래스에 <strong>고정적으로 위치하는 멤버</strong>를 의미한다.
  </li>
    <ul>
      <li>
        고정적으로 위치하는 멤버이기에 객체를 생성할 필요없이 클래스르 통해 바로 사용이 가능하다.
      </li>
    </ul>
</ul>

<br>

<h2>10-1. 정적 멤버 선언</h2>
<ul>
  <li>
    필드와 메서드는 모두 정적 멤버가 될 수 있다.
  </li>
  <li>
    객체마다 갖고 있을 필요성이 없는 <strong>공용적인 필드</strong>는 정적 필드로 선언하는 것이 좋다.
  </li>
  <li>
    정적 멤버는 <strong>static</strong>을 사용해 선언할 수 있다.
  </li>
  <li>
    <strong>외부에서 주어진 매개변수</strong>를 받아서 처리하는 경우 <strong>정적 메서드</strong>로 선언하는 것이 좋다. 반면 <strong>인스턴스 필드</strong>를 변경하는 메서드는 <strong>인스턴스 메서드</strong>로 선언하는 것이 좋다.
  </li>
</ul>

<br>

<h2>10-2. 정적 멤버 사용</h2>
<ul>
  <li>
    클래스가 메모리에 로딩되면 <strong>클래스 이름</strong>과 <strong>도트(.) 연산자</strong>로 정적 멤버를 사용할 수 있다.
  </li>
  <li>
    정적 필드와 정적 메서드는 <strong>객체 참조 변수</strong>로도 접근이 가능하다.
  </li>
</ul>

```java
// 1. Calculator.java
package ch06.sec10.exam01;

public class Calculator {
  static double pi = 3.14159;

  static int plus(int x, int y) {
    return x + y;
  }

  static int minus(int x, int y) {
    return x - y;
  }
}
```

```java
// 2. CalculatorExample.java
package ch06.sec10.exam01;

public class CalculatorExample {
  public static void main(String[] args) {
    double result1 = 10 * 10 * Calculator.pi;
    int result2 = Calculator.plus(10, 5);
    int result3 = Calculator.minus(10, 5);

    System.out.println("result1 : " + result1);
    System.out.println("result2 : " + result2);
    System.out.println("result3 : " + result3);
  }
}
```

<br>

<h2>10-3. 정적 블록</h2>
<ul>
  <li>
    정적 필드는 <strong>필드 선언과 동시에</strong> 값을 주는 것이 일반적이다.
  </li>
  <li>
    복잡한 초기화 작업이 필요할 때에는 정적 블록(static block)을 사용해야 한다. 
  </li>
    <ul>
      <li>
        정적 블록은 클래스가 <strong>메모리에 로딩될 때</strong> 자동으로 실행된다.
      </li>
      <li>
        정적 블록이 클래스 내부에 여럭 개가 선언되어 있는 경우 <strong>순서대로 실행</strong>된다.
      </li>
    </ul>
</ul>

```java
// 1. Television.java
package ch06.sec10.exam02;

public class Television {
  static String company = "MyCompany";
  static String model = "LCD";
  static String info;

  static {
    info = company + "-" + model;
  }
}
```

```java
// 2. TelevisionExample.java
package ch06.sec10.exam02;

public class TelevisionExample {
  public static void main(String[] args) {
    // 객체를 생성하지 않고 정적 필드를 사용.
    System.out.println(Television.info);
  }
}
```

<br>

<h2>10-4. 인스턴스 멤버 사용 불가</h2>
<ul>
  <li>
    <strong>정적 메서드와 정적 블록</strong>은 객체가 없어도 실행된다는 특징 때문에 <strong>내부 인스턴스 필드</strong>나 <strong>인스턴스 메서드</strong>를 사용할 수 없으며 또한 자신의 참조인 <strong>this도 사용할 수 없다</strong>.
  </li>
  <li>
    정적 메서드와 정적 블록에서 인스턴스 멤버를 사용하고 싶다면 <strong>객체를 먼저 생성</strong>하고 <strong>참조 변수로 접근</strong>해야 한다.
  </li>
  <li>
    <strong>main() 메서드</strong>도 정적 메서드이기에 <strong>객체 생성</strong> 없이 인스턴스 필드와 인스턴스 메서드를 바로 사용할 수 없다.
  </li>
</ul>

```java
// 1. Car.java
package ch06.sec10.exam03;

public class Car {
  // 인스턴스 필드 생성.
  int speed;
  
  // 인스턴스 메서드 선언 
  void run() {
    System.out.println(speed + "으로 달립니다.");
  }

  static void simulate() {
    // 객체 생성.
    Car myCar = new Car();
    // 인스턴스 멤버 사용
    myCar.speed = 200;
    myCar.run();
  }

  public static void main(String[] args) {
    // 정적 메서드 호출
    simulate();

    // 객체 생성.
    Car myCar = new Car();
    // 인스턴스 멤버 사용.
    myCar.speed = 60;
    myCar.run();
  }
}
```

<br><br>

<h1>11. final 필드와 상수</h1>
<ul>
  <li>
    인스턴스 필드와 정적 필드는 언제든지 값을 변경할 수 있지만 경우에 따라 <strong>값 변경을 막을 때</strong>에는 <strong>final 필드와 상수</strong>를 선언해 활용한다.
  </li>
</ul>

<br>

<h2>11-1. final 필드 선언</h2>
<ul>
  <li>
    final 필드는 초기값이 저장되면 <strong>최종값</strong>이 되며 도중에 <strong>수정이 불가</strong>하다.
  </li>
  <li>
    final 필드에 초기값을 주는 방법은 <strong>필드 선언 시에 초기값을 대입</strong>하거나 <strong>생성자에서 초기값을 대입</strong>하는 방법 두 가지 밖에 없다.
  </li>
    <ul>
      <li>
        마찬가지로 <strong>고정된 값</strong>이라면 <strong>필드 선언 시</strong>에 값을 대입한다.
      </li>
      <li>
        <strong>복잡한 초기화 코드</strong>가 필요하거나 객체 생성 시에 <strong>외부에서 전달된 값</strong>으로 초기화하는 경우 <strong>생성자</strong>를 사용한다.
      </li>
    </ul>
</ul>

```java
// 1. final 타입 형식
final 타입 필드 [=초기값];
```

```java
// 2. Korean.java
package ch06.sec11.exam01;

public class Korean {
  // 인스턴스 final 필드 선언
  final String nation = "대한민국";
  final String ssn;

  // 인스턴스 필드 선언
  String name;

  // 생성자 선언
  public Korean(String ssn, String name) {
    this.ssn = ssn;
    this.name = name;
  }
}
```

```java
// 2. KoreanExample.java
package ch06.sec11.exam01;

public class KoreanExample {
  public static void main(String[] args) {
    // 객체 생성 시 주민등록번호와 이름 전달.
    Korean k1 = new Korean("123456-1234567", "감자바");

    // 필드값 읽기
    System.out.println(k1.nation);
    System.out.println(k1.ssn);
    System.out.println(k1.name);

    // Final 필드는 값을 변경할 수 없다.
    // k1.nation = "USA";
    // k1.ssn = "123-12-1234";

    // 비 final 필드는 값 변경이 가능하다.
    k1.name = "김자바";
  }
}
```

<br>

<h2>11-2. 상수 선언</h2>
<ul>
  <li>
    원주율을 의미하는 파이 등 불변의 값들이 있다. 이런 <strong>불변의 값들</strong>을 저장하는 필드를 자바에서는 <strong>상수(constant)</strong>라 한다.
  </li>
  <li>
    상수는 객체마다 저장할 필요가 없고 여러 값을 가져도 안되기 때문에 <strong>static</strong>이면서 <strong>final</strong>인 특성을 가져야 한다.
  </li>
  <li>
    초기값은 선언 시에 주는 것이 일반적이지만, 복잡한 초기화가 필요한 경우 <strong>정적 블록</strong>에서 초기화할 수도 있다.
  </li>
  <li>
    상수 이름은 모두 <strong>대문자</strong>로 작성하는 것이 관례이다. 만약 서로 다른 단어가 혼합된 이름의 경우 <strong>언더바(_)</strong>로 단얼들을 연결한다.
  </li>
  <li>
    상수는 <strong>정적 필드</strong>이기에 클래스로 접근해서 읽을 수 있다.
  </li>
</ul>

```java
// 1. 상수타입 초기화 형식.
static final 타입 상수 [= 초기값];
```

```java
// 2. Earth.java
package ch06.sec11.exam02;

public class Earth {
  // 상수 선언 및 초기화.
  static final double EARTH_RADIUS = 6400;

  // 상수 선언
  static final double EARTH_SURFACE_AREA;

  // 정적 블록에서 상수 초기화.
  static {
    EARTH_SURFACE_AREA = 4 * Math.PI * EARTH_RADIUS * EARTH_RADIUS;
  }
}
```

```java
// 3. EarthExample.java
package ch06.sec11.exam02;

public class EarthExample {
  public static void main(String[] args) {
    // 상수 읽기
    System.out.println("지구의 반지름: " + Earth.EARTH_RADIUS + "km");
    System.out.println("지구의 표면적: " + Earth.EARTH_SURFACE_AREA + "km^2");
  }
}
```

<br><br>

<h1>12. 패키지</h1>
<ul>
  <li>
    패키지는 클래스의 일부이며 <strong>클래스를 식별</strong>하는 용도로 사용된다.
  </li>
  <li>
    패키지는 주로 개발 회사 <strong>도메인 이름의 역순</strong>으로 만든다.
  </li>
  <li>
    패키지는 상위 패키지와 하위 패키지를 <strong>도트(.)로 구분</strong>한다.
  </li>
  <li>
    패키지는 클래스를 식별하는 용도로 사용되기 때문에 <strong>클래스의 전체 이름</strong>을 포함한다.
  </li>
  <li>
    <strong>패키지에 속한 바이트코드 파일(*.class)</strong>는 따로 떼어 다른 디렉터리로 <strong>이동할 수 없다</strong>.
  </li>
</ul>

<br>

<h2>12-1. 패키지 선언</h2>
<ul>
  <li>
    패키지는 컴파일러가 <strong>컴파일</strong> 하는 과정에서 클래스의 패지지 선언을 보고 <strong>패키지 디렉터리를 자동 생성</strong>한다.
  </li>
  <li>
    패키지 선언은 <strong>package 키워드</strong>와 함께 항상 <strong>소스 파일의 최상단</strong>에 위치해야한다.
  </li>
  <li>
    패키지 이름은 <strong>모두 소문자</strong>로 작성하며, <strong>회사 도메인의 역순</strong>으로 작성하고 마지막에는 <strong>프로젝트 이름</strong>을 붙인다.
  </li>
  <li>
    이클립스는 패키지를 먼저 생성하고 클래스는 나중에 추가한다.
  </li>
  <li>
    이클립스는 소스 파일(*.java)이 저장되면 자동으로 컴파일하여 <strong>bin 디렉터리</strong>에 패키지 디렉터리와 함께 <strong>바이트코드 파일(*.class)을 생성</strong>한다.
  </li>
</ul>

<br>

<h2>12-2. import 문</h2>
<ul>
  <li>
    <strong>다른 패키지에 있는 클래스</strong>를 사용하기 위해서는 <strong>import 문</strong>을 이용해서 <strong>어떤 패키지의 클래스</strong>를 사용하지는지 명시해야 한다.
  </li>
  <li>
    import 문이 작성되는 위치는 <strong>패키지 선언과 클래스 선언 사이</strong>이며 사용하고자 하는 <strong>클래스의 전체 이름</strong>을 기술한다.
  </li>
    <ul>
      <li>
        <strong>동일한 패키지에 포함된 다수의 클래스</strong>를 사용한다면 클래스 이름을 생략하고 <strong>*</strong>을 사용할 수 있다.
      </li>
    </ul>
  <li>
    import 문은 하위 패키지를 포함하지 않기에 <strong>하위 패키지를 로드</strong>할 때에도 <strong>별도로 명시</strong>를 해야한다.
  </li>
  <li>
    동일한 명칭의 클래스를 사용할 경우 <strong>어느 패키지의 클래스</strong>를 사용하는지 명시해야 한다.
  </li>
    <ul>
      <li>
        전체 패키지 명을 주는 경우에는 경로를 모두 명시하기에 import를 할 필요가 없다.
      </li>
    </ul>
  <li>
    이클립스에서 자동으로 필요한 import 문을 작성할 때에는 <strong>Ctrl + Shift + O</strong>를 사용한다.
  </li>
</ul>

```java
// 1. SnowTire.java
package ch06.sec12.hankook;

public class SnowTire {

}
```

```java
// 2. Tire.java
package ch06.sec12.hankook;

public class Tire {

}
```

```java
// 3. AllSeansonTire.java
package ch06.sec12.kumho;

public class AllSeasonTire {

}
```

```java
// 4. Tire.java
package ch06.sec12.kumho;

public class Tire {

}
```

```java
// 5. Car.java
package ch06.sec12.hyundai;

// import 문으로 다른 패키지 클래스 사용
import ch06.sec12.hankook.SnowTire;
import ch06.sec12.kumho.AllSeasonTire;

public class Car {
  // 부품 필드 선언
  ch06.sec12.hankook.Tire tire1 = new ch06.sec12.hankook.Tire();
  ch06.sec12.kumho.Tire tire2 = new ch06.sec12.kumho.Tire();
  SnowTire tire3 = new SnowTire();
  AllSeasonTire tire4 = new AllSeasonTire();
}
```

<br><br>

<h1>13. 접근 제한자</h1>
<ul>
  <li>
    경우에 따라 객체의 필드를 외부에서 변경하거나 메서드를 호출할 수 없도록 막아야할 필요가 있는데 이 경우 <strong>접근 제한자(Access Modifier)</strong>를 사용한다.
  </li>
    <ul>
      <li>
        public, protected, (default) 그리고 private이 존재하며 p264에 장표로 정리돼 있다.
      </li>
    </ul>
</ul>

<br>

<h2>13-1. 클래스의 접근 제한</h2>
<ul>
  <li>
    클래스는 <strong>public</strong>과 <strong>default</strong> 접근 제한을 갖을 수 있다.
  </li>
  <li>
    default는 <strong>같은 패키지 내에서는 제약 없이 사용이 가능</strong>하지만 다른 패키지는 사용할 수 없다.
  </li>
  <li>
    public은 <strong>같은 패키지</strong>뿐만 아니라 <strong>다른 패키지</strong>에서도 사용할 수 있다.
  </li>
</ul>

```java
// 1. A.java
package ch06.sec13.exam01.package1;

// defualt 접근 제한
class A {
}
```

```java
// 2. B.java
// A와 동일 패키지
package ch06.sec13.exam01.package1;

public class B {
  // 필드 선언
  // A 클래스에 접근이 가능하다.
  A a;
}
```

```java
// 3. C.java
// 다른 패키지
package ch06.sec13.exam01.package2;

import ch06.sec13.exam01.package1.*;

public class C {
  // 필드 선언
  // A는 default이기에 접근이 불가하다.
  A a;

  // 반면 B는 public이기에 접근이 가능하다.
  B b;
}
```

<br>

<h2>13-2. 생성자 접근 제한</h2>
<ul>
  <li>
    생성자 또한 public, default 그리고 private 접근 제한을 갖는다. (protected는 없다).
  </li>
</ul>

```java
// 1. A.java
package ch06.sec13.exam02.package1;

public class A {
  // 필드 선언
  A a1 = new A(true);
  A a2 = new A(1);
  A a3 = new A("문자열");

  // public 접근 제한 생성자 선언
  public A(boolean b) {

  }

  // default 접근 제한 생성자 선언
  A(int b) {

  }

  // private 접근 제한 생성자
  private A(String s) {

  }
}
```

```java
// 2. B.java
package ch06.sec13.exam02.package1;

public class B {
  // 필드 선언
  A a1 = new A(true);
  A a2 = new A(1);
  // String 매개변수 생성자는 private 이기에 접근이 불가하다.
  // A a3 = new A("문자열");
}
```

```java
// 3. C.java
package ch06.sec13.exam02.package2;

import ch06.sec13.exam02.package1.*;

public class C {
  // 필드 선언
  A a1 = new A(true);
  // default 설정이라 접근 불가.
  // A a2 = new A(1);
  // private 설정이라 접근 불가.
  // A a3 = new A("문자열");
}
```

<br>

<h2>13-3. 필드와 메서드 접근 제한</h2>
<ul>
  <li>
    필드와 메서드 또한 public, default 그리고 private 접근 제한을 갖을 수 있다.
  </li>
</ul>

```java
// 1. A.java
package ch06.sec13.exam03.package1;

public class A {
  // public 접근 제한을 갖는 필드 선언
  public int field1;
  // default 접근 제한을 갖는 필드 선언
  int field2;
  // private 접근 제한을 갖는 필드 선언
  private int field3;

  // 생성자 선언
  // 모두 클래스 내에서 사용하기에 접근이 가능하다.
  public A() {
    field1 = 1;
    field2 = 1;
    field3 = 1;

    method1();
    method2();
    method3();
  }

  // public 접근 제한을 갖는 메서드 선언
  public void method1() {

  }

  // default 접근 제한을 갖는 메서드 선언.
  void method2() {

  }

  // private 접근 제한을 갖는 메서드 선언.
  private void method3() {

  }
}
```

```java
// 2. B.java
package ch06.sec13.exam03.package1;

public class B {
  public void method() {
    // 객체 생성
    A a = new A();

    // 필드값 변경
    a.field1 = 1;
    a.field2 = 1;
    // private 필드는 접근 불가
    // a.field3 = 1;

    // 메서드 호출
    a.method1();
    a.method2();
    // private 메서드 접근 불가
    // a.method3();
  }
}
```

```java
// 3. C.java
package ch06.sec13.exam03.package2;

import ch06.sec13.exam03.package1.*;

public class C {
  public C() {
    // 객체 생성
    A a = new A();

    // 필드값 변경
    a.field1 = 1;
    // default 필드 접근 불가. (컴파일 에러).
    // a.field2 = 1;
    // private 필드 접근 불가. (컴파일 에러).
    // a.field3 = 1;

    // 메서드 호출
    a.method1();
    // default 메서드 접근 불가 (컴파일 에러).
    // a.method2();
    // private 메서드 접근 불가 (컴파일 에러).
    // a.method3();
  }
}
```

<br><br>

<h1>14. Getter와 Setter</h1>
<ul>
  <li>
    객체지향 프로그래밍에서는 <strong>객체의 무결성</strong>이 깨지는 것을 방지하기 위해 외부에서의 직접적 필드 접근을 제한하고 <strong>메서드를 통한 필드 접근을 선호</strong>한다.
  </li>
    <ul>
      <li>
        메서드가 <strong>데이터를 검증해서 유효한 값만 필드에 저장</strong>할 수 있기 때문이며 이러한 역할을 하는 메서드를 <strong>Setter</strong>라 한다.
      </li>
      <li>
        필드값이 객체 외부에서 사용하기 부적절한 경우 메서드로 <strong>적절한 값을 변환해서 리턴</strong>할 수 있는데 이런 역할을 하는 메서드를 <strong>Getter</strong>라 한다.
      </li>
    </ul>
  <li>
    Setter를 사용하면 예외처리가 가능하고, Getter의 경우 필드를 보호하면서 필요한 정보만 보여줄 수 있다.
  </li>
  <li>
    <strong>생성자</strong>는 <strong>new로 객체가 만들어질 때 한 번</strong>만 실행되고 <strong>Getter</strong>는 <strong>객체가 생성된 후에 값을 조회</strong>한다.
  </li>
</ul>

```java
// 1. Car.java
package ch06.sec14;

public class Car {
  // 필드 선언
  private int speed;
  private boolean stop;

  // speed 필드의 Getter/Setter 선언
  public int getSpeed() {
    return speed;
  }
  public void setSpeed(int speed) {
    if(speed < 0) {
      this.speed = 0;
    } else {
      this.speed = speed;
    }
  }

  // stop 필드의 Getter/Setter 선언
  public boolean isStop() {
    return stop;
  }
  public void setStop(boolean stop) {
    this.stop = stop;
    if(stop == true) this.speed = 0;
  }
}
```

```java
// 2. CarExample.java
package ch06.sec14;

public class CarExample {
  public static void main(String[] args) {
    // 객체 생성
    Car myCar = new Car();

    // 잘못된 속도 변경
    myCar.setSpeed(-50);
    System.out.println("현재 속도: " + myCar.getSpeed());

    // 올바른 속도 변경
    myCar.setSpeed(60);
    System.out.println("현재 속도: " + myCar.getSpeed());

    // 멈춤
    if(!myCar.isStop()) {
      myCar.setStop(true);
    }
    System.out.println("현재 속도: " + myCar.getSpeed());
  }
}
```

<br><br>

<h1>15. 싱글톤 패턴</h1>
<ul>
  <li>
    앱에서 전체에서 <strong>단 한 개의 객체</strong>만 사용하고 싶다면 <strong>싱글톤(Singleton) 패턴</strong>을 적용할 수 있다.
  </li>
    <ul>
      <li>
        싱글톤 패턴의 핵심은 <strong>생성자를 private 접근 제한</strong>해 <strong>외부에서 new 연산자로 생성자를 호출할 수 없도록</strong> 막는다.
      </li>
      <li>
        대신 싱글톤 패턴이 제공하는 <strong>정적 메서드</strong>를 통해 객체를 얻을 수 있다.
      </li>
    </ul>
</ul>

```java
// 1. 싱글톤 형식
public class 클래스 {
  // private 접근 권한을 갖는 정적 필드 선언과 초기화.
  private static 클래스 singletone = new 클래스();

  // private 접근 권한을 갖는 생성자 선언
  private 클래스() {}

  // public 접근 권한을 갖는 정적 메서드 선언
  public static 클래스 getInstance() {
    return Singleton;
  }
}
```

```java
// 2. Singleton.java
package ch06.sec15;

public class Singleton {
  // private 접근 권한을 갖는 정적 필드 선언과 초기화
  private static Singleton singleton = new Singleton();

  // private 접근 권한을 갖는 생성자 선언
  private Singleton() {

  }

  // public 접근 권한을 갖는 정적 메서드 선언
  public static Singleton getInstance() {
    return singleton;
  }
}
```

```java
// 3. SingletonExample.java
package ch06.sec15;

public class SingletonExample {
  public static void main(String[] args) {
    /*
    Singleton obj1 = new Singleton(); // 컴파일 에러
    Singleton obj2 = new Singleton(); // 컴파일 에러
    */

    // 정적 메서드를 호출해서 싱글톤 객체 얻기.
    Singleton obj1 = Singleton.getInstance();
    Singleton obj2 = Singleton.getInstance();

    // 동일한 객체를 참조하는지 확인.
    if(obj1 == obj2) {
      System.out.println("같은 Singleton 객체입니다.");
    } else {
      System.out.println("다른 Singleton 객체입니다.");
   }
  }
}
```