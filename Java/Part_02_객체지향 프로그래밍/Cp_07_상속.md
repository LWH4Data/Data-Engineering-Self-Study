<h1>1. 상속 개념</h1>
<ul>
  <li>
    객체지향 프로그램에서 부모 클래스의 필드와 메서드를 자식 클래스에 물려주는 것을 <strong>상속(Inheritance)</strong>이라 한다.
  </li>
  <li>
    상속은 이미 잘 개발된 <strong>클래스를 재사용</strong>하여 새로운 클래스를 생성하기 때문에 중복되는 코드를 줄여 <strong>개발 시간을 단축</strong>시킨다.
  </li>
  <li>
    부모 클래스를 수정하면 <strong>모든 자식 클래스를 수정</strong>한 효과를 가져오기에 코드의 <strong>유지보수가 용이</strong>하다.
  </li>
</ul>

<br><br>

<h1>2. 클래스 상속</h1>
<ul>
  <li>
    프로그램에서는 자식 클래스가 부모 클래스를 선택한다. 따라서 <strong>자식 클래스</strong>는 어떤 부모로부터 상속 받을지를 결정하고 <strong>extends 뒤에 부모 클래스를 기술</strong>한다.
  </li>
  <li>
    자바는 <strong>다중 상속</strong>을 허용하지 않기에 단 하나의 부모 클래스만 와야한다.
  </li>
</ul>

```java
// 1. 상속 형식
public class 자식클래스 extends 부모클래스 {

}
```

```java
// 2. Phone.java
package ch07.sec02;

public class Phone {
  // 필드 선언
  public String model;
  public String color;

  // 메서드 선언
  public void bell() {
    System.out.println("벨이 울립니다.");
  }

  public void sendVoice(String message) {
    System.out.println("자기: " + message);
  }

  public void receiveVoice(String message) {
    System.out.println("상대방: " + message);
  }

  public void hangUp() {
    System.out.println("전화를 끊습니다.");
  }
}
```

```java
// 2. SmartPhone.java
package ch07.sec02;

public class SmartPhone extends Phone {
  // 필드 선언
  public boolean wifi;
  
  // 생성자 선언
  public SmartPhone(String model, String color) {
    this.model = model;
    this.color = color;
  }

  // 메서드 선언
  public void setWifi(boolean wifi) {
    this.wifi = wifi;
  }

  public void internet() {
    System.out.println("인터넷에 연결합니다.");
  }
}
```

```java
// 3. SmartPhoneExample.java
package ch07.sec02;

public class SmartPhoneExample {
  
  public static void main(String[] args) {
    // SmartPhone 객체 생성.
    SmartPhone myPhone = new SmartPhone("갤럭시", "은색");

    // Phone으로부터 상속받은 필드 읽기
    System.out.println("모델: " + myPhone.model);
    System.out.println("색상: " + myPhone.color);

    // SmartPhone의 필드 읽기
    System.out.println("와이파이 상태: " + myPhone.wifi);

    // Phone으로부터 상속받은 메서드 호출
    myPhone.bell();
    myPhone.sendVoice("여보세요.");
    myPhone.receiveVoice("안녕하세요! 저는 홍길동인데요.");
    myPhone.sendVoice("아~ 네, 반갑습니다.");
    myPhone.hangUp();

    // SmartPhone의 메서드 호출
    myPhone.setWifi(true);
    myPhone.internet();
  }
}
```

<br><br>

<h1>부모 생성자 호출</h1>
<ul>
  <li>
    자바에서도 객체를 생성하면 <strong>부모 객체가 먼저 생성</strong>된 다음 자식 객체가 생성된다.
  </li>
  <li>
    모든 객체는 <strong>생성자를 호출</strong>해야 생성된다. 따라서 자식 객체는 부모 객체를 생성하기 위해 생성자로 <strong>super()를 활용</strong>해 부모 객체의 생성자를 호출한다.
  </li>
    <ul>
      <li>
        부모 클래스에 <strong>기본 생성자</strong>가 없다면 자식 생성자 선언에서 <strong>컴파일 에러</strong>가 발생한다.
      </li>
      <li>
        super()는 컴파일 시 자동 생성되기에 생략할 수 있다.
      </li>
      <li>
        부모 변수에 생성자가 없고 매개변수를 갖는 생성자만 있다면 <strong>super(매개값, ...)</strong>으로 <strong>매개변수를 전달</strong>해야 한다.
      </li>
    </ul>
</ul>

```java
// 1. Phone.java
package ch07.sec03.exam01;

public class Phone {
  // 필드 선언
  public String model;
  public String color;

  // 기본 생성자 선언
  public Phone() {
    System.out.println("Phone() 생성자 실행");
  }
}
```

```java
// 2. SmartPhone.java
package ch07.sec03.exam01;

public class SmartPhone extends Phone {
  // 자식 생성자 선언
  public SmartPhone(String model, String color) {
    // 컴파일 시에 자동 추가되기에 생략할 수 있다.
    super();
    // 자식 클래스가 상속받은 부모 클래스의 필드에 값을 대입
    this.model = model;
    this.color = color;
    System.out.println("SmartPhone(String model, String color) 생성자 실행됨");
  }
}
```

```java
// 3. SmartPhoneExample.java
package ch07.sec03.exam01;

public class SmartPhoneExample {
  
  public static void main(String[] args) {
    // SmartPhone 객체 생성.
    SmartPhone myPhone = new SmartPhone("갤럭시", "은색");

    // Phone으로부터 상속받은 필드 읽기.
    System.out.println("모델: " + myPhone.model);
    System.out.println("색상: " + myPhone.color);
  }
}
```

```java
// 4. Phone.java
//   - 부모 클래스가 매개변수를 갖는 생성자가 있는 경우.
package ch07.sec03.exam02;

public class Phone {
  // 필드 선언
  public String model;
  public String color;

  // 매개변수를 갖는 생성자 선언
  public Phone(String model, String color) {
    this.model = model;
    this.color = color;
    System.out.println("Phone(String model, String color) 생성자 실행");
  }
}
```

```java
// 5. SmartPhone.java
package ch07.sec03.exam02;

public class SmartPhone extends Phone {
  // 자식 생성자 선언
  public SmartPhone(String model, String color) {
    // 부모 클래스가 매개변수를 갖는 생성자가 있기에 반드시 작성해야 한다.
    //   - 매개변수로 전달한 경우 별도로 값을 대입하지는 않는다.
    super(model, color);
    System.out.println("SmartPhone(String model, String color) 생성자 실행됨");
  }
}
```

```java
// 6. SmartPhoneExample.java
package ch07.sec03.exam02;

public class SmartPhoneExample {
 
    public static void main(String[] args) {
      // SmartPhone 객체 생성
      SmartPhone myPhone = new SmartPhone("갤럭시", "은색");

      // Phone으로부터 상속받은 필드 읽기
      System.out.println("모델: " + myPhone.model);
      System.out.println("색상: " + myPhone.color);
    }
}
```

<br><br>

<h1>4. 메소드 재정의</h1>
<ul>
  <li>
    부모 클래스의 메서드가 자식 클래스의 메서드에 완벽히 적합하지 않다면 <strong>자식 클래스에서 메서드를 재정의</strong> 해야하며 이를 <strong>메서드 오버라이딩(Overriding)</strong>이라 한다.
  </li>
</ul>

<br>

<h2>4-1. 메소드 오버라이딩</h2>
<ul>
  <li>
    메서드 오버라이딩이란 상속된 메서드를 자식 클래스에서 재정의하는 것을 의미한다.
  </li>
    <ul>
      <li>
        메서드가 오버라이딩되면 부모 메서드는 숨겨지고 <strong>자식 메서드가 우선적으로 사용</strong>된다.
      </li>
    </ul>
  <li>
    메서드를 오버라이딩할 때는 다음과 같은 규칙에 주의해서 작성한다.
  </li>
    <ul>
      <li>
        <strong>부모 메서드의 선언부(리턴 타입, 메서드 이름, 매개변수)</strong>와 동일해야 한다.
      </li>
      <li>
        <strong>접근 제한</strong>을 더 강하게 오버라딩할 수 없다(public → private 불가능).
      </li>
      <li>
        <strong>새로운 예외</strong>를 throws 할 수 없다.
      </li>
    </ul>
  <li>
    <strong>@Override</strong>를 사용하면 컴파일 시 정확히 오버라이딩 되었는지 확인해 준다. 생략이 가능하다.
  </li>
  <li>
    이클립스에서는 오버라이딩 기능을 제공하며 개발에 사용할 수 있다.
  </li>
</ul>

```java
// 1. Calculator.java
package ch07.sec04.exam01;

public class Calculator {
  // 메서드 선언
  public double areaCircle(double r) {
    System.out.println("Calculator 객체의 areaCircle() 실행");
    return 3.14159 * r * r;
  }
}
```

```java
// 2. Computer.java
package ch07.sec04.exam01;

public class Computer extends Calculator {
  // 메서드 오버라이딩
  @Override
  public double areaCircle(double r) {
    System.out.println("Computer 객체의 areaCircle() 실행");
    return Math.PI * r * r;
  }
}
```

```java
// 3. ComputerExample.java
package ch07.sec04.exam01;

public class ComputerExample {
  public static void main(String[] args) {
    int r = 10;

    Calculator calculator = new Calculator();
    System.out.println("원 면적: " + calculator.areaCircle(r));
    System.out.println();

    Computer computer = new Computer();
    System.out.println("원 면적: " + computer.areaCircle(r));
  }
}
```

<br>

<h2>4-2 부모 메소드 호출</h2>
<ul>
  <li>
    메서드를 재정의하면 부모 메서드는 숨겨지고 자식 메서드만 사용되지만 그럼에도 자식 메서드는 부모 메서드의 내용을 <strong>중복으로 가지고 있어야 한다</strong>.
  </li>
    <ul>
      <li>
        위의 문제는 자식 메서드와 부모 메서드의 <strong>공동 작업 처리 기법</strong>을 이용하면 쉽게 해결할 수 있다.
      </li>
      <li>
        공동 작업 처리 기법이란 <strong>자식 메서드 내에서 부모 메서드를 호출</strong>하는 것으로 <strong>super 키워드</strong>와 <strong>도트(.) 연산자</strong>를 사용하여 숨겨진 부모 메서드를 호출한다. 
      </li>
      <li>
        super로 호출하는 부모 클래스의 메서드는 자식 클래스의 작업 처리 전과 후 어디든지 올 수 있다.
      </li>
        <ul>
          <li>
            순서가 상관없는 이유는 클래스 메타데이터에 이미 저장이 되어있기 때문이다.
          </li>
        </ul>
    </ul>
</ul>

```java
// 1. Airplane.java
package ch07.sec04.exam02;

public class Airplane {
  // 메서드 선언
  public void land() {
    System.out.println("작륙합니다.");
  }

  public void fly() {
    System.out.println("일반 비행합니다.");
  }

  public void takeOff() {
    System.out.println("이륙합니다.");
  }
}
```

```java
// 2. SupersonicAirplane.java
package ch07.sec04.exam02;

public class SupersonicAirplane extends Airplane {
  // 상수 선언
  public static final int NORMAL = 1;
  public static final int SUPERSONIC = 2;
  // 상태 필드 선언
  public int flyMode = NORMAL;

  // 메서드 재정의
  @Override
  public void fly() {
    if(flyMode == SUPERSONIC) {
      System.out.println("초음속 비행합니다.");
    } else {
      // Airplane 객체의 fly() 메서드 호출.
      super.fly();
    }
  }
}
```

```java
// 3. SupersonicAirplaneExample.java
package ch07.sec04.exam02;

public class SupersonicAirplaneExample {
  public static void main(String[] args) {
    SupersonicAirplane sa = new SupersonicAirplane();
    sa.takeOff();
    sa.fly();
    sa.flyMode = SupersonicAirplane.SUPERSONIC;
    sa.fly();
    sa.flyMode = SupersonicAirplane.NORMAL;
    sa.fly();
    sa.land();
  }
}
```

<br><br>

<h1>5. final 클래스와 final 메소드</h1>
<h2>5-1. final 클래스</h2>
<ul>
  <li>
    클래스 앞에 final을 붙이면 최종적인 클래스로 <strong>더 이상 상속할 수 없게</strong> 된다. 즉, final 클래스는 부모 클래스가 될 수 없으며 반대로 자식 클래스를 가질 수 없다.
  </li>
</ul>

```java
// 1. Member.java
package ch07.sec05.exam01;

public final class Member {

}
```

```java
// 2. VeryImportanctPerson.java
package ch07.sec05.exam01;

// Member 클래스가 final로 생성되어 상속이 불가하다.
public class VeryImportantPerson extends Member {

}
```

<br>

<h2>5-2. final 메소드</h2>
<ul>
  <li>
    final 메서드 또한 최종적인 메서드가 되기에 오버라이딩이 불가한 메서드가 된다. 따라서 <strong>자식 클래스에서 final 메서드를 재정의 할 수 없다</strong>.
  </li>
</ul>

```java
// 1. Car.java
package ch07.sec05.exam02;

public class Car {
  // 필드 선언
  public int speed;

  // 메서드 선언
  public void speedUp() {
    speed += 1;
  }

  // final 메서드
  public final void stop() {
    System.out.println("차를 멈춤");
    speed = 0;
  }
}
```

```java
// 2. SportsCar.java
package ch07.sec05.exam02;

public class SportsCar extends Car {
  @Override
  public void speedUp() {
    speed += 10;
  }

  // 오버라이딩 불가.
  /*
  @Override
  public void stop() {
    System.out.println("스포츠카를 멈춤");
  } 
  */
}
```

<br><br>

<h1>1. protected 접근 제한자</h1>
<ul>
  <li>
    protected는 public과 private 주간쯤에 해당하는 접근 제한을 한다.
  </li>
  <li>
    protected는 <strong>같은 패키지 내에서는 default</strong>처럼 접근이 가능하지만, <strong>다른 패키지에서는 자식 클래스에서만</strong> 접근을 허용한다.
  </li>
</ul>

```java
// 1. A.java
package ch07.sec06.package1;

public class A {
  // 필드 선언
  protected String field;

  // 생성자 선언
  protected A() {

  }

  // 메서드 선언
  protected void method() {
    
  }
}
```

```java
// 2. B.java
package ch07.sec06.package1;

public class B {
  // 메서드 선언
  // 같은 패키지이기에 A 클래스의 모든 필드와 메서드를 사용할 수 있다.
  public void method() {
    A a = new A();
    a.field = "value";
    a.method();
  }
}
```

```java
// 3. C.java
package ch07.sec06.package2;

// A 클래스 호출
import ch07.sec06.package1.A;

public class C {
  // 메서드 선언
  // A 클래스와는 다른 패키지이기에 protected로 생성된 필드와 메서드 사용 불가.
  public void method() {
    A a = new A();
    a.field = "value";
    a.method();
  }
}
```

```java
// 4. D.java
package ch07.sec06.package2;

import ch07.sec06.package1.A;

public class D extends A {
  // 생성자 선언
  public D() {
    // A() 생성자 호출
    super();
  }

  // 메서드 선언 (상속을 통한 참조)
  // 상속을 통한 자식 클래스 접근이기에 가능.
  public void method() {
    // A 필드값 변경
    this.field = "value";
    // A 메서드 호출.
    this.method();
  }

  // 메서드 선언 (객체를 생성한 접근)
  // 객체 생성은 자식 클래스 접근이 아닌 외부 접근이기에 불가.
  public void method2() {
    A a = new A();
    a.field = "value";
    a.method();
  }
}
```

<br><br>

<h1>7. 타입 변환</h1>
<ul>
  <li>
    클래스의 타입 변환은 <strong>상속 관계에 있는 클래스 사이</strong>에서 발생한다.
  </li>
</ul>

<br>

<h2>7-1. 자동 타입 변환</h2>
<ul>
  <li>
    <strong>자동 타입 변환(Promotion)</strong>이란 자동적으로 타입 변환이 일어나는 것을 의미한다.
  </li>
  <li>
    <strong>하위 계층에서 상위 계층으로의 타입변환</strong>이 발생한다. 자식과 부모의 타입은 다르지만, 자식 객체는 부모 타입으로 자동 변환된다.
  </li>
  <li>
    자동 타입 변환이 된 후에는 변수는 자식 객체를 참조하지만 접근 가능한 멤버는 <strong>부모 클래스 멤버</strong>로 한정된다.
  </li>
  <li>
    자식 클래스에서 오버리이딩된 메서드가 있다면 부모 메서드 대신 <strong>오버라이딩된 메서드</strong>가 호출되는데 이는 <strong>다형성(Polymorphism)</strong>과 관련이 있다.
  </li>
</ul>

```java
// 1. PromotionExample.java
package ch07.sec07.exam01;

class A {

}

class B extends A {

}

class C extends A {

}

class D extends B {

}

class E extends C {

}

public class PromotionExample { 
  B b = new B();
  C c = new C();
  D d = new D();
  E e = new E();
  
  // 자식 객체를 부모 타입으로 참조하기에 자동 타입 변환 가능.
  A a1 = b;
  A a2 = c;
  A a3 = d;
  A a4 = e;

  B b1 = d;
  C c1 = e;

  // 상속관계에 해당하지 않기에 컴파일 에러
  // B b3 = e;
  // C c2 = d;
}
```

```java
// 2. Parent.java
package ch07.sec07.exam02;

public class Parent {
  // 메서드 선언
  public void method1() {
    System.out.println("Parent-method1()");
  }

  // 메서드 선언
  public void method2() {
    System.out.println("Parent-method2()");
  }
}
```

```java
// 2. Child.java
package ch07.sec07.exam02;

public class Child extends Parent {
  // 메서드 오버라이딩
  @Override
  public void method2() {
    System.out.println("Child-method2()");
  }

  // 메서드 선언
  public void method3() {
    System.out.println("Child-method3()");
  }
}
```

```java
// 3. ChildExample.java
package ch07.sec07.exam02;

public class ChildExample {
  public static void main(String[] args) {
    // 자식 객체 생성.
    Child child = new Child();

    // 자동 타입 변환.
    Parent parent = child;

    // 메서드 호출
    parent.method1();
    parent.method2();
    // 부모 타입 객체로 변환되었기에 호출이 불가하다.
    // parent.method3();
  }
}
```

<br>

<h2>7-2. 강제 타입 변환</h2>
<ul>
  <li>
    부모 타입은 자식 타입으로 자동 변환되지 않는데 대신 캐스팅 연산자를 통해 <strong>강제 타입 변환(casting)</strong>을 할 수 있다.
  </li>
  <li>
    항상 캐스팅이 가능한 것은 아니며 자식 타입 객체가 부모 타입으로 자동 변환된 후 <strong>다시 자식 타입으로 변환</strong>할 때 사용할 수 있다.
  </li>
  <li>
    부모 타입으로 자동 형변환이 일어난 경우 부모 객체의 필드와 메서드만 사용할 수 있기에 자식 타입의 필드와 메서드를 사용하기 위해 강제 형변환을 수행한다.
  </li>
</ul>

```java
// 1. Parent.java
package ch07.sec07.exam03;

public class Parent {
  // 필드 선언
  public String field1;

  // 메서드 선언
  public void method1() {
    System.out.println("Parent-method1()");
  }

  // 메서드 선언
  public void method2() {
    System.out.println("Parent-method2()");
  }
}
```

```java
// 2. Child.java
package ch07.sec07.exam03;

public class Child extends Parent {
  // 필드 선언
  public String field2;

  // 메서드 선언
  public void method3() {
    System.out.println("Child-method3");
  }
}
```

```java
// 3. ChildExample.java
package ch07.sec07.exam03;

public class ChildExample {
    public static void main(String[] args) {
    // 객체 생성 및 자동 타입 변환.
    Parent parent = new Child();

   // Parent 타입으로 필드와 메서드 사용.
   parent.field1 = "data1";  
    parent.method1();
    parent.method2();

    /*
    < 자식 객체의 멤버이기에 부모 객체는 점근 불가. >
    parent.field2 = "data2";
    parent.method3();
    */

   // 강제 타입 변환
   Child child = (Child) parent;

   // Child 타입으로 필드와 메서드 사용
   child.fields = "data2";
   child.method3();
  }
}
```

<br><br>

<h1>8. 다형성</h1>
<ul>
  <li>
    <strong>다형성</strong>이란 <strong>사용 방법은 동일</strong>하지만 <strong>실행 결과가 다양</strong>하게 나오는 성질을 의미한다. 프로그램에서는 구성하는 <strong>객체를 바꾸면</strong> 프로그램의 성능이 다르게 나올 수 있다.
  </li>
  <li>
    같은 메서드 호출이라도 <strong>실제 객체의 타입</strong>에 따라 다른 결과를 나타내며, 이를 다형성이라 한다.
  </li>
  <li>
    다형성을 구현하기 위해서는 <strong>자동 타입 변환</strong>과 <strong>메서드 재정의</strong>가 필요하다.
  </li>
</ul>

<br>

<h2>8-1. 필드 다형성</h2>
<ul>
  <li>
    필드 다형성이란 필드 타입은 동일하지만 <strong>대입되는 객체</strong>가 달라져서 실행 결과가 다양하게 나올 수 있는 것을 의미한다.
  </li>
</ul>

```java
// 1. Tire.java
package ch07.sec08.exam01;

public class Tire {
  // 메서드 선언
  public void roll() {
    System.out.println("회전합니다.");
  }
}
```

```java
// 2. HankookTire.java
package ch07.sec08.exam01;

public class HankookTire extends Tire {
  // 메서드 재정의(오버라이딩)
  @Override
  public void roll() {
    System.out.println("한국 타이어가 회전합니다.");
  }
}
```

```java
// 3. KumhoTire.java
package ch07.sec08.exam01;

public class KumhoTire extends Tire {
  // 메서드 재정의(오버라이딩)
  @Override
  public void roll() {
    System.out.println("금호 타이어가 회전합니다.");
  }
}
```

```java
// 4. Car.java
package ch07.sec08.exam01;

public class Car {
  // 필드 선언
  public Tire tire;

  // 메서드 선언
  public void run() {
    // tire 필드에 대입된 객체의 roll() 메서드 호출
    tire.roll();
  }
}
```

```java
// 5. CarExample.java
package ch07.sec08.exam01;

public class CarExample {
  public static void main(String[] args) {
    // Car 객체 생성
    Car myCar = new Car();

    // Tire 객체 장착
    myCar.tire = new Tire();
    myCar.run();

    // HankookTire 객체 장착
    myCar.tire = new HankookTire();
    myCar.run();

    // KumhoTire 객체 장착
    myCar.tire = new KumhoTire();
    myCar.run();
  }
}
```

<br>

<h2>8-2. 매개변수 다형성</h2>
<ul>
  <li>
    다형성은 필드보다 <strong>메서드를 호출</strong>할 때 많이 발생한다.
  </li>
  <li>
    메서드가 <strong>클래스 타입의 매개변수</strong>를 갖는 경우 호출할 때 동일한 타입의 객체를 제공하는 것이 정석이지만 <strong>자식 객체</strong>를 제공할 수도 있으며 이때 <strong>다형성이 발생</strong>한다.
  </li>
  <li>
    부모 클래스의 메서드에 <strong>자식 클래스의 객체를 매개변수로 전달</strong>하면, 컴파일 시점에 <strong>부모 타입으로 자동 타입 변환(업캐스팅)</strong>이 일어난다. 하지만 실행 시점에는 자식 객체에 <strong>오버라이딩된 메서드</strong>가 호출된다.
  </li>
    <ul>
      <li>
        이는 <strong>컴파일 단계</strong>에서는 매개변수의 타입이 <strong>부모 클래스</strong>로 인식되지만, <strong>실행 단계</strong>에서는 <strong>실제 객체의 타입(자식 클래스)</strong>을 기준으로 <strong>동적 바인딩(dynamic binding)</strong>이 일어나기 때문이다.
      </li>
    </ul>
  <li>
    자식 클래스를 부모 타입으로 자동 타입 변환하지 않으면, <strong>타입 불일치</strong>로 <strong>컴파일 에러</strong>가 발생하여 프로그램이 실행되지  않는다.
  </li>
</ul>

```java
// 1. Vehicle.java
package ch07.sec08.exam02;

public class Vehicle {
  // 메서드 선언
  public void run() {
    System.out.println("차량이 달립니다.");
  }
}
```

```java
// 2. Bus.java
package ch07.sec08.exam02;

public class Bus extends Vehicle {
  // 메서드 재정의(오버라이딩)
  @Override
  public void run() {
    System.out.println("버스가 달립니다.");
  }
}
```

```java
// 3. Taxi.java
package ch07.sec08.exam02;

public class Taxi extends Vehicle {
  // 메서드 재정의 (오버라이딩)
  @Override
  public void run() {
    System.out.println("택시가 달립니다.");
  }
}
```

```java
// 4. Driver.java
package ch07.sec08.exam02;

public class Driver {
  // 메서드 선언(클래스 타입의 매개변수를 가지고 있다).
  public void drive(Vehicle vehicle) {
    vehicle.run();
  }
}
```

```java
// 5. DriverExample.java
package ch07.sec08.exam02;

public class DriverExample {
  public static void main(String[] args) {
    // Driver 객체 생성.
    Driver driver = new Driver();

    // 매개값으로 Bus 객체를 제공하고 driver() 메서드 호출
    // driver.drive(new Bus()); 와 동일
    Bus bus = new Bus();
    driver.drive(bus);

    // 매개값으로 Taxi 객체를 제공하고 driver() 메서드 호출.
    // driver.drive(new Taxi());와 동일
    Taxi taxi = new Taxi();
    driver.drive(taxi);
  }
}
```

<br><br>

<h1>9. 객체 타입 확인</h1>
<ul>
  <li>
    변수가 <strong>참조하는 객체의 타입</strong>을 확인하고자할 때 <strong>instanceof 연산자</strong>를 사용한다.
  </li>
  <li>
    좌항의 객체의 타입이 <strong>우항과 동일하면 true</strong>를, <strong>일치하지 않는다면 false</strong>를 출력한다.
  </li>
  <li>
    Java12 부터는 instanceof 연산의 결과가 <strong>true</strong>일 경우 <strong>우측 타입 변수르 사용할 수 있기에</strong> 강제 타입 변환이 필요 없다.
  </li>
</ul>

```java
// 1. instanceof 연산자 형식
boolean result = 객체 instanceof 타입;
```

```java
// 2. InstanceofExample.java
package ch07.sec09;

public class InstanceofExample {
  // main() 메서드에서 바로 호출하기 위해 정적 메서드 선언.
  public static void personInfo(Person person) {
    System.out.println("name: " + person.name);
    person.walk();

    // person이 참조하는 객체가 Student 타입인지 확인.
    /* if(person instanceof Student) {
      // Student 객체일 경우 강제 타입 변환
      Student student = (Student) person;
      // Student 객체만 갖고 있는 필드 및 메서드 사용.}
      System.out.println("studentNo: " + student.studentNo);
    */

    // person이 참조하는 변수가 Student인 경우
    // student 변수에 대입(타입 변환 발생)
    if(person instanceof Student student) {
      System.out.println("studentNo: " + student.studentNo);
      student.study();
    }
  }

  public static void main(String[] args) {
    // Person 객체를 매개값을 제공하고, personInfo() 메서드 호출
    Person p1 = new Person("홍길동");
    personInfo(p1);

    System.out.println();

    // Student 객체를 매개값으로 제공하고 personInfo() 메서드 호출
    Person p2 = new Student("김길동", 10);
    personInfo(p2);
  }
}
```

```java
// 3. Person.java
package ch07.sec09;

public class Person {
  // 필드 선언
  public String name;

  // 생성자 선언
  public Person(String name) {
    this.name = name;
  }

  // 메서드 선언
  public void walk() {
    System.out.println("걷습니다.");
  }
}
```

```java
// 3. Student.java
package ch07.sec09;

public class Student extends Person {
  // 필드 선언
  public int studentNo;

  // 생성자 선언
  public Student(String name, int studentNo) {
    super(name);
    this.studentNo = studentNo;
  }

  // 메서드 선언
  public void study() {
    System.out.println("공부를 합니다.");
  }
}
```

<br><br>

<h1>10. 추상 클래스</h1>
<ul>
  <li>
    사전적으로 <strong>추상(abstract)</strong>는 실체 간에 <strong>공통되는 특성을 추출</strong>한 것을 의미한다.
  </li>
</ul>

<br>

<h2>10-1. 추상 클래스란?</h2>
<ul>
  <li>
    객체를 생성할 수 있는 클래스를 실체 클래스라고 한다면, 클래스들의 <strong>공통적인 필드나 메서드</strong>를 추출해서 선언한 클래스를 <strong>추상 클래스</strong>라 한다.
  </li>
    <ul>
      <li>
        추상 클래스는 <strong>실제 클래스의 부모</strong> 역할을 하며 실체 클래스는 <strong>추상 클래스를 상속</strong>할 수 있다.
      </li>
      <li>
        추상 클래스는 부모 용도로만 사용하기에 extends 뒤에만 올 수 있다.
      </li>
    </ul>
  <li>
    추상 클래스는 실체 클래스의 공통되는 필드와 메서드를 추출해선 만들었기 때문에 <strong>new 연산자로 객체를 생성할 수 없다</strong>.
  </li>
    <ul>
      <li>
        추상 클래스는 선언만 되어 있고 완전히 구현되지 않은 <strong>추상 메서드</strong> 등의 멤버를 포함하기 때문이다
      </li>
    </ul>
  <li>
    추상 클래스를 사용하는 이유는 <strong>공통된 규격을 강제</strong>하여 여러 자식 클래스들이 <strong>일관된 방식으로 동작</strong>하는 것을 보장하기 위해서 이다.
  </li>
</ul>

<br>

<h2>10-2. 추상 클래스 선언</h2>
<ul>
  <li>
    클래스 선언에 <strong>abstract 키워드</strong>를 붙이면 추상 클래스를 선언할 수 있다.
  </li>
  <li>
    추상 클래스는 new 연산자를 이용해서 객체를 직접 만들지 못하며 상속을 통해 <strong>자식 클래스만</strong> 만들 수 있다.
  </li>
    <ul>
      <li>
        자식 클래스는 추상 클래스의 생성자를 호출하기 때문에 추상 클래스는 생성자 또한 반드시 있어야 한다.
      </li>
    </ul>
</ul>

```java
// 1. Phone.java
package ch07.sec10.exam01;

public abstract class Phone {
  // 필드 선언
  String owner;

  // 생성자 선언
  Phone(String owner) {
    this.owner = owner;
  }

  // 메서드 선언
  void turnOn() {
    System.out.println("폰 전원을 켭니다.");
  }
  void turnOff() {
    System.out.println("폰 전원을 끕니다.");
  }
}
```

```java
// 2. SmartPhone.java
package ch07.sec10.exam01;

public class SmartPhone extends Phone {
  // 생성자 선언
  SmartPhone(String owner) {
    // Phone 생서자 호출
    super(owner);
  }
  
  // 메서드 선언
  void internetSearch() {
    System.out.println("인터넷 검색을 합니다.");
  }
}
```

```java
// 3. PhoneExample.java
package ch07.sec10.exam01;

public class PhoneExample {
  public static void main(String[] args) {
    // 추상 클래스로는 new 연산자로 객체 생성이 불가하다.
    // Phone phone = new Phone();

    SmartPhone smartPhone = new SmartPhone("홍길동");

    smartPhone.turnOn();
    smartPhone.internetSearch();
    smartPhone.turnOff();
  }
}
```

<br>

<h2>10-3. 추상 메서드와 재정의</h2>
<ul>
  <li>
    자식 클래스들이 가지고 있는 공통 메서드를 추상 클래스로 작성할 때 메서드 선언부만 동일하고 실행 내용은 <strong>자식 클래스마다 다른 경우</strong>가 많기에 이런 경우 <strong>추상 메서드</strong>를 선언할 수 있다.
  </li>
  <li>
    추상 메서드는 abstract 키워드를 붙여 생성할 수 있다.
  </li>
  <li>
    추상 메서드는 공통 메서드를 정의만 할뿐 실행 내용을 가지지 않기에 반드시 실행 내용을 <strong>자식 클래스에서 오버라이딩</strong>해야한다.
  </li>
    <ul>
      <li>
        형식만을 갖기 때문에 실핸 내용을 정의하기 위한 <strong>중괄호({})가 없</strong>.
      </li>
    </ul>
</ul>

```java
// 1. Animal.java
package ch07.sec10.exam02;

public abstract class Animal {
  // 메서드 선언
  public void breathe() {
    System.out.println("숨을 쉽니다.");
  }

  // 추상 메서드 선언
  public abstract void sound();
}
```

```java
// 2. Dog.java
package ch07.sec10.exam02;

public class Dog extends Animal {
  // 추상 메서드 재정의
  @Override
  public void sound() {
    System.out.println("멍멍");
  }
}
```

```java
// 3. Cat.java
package ch07.sec10.exam02;

public class Cat extends Animal {
  // 추상 메서드 재정의
  @Override
  public void sound() {
    System.out.println("야옹");
  }
}
```

```java
// 4. AbstractMethodExample.java
package ch07.sec10.exam02;

public class AbstractMethodExample {
  public static void main(String[] args) {
    Dog dog = new Dog();
    dog.sound();

    Cat cat = new Cat();
    cat.sound();

    // 매개변수의 다형성
    animalSound(new Dog());
    animalSound(new Cat());
  }

  public static void animalSound(Animal animal) {
    animal.sound();
  }
}
```

<br><br>

<h1>11. 봉인된 클래스</h1>
<ul>
  <li>
    Java 15부터는 <strong>무분별한 자식 클래스 생성을 방지</strong>하기 위해 <strong>봉인된(sealed) 클래스</strong>가 도입되었다.
  </li>
  <li>
    <strong>sealed 키워드</strong>를 사용하여 <strong>봉인된 클래스를 선언</strong>하고 <strong>permits 키워드</strong> 뒤에 <strong>상속 가능한 자식 클래스</strong>를 지정한다.
  </li>
  <li>
    상속되는 자식 클래스는 다른 클래스로의 상속을 막기위해 <strong>final </strong>혹은 <strong>non-sealed 키워드</strong>로 <strong>또 다른 봉인 해제</strong>로 선언한다.
  </li>
    <ul>
      <li>
        <strong>final</strong>: 더이상 상속을 할 수 없도록 막아 버린다.
      </li>
      <li>
        <strong>non-sealed</strong>: 봉인을 풀어 해당 클래스부터는 상속이 가능하도록 한다.
      </li>
    </ul>
</ul>

```java
// 1. Person.java
package ch07.sec11;

public sealed class Person permits Employee, Manager {
  // 필드
  public String name;

  // 메서드
  public void work() {
    System.out.println("하는 일이 결정되지 않았습니다.");
  }
}
```

```java
// 2. Employee.java
package ch07.sec11;

public final class Employee extends Person {
  @Override
  public void work() {
    System.out.println("제품을 생산합니다.");
  }
}
```

```java
// 3. Manager.java
package ch07.sec11;

public non-sealed class Manager extends Person {
  @Override
  public void work() {
    System.out.println("생산 관리를 합니다.");
  }
}
```

```java
// 4. Director.java
package ch07.sec11;

public class Director extends Manager {
  @Override
  public void work() {
    System.out.println("제품을 기획합니다.");
  }
}
```

```java
// 5. SealedExample.java
package ch07.sec11;

public class SealedExample {
  public static void main(String[] args) {
    Person p = new Person();
    Employee e = new Employee();
    Manager m = new Manager();
    Director d = new Director();

    p.work();
    e.work();
    m.work();
    d.work();
  }
}
```