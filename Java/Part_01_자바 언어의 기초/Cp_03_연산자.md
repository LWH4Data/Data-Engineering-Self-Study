<h1>1. 부호/증감 연산자</h1>
<ul>
  <li>
    <strong>부호 연산자</strong>는 변수의 <strong>부호를 유지</strong>하거나 <strong>변경</strong>한다.
  </li>
  <li>
    + 연산자는 잘 사용되지 않고, <strong>- 연산자</strong>는 <strong>변수값의 부호를 변경</strong>할 때 사용한다.
  </li>
  <li>
    정수 타입(byte, short, int) 연산의 결과는 <strong>int 타입</strong>이며 부호를 변경하는 것도 <strong>연산</strong>이기에 <strong>int 타입 변수</strong>에 대입해야 한다.
  </li>
  <li>
    <strong>증감 연산자(++, --)</strong>는 변수의 값을 1 증가시키거나 1 감소시키는 연산자이다.
  </li>
    <ul>
      <li>
        변수 단독으로 증감 연산자를 사용할 경우 변수의 <strong>앞과 뒤</strong> 어디에 증감 연산자가 붙더라도 결과는 동일하다.
      </li>
      <li>
        <strong>변수가 여럿</strong>인 경우 <strong>앞에 증감 연산자</strong>가 붙는다면 증감 연산자 연산을 <strong>먼저 수행</strong>하고, <strong>뒤에 붙는 경우</strong> 모든 연산을 <strong>끝낸 뒤</strong> 연산을 수행한다.
      </li>
    </ul>
</ul>

```java
// 1. SignOperatorExample.java
package ch03.sec01;

public class SignOperatorExample {
  public static void main(String[] args) {
    int x = -100;
    x = -x;
    System.out.println("x: " + x);

    byte b = 100;
    int y = -b;
    System.out.println("y: " + y); 
  }
}
```

```java
// 2. IncreaseDecreaseOperatorExample.java
package ch03.sec01;

public class IncreaseDecreaseOperatorExample {
  public static void main(String[] args) {
    int x = 10;
    int y = 10;
    int z;

    x++;
    ++x;
    System.out.println("x=" + x);
    
    System.out.println("----------------------------");
    y--;
    --y;
    System.out.println("y=" + y);

    System.out.println("----------------------------");
    z = x++;
    System.out.println("z=" + z);
    System.out.println("x=" + x);

    System.out.println("----------------------------");
    z = ++x;
    System.out.println("z=" + z);
    System.out.println("x=" + x);

    System.out.println("----------------------------");
    z = ++x + y++;
    System.out.println("z=" + z);
    System.out.println("x=" + x);
    System.out.println("y=" + y);
  }
}
```

<br><br>

<h1>2. 산술 연산자</h1>
<ul>
  <li>
    산술 연산자는 +, -, *, /, % 다섯 가지이다.
  </li>
  <li>
    산술 연산 특징 세 가지
  </li>
    <ul>
      <li>
        피연산자가 <strong>정수 타입(byte, short, char, int)</strong>이면 연산의 결과는 <strong>int</strong>이다.
      </li>
      <li>
        피연산자가 <strong>정수 타입</strong>이고, <strong>그 중 하나가 long 타입</strong>이라면 연산의 결과는 <strong>long 타입</strong>이다.
      </li>
      <li>
        피연산자 중 <strong>하나가 실수 타입</strong>이면 연산의 결과는 <strong>실수 타입</strong>이다.
      </li>
    </ul>
</ul>

```java
// 1. ArithmeticOperatorExample.java
package ch03.sec02;

public class ArithmeticOperatorExample {
  public static void main(String[] args) {
    byte v1 = 10;
    byte v2 = 4;
    int v3 = 5;
    long v4 = 10L;

    // 모든 피연산자는 int 타입으로 자동 변환 후 연산
    int result1 = v1 + v2;
    System.out.println("result1: " + result1);
    
    // 모든 피연산자는 long 타입으로 자동 변환 후 연산
    long result2 = v1 + v2 - v4;
    System.out.println("result2: " + result2);

    // double 타입으로 강제 변환 후 연산.
    double result3 = (double) v1 / v2;
    System.out.println("result3: " + result3);

    int result4 = v1 % v2;
    System.out.println("result4: " + result4);
  }
}
```

<br><br>

<h1>3. 오버플로우와 언더플로우</h1>
<ul>
  <li>
    <strong>오버플로우(overflow)</strong>란 타입이 허용하는 <strong>최대값을 벗어나는 것</strong>을 의미한다.
  </li>
  <li>
    <strong>언더플로우(underflow)</strong>는 타입이 허용하는 <strong>최소값을 벗어나는 것</strong>을 의미한다.
  </li>
  <li>
    오버플로우 혹은 언더플로우 발생 시 에러가 발생하지는 않고 오버플로우는 최솟값으로, 언더 플로우는 최댓값으로 돌아가 <strong>순환</strong>된다.
  </li>
  <li>
    오버플로우와 언더플로우는 예상하는 값이 나오지 않기 때문에 범위가 초과할 것 같다면 <strong>long 타입으로 변환</strong>하여 수행해야 한다.
  </li>
</ul>

```java
// 1. OverflowUnderflowExample.java
package ch03.sec03;

public class OverflowUnderflowExample {
  public static void main(String[] args) {
    byte var1 = 125;
    // 5회 반복 연산
    for(int i=0; i<5; i++) {
      // ++연산은 var1의 값을 1 증가시킨다.
      var1++;
      System.out.println("var1: " + var1);
    }

    System.out.println("------------------------");

    byte var2 = -125;
    // 5회 반복 연산
    for(int i=0; i<5 ; i++) {
      // --연산은 var2의 값을 1 감소시킨다.
      var2--;
      System.out.println("var2: " + var2);
    }
  }
}
```

<br><br>

<h1>4. 정확한 계산은 정수 연산으로</h1>
<ul>
  <li>
    산술 연산을 정확히 계산하려 한다면 <strong>실수 타입을 사용하지 않는 것</strong>이 좋다.
  </li>
</ul>

```java
// 1. AccuracyExample.java
//   - 부동 소수점 문제로 인해 정확한 결과를 얻을 수 없다.
package ch03.sec04;

public class AccuracyExample {
  public static void main(String[] args) {
    int apple = 1;
    double pieceUnit = 0.1;
    int number = 7;

    double result = apple - number * pieceUnit;
    System.out.println("사과 1개에서 남은 양: " + result);
  }
}
```

```java
// 2. AccuracyExample2.java
//   - 정수 연산으로 변환하면 정확한 결과를 얻을 수 있다.
package ch03.sec04;

public class AccuracyExample2 {
  public static void main(String[] args) {
    int apple = 1;
    int totalPieces = apple * 10;
    int number = 7;

    int result = totalPieces - number;
    System.out.println("10조각에서 남은 조각: " + result);
    System.out.println("사과 1개에서 남은 양: " + result/10.0);
  }
}
```

<br><br>

<h1>5. 나눗셈 연산 후 Nan과 Infinity 처리</h1>
<ul>
  <li>
    <strong>0이 포함된 연산</strong>을 수행할 때 정수 타입 연산은 <strong>Infinity</strong> 혹은 <strong>NaN</strong>이 출력되지 않도록 <strong>예외(ArithmeticException)</strong>를 발생시킨다.
  </li>
  <li>
    그러나 실수를 포함한 연산을 수행할 때에는 <strong>Infinity</strong> 혹은 <strong>NaN(Not a Number)</strong>이 발생하여 데이터가 망가질 수 있다.
  </li>
    <ul>
      <li>
        이때에는 <strong>Double.isInfinite()</strong>와 <strong>Double.isNaN()</strong>을 사용하여 Infinity와 NaN의 여부를 확인할 수 있다.
      </li>
    </ul>
</ul>

```java
// 1. InfinityAndNaNCheckExample.java
package ch03.sec05;

public class InfinityAndNaNCheckExample {
  public static void main(String[] args) {
    int x = 5;
    double y = 0.0;
    double z = x / y;
    // double z = x % y;

    // 잘못된 코드
    System.out.println(z + 2);

    // 올바른 코드
    if(Double.isInfinite(z) || Double.isNaN(z)) {
        System.out.println("값 산출 불가");
    } else {
      System.out.println(z + 2);
    }
  }
}
```

<br><br>

<h1>6. 비교 연산자</h1>
<ul>
  <li>
    비교 연산자는 <strong>동등(==, !=)</strong> 또는 <strong>크기(<. <=, >, >=)</strong>를 평가하여 <strong>boolean 타입(true/false)</strong>을 산출한다.
  </li>
  <li>
    피연산자의 타입이 다른 경우 비교 연산을 수행하기 전에 <strong>타입을 일치</strong>시킨다.
  </li>
    <ul>
      <li>
        단, double 타입과 float 타입의 비교는 <strong>부동 소수점</strong> 문제로 인해 정확한 결과가 반환되지 않는다. 이때에는 <strong>float으로 강제 타입 변환</strong>을 수행한 후 연산을 수행한다.
      </li>
    </ul>
  <li>
    <strong>문자열</strong>을 비교할 때에는 <strong>equals()</strong>와 <strong>!equals()</strong>를 사용한다. 이유는 5장에서 다룬다.
  </li>
</ul>

```java
// 1. CompareOperatorExample.java
package ch03.sec06;

public class CompareOperatorExample {
  public static void main(String[] args) {
    int num1 = 10;
    int num2 = 10;
    boolean result1 = (num1 == num2);
    boolean result2 = (num1 != num2);
    boolean result3 = (num1 <= num2);
    System.out.println("result1: " + result1);
    System.out.println("result2: " + result2);
    System.out.println("result3: " + result3);

    char char1 = 'A';
    char char2 = 'B';
    boolean result4 = (char1 < char2); // 65 < 66
    System.out.println("result5: " + result4);

    int num3 = 1;
    double num4 = 1.0;
    boolean result5 = (num3 == num4);
    System.out.println("result5: " + result5);

    float num5 = 0.1f;
    double num6 = 0.1;
    boolean result6 = (num5 == num6);
    boolean result7 = (num5 == (float)num6);
    System.out.println("result6: " + result6);
    System.out.println("result7: " + result7);

    String str1 = "자바";
    String str2 = "Java";
    boolean result8 = (str1.equals(str2));
    boolean result9 = (! str1.equals(str2));
    System.out.println("result8: " + result8);
    System.out.println("result9: " + result9);
  }
}
```

<br><br>

<h1>7. 논리 연산자</h1>
<ul>
  <li>
    논리 연산자는 <strong>논리곱(&&)</strong>, <strong>논리합(||)</strong>, <strong>배타적 논리합(^)</strong> 그리고 <strong>논리 부정(!)</strong> 연산을 수행한다.
  </li>
  <li>
    논리 연산자는 주로 <strong>조건문(if)</strong> 혹은 <strong>반복문(for)</strong> 등에서 주로 사용한다.
  </li>
  <li>
    <strong>&&</strong>와 <strong>||</strong>는 앞의 연산자에 따라 <strong>뒤의 연산을 수행하지 않기에</strong> &와 |보다는 효율적이다.
  </li>
    <ul>
      <li>
        &와 |은 앞의 연산 결과와 상관없이 뒤의 논리 연산도 수행하기에 비교적 비효율적이다.
      </li>
    </ul>
</ul>

```java
// 1. LogicalOperatorExample.java
package ch03.sec07;

public class LogicalOperatorExample {
  public static void main(String[] args) {
    int charCode = 'A';
    // int charCode = 'a';
    // int charCode = '5';

    if( (65<=charCode) & (charCode <= 90) ) {
      System.out.println("대문자이군요.");
    }

    if( (97<=charCode) && (charCode<=90) ) {
      System.out.println("소문자이군요.");
    }

    if( (48<=charCode) && (charCode<=57) ) {
      System.out.println("0-9 숫자이군요.");
    }

    //-----------------------------------------------

    int value = 6;
    // int value = 7;

    if( (value%2==0) | (value%3==0) ) {
      System.out.println("2 또는 3의 배수이군요.");
    }

    boolean result = (value%2==0) || (value%3==0);
    if( !result ) {
      System.out.println("2 또는 3의 배수가 아니군요.");
    }
  }
}
```

<br><br>

<h1>8. 비트 논리 연산자</h1>
<ul>
  <li>
    비트 논리 연산자는 <strong>bit 단위</strong>로 논리 연산을 수행하기에 <strong>0과 1이 피연산자</strong>가 된다. 
  </li>
    <ul>
      <li>
        따라서 <strong>정수 타입(byte, short, int, long)</strong>만 피연산자가 될 수 있고, 부동 소수점 방식으로 저장되는 실수 타입(float, double)은 피연산자가 될 수 없다.
      </li>
    </ul>
  <li>
    비트 논리 연산자에는 <strong>AND(&), OR(|), XOR(^) 그리고 NOT(~)</strong>이 있다.
  </li>
  <li>
    비트 논리 연산자는 byte, short, char 타입 피연산자를 <strong>int 타입으로 자동 변환</strong>한 후에 연산을 수행하기에 <strong>연산 결과도 int 타입 변수에 대입</strong>해야 한다.
  </li>
  <li>
    자바는 최상위 비트를 부호로 인지하는데 이를 적용하지 않고 변환할 때에는 <strong>toUnsignedInt()</strong>를 사용할 수 있다.
  </li>
</ul>

```java
// 1. BitLogicExample.java
package ch03.sec08;

public class BitLogicExample {
  public static void main(String[] args) {
    System.out.println("45 & 25 = " + (45 & 25));
    System.out.println("45 | 25 = " + (45 | 25));
    System.out.println("45 ^ 25 = " + (45 ^ 25));
    System.out.println("-45 = " + (-45));
    System.out.println("----------------------------");

    byte receiveData = -120;

    // 방법1: 비트 논리곱 연산으로 Unsigned 정수 얻기
    int unsignedInt1 = receiveData & 255;
    System.out.println(unsignedInt1);

    // 방법2: 자바 API를 이용해서 Unsigned 정수 얻기.
    int unsignedInt2 = Byte.toUnsignedInt(receiveData);
    System.out.println(unsignedInt2);

    int test = 136;
    byte btest = (byte) test;
    System.out.println(btest);
  }
}
```

<br><br>

<h1>9. 비트 이동 연산자</h1>
<ul>
  <li>
    비트 좌측 혹은 우측 연산자는 <strong>비트를 밀어서 이동시키는 연산</strong>을 수행한다.
  </li>
  <li>
    <strong>음수는 보수</strong>이기에 음의 비트를 우측으로 이동하면 좌측은 <strong>1</strong>로 채워진다.
  </li>
    <ul>
      <li>
        단, <strong>>>></strong>로 비트 이동을 하는 경우에는 <strong>0</strong>으로 채워진다.
      </li>
    </ul>
</ul>

```java
// 1. BitShiftExample.java
package ch03.sec09;

public class BitShiftExample {
  public class void main(String[] args) {
    int num1 = 1;
    int result1 = num << 3;
    // int로 결괄르 반환받기위해 casting
    int result2 = num1 * (int) Math.pow(2, 3);
    System.out.println("result1: " + result1);
    System.out.println("reuslt2: " + reuslt2);
    int num2 = -8;
    int result3 = num2 >> 3;
    int result4 = num2 / (int) Math.pow(2, 3);
    System.out.println("result3: " + result3);
    System.out.println("result4: " + result4);
  }
}
```

```java
// 2. BitShiftExample2.java
package ch03.sec09;

public class BitShiftExample2 {
  public static void main(String[] args) {
    int value = 772; // [00000000] [00000000] [00000011] [00000100]

    // 우측으로 3byte(24bit) 이동하고 끝 1바이트만 읽음:[00000000]
    byte byte1 = (byte) (value >>> 24);
    int int1 = byte1 & 255;
    System.out.println("첫 번째 바이트 부호 없는 값: " + int1);

    // 우측으로 2byte(16bit) 이동하고 끝 1바이트만 읽음:[00000000]
    byte byte2 = (byte) (value >>> 16);
    int int2 = Byte.toUnsignedInt(byte2);
    System.out.println("두 번째 바이트 부호 없는 값: " + int2);

    // 우측으로 1byte(8bit) 이동하고 끝 1바이트만 읽음: [00000011]
    byte byte3 = (byte) (value >>> 8);
    int int3 = byte3 & 255;
    System.out.println("세 번째 바이트 부호 없는 값: " + int3);

    // 끝 1바이트만 읽음: [00000100]
    byte byte4 = (byte) value;
    int int4 = Byte.toUnsignedInt(byte4);
    System.out.println("네 번째 바이트 부호 없는 값: " + int4);
  }
}
```

<br><br>

<h1>10. 대입 연산자</h1>
<ul>
  <li>
    대입 연산자는 우측 피연산자에는 리터럴 및 변수, 그리고 연산식이 오며 결과를 <strong>좌측 피연산자 변수에 대입</strong>을 한다.
  </li>
  <li>
    p104의 장표에서 전체 연산자를 확인할 수 있다.
  </li>
</ul>

```java
// 1. AssignmentOperatorExample.java
package ch03.sec10;

public class AssignmentOperatorExample {
  public static void main(String[] args) {
    int result = 0;
    result += 10;
    System.out.println("result=" + result);
    result -= 5;
    System.out.println("result=" + result);
    result *= 3;
    System.out.println("result=" + result);
    result /= 5;
    System.out.println("result=" + result);
    result %= 3;
    System.out.println("result=" + result);
  }
}
```

<br><br>

<h1>11. 삼항(조건) 연산자</h1>
<ul>
  <li>
    <strong>삼항 연산자(피연산자 ? 피연산자 : 피연산자)</strong>는 총 세 개의 피연산자를 갖는다.
  </li>
    <ul>
      <li>
        <strong>첫 번째 피연산자</strong>: boolean 변수 혹은 조건식이 오며 <strong>조건 연산자</strong>라고도 한다.
      </li>
      <li>
        첫 번째 피연산자의 값이 <strong>true</strong>라면 <strong>두 번째 피연산자</strong>를 선택하고 <strong>false</strong>라면 <strong>세 번째 피연산자</strong>를 선택한다.
      </li>
      <li>
        두 번째 및 세 번째 피연산자는 보통 값이 오지만 경우에 따라 다른 연산식이 올 수도 있다.
      </li>
    </ul>
</ul>

```java
// 1. ConditionalOperationExample.java
package ch03.sec11;

public class ConditionalOperationExample {
  public static void main(String[] args) {
    int score = 85;
    char grade = (score > 90) ? 'A' : ( (score > 80 ) ? 'B' : 'C' );
    System.out.println(score + "점은" + grade + "등급입니다.");
  }
}
```

<br><br>

<h1>12. 연산의 방향과 우선순위</h1>
<ul>
  <li>
    연산자는 우선 순위에 따라 연산이 수행된다.
  </li>
  <li>
    동일한 우선 순위를 갖는다면 → 방향으로 연산을 수행한다.
  </li>
  <li>
    단, <strong>대입 연산자</strong>는 <strong>역방향인 ←</strong>로 연산이 진행된다.
  </li>
  <li>
    우선 순위는 107p에 정리되어 있으며 필요할 때마다 확인하면 된다.
  </li>
  <li>
    연산이 복잡하다면 우선 순위를 확인하기 어렵기에 <strong>먼저 처리해야할 연산</strong>을 <strong>괄호</strong>로 묶어주는 것이 좋다.
  </li>
</ul>