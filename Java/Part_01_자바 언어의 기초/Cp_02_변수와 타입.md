<h1>1. 변수 선언</h1>
<ul>
  <li>
    <strong>변수(variable)</strong>란 하나의 값을 저장할 수 있는 <strong>메모리 번지</strong>에 붙여진 이름이다.
  </li>
  <li>
    변수를 사용하기 위해서는 <strong>변수 선언</strong>이 필요하며 <strong>어떤 타입의 데이터</strong>를 저장할 것인지와 <strong>변수 이름</strong>을 결정한다.
  </li>
    <ul>
      <li>
        첫 글자는 <strong>문자</strong>여야 하고, 중간은 문자, 숫자, $, _를 포함할 수 있다.
      </li>
      <li>
        첫 문자는 <strong>소문자</strong>로 시작하며 <strong>캐멀 스타일</strong>로 작성하는 것이 관례이다.
      </li>
    </ul>
  <li>
    변수를 선언한 후에는 값을 저장할 수 있으며 대입 연산자인 <strong>=</strong> 을 사용한다.
  </li>
    <ul>
      <li>
        수학에서는 = 가 같다의 의미이지만 java에서는 <strong>우측 값을 좌측 변수에 대입하는 연산자</strong>이다.
      </li>
    </ul>
  <li>
    변수의 이름은 충분히 길어도 되지만 어떤 값을 저장하는지 알기 쉽게 지어주는 것이 좋다.
  </li>
  <li>
    변수가 선언될 떄가 아닌 <strong>최초로 값이 대입</strong>될 때 <strong>메모리에 할당</strong>된다.
  </li>
    <ul>
      <li>
        최초로 값을 대입하는 행위를 <strong>변수 초기화</strong>라 하며 이때의 값을 <strong>초기값</strong>이라 한다.
      </li>
    </ul>
  <li>
    변수는 또 다른 변수에 대입되어 메모리 간에 값을 복사할 수 있다.
  </li>
</ul>

```java
// 1. VariableInitializationExample.java
//   - value를 초기화하지 않았기에 오류가 발생한다.

package ch02.sec01;

public class VariableInitializationExample {
  public static void main(String[] args) {
    // 변수 value 선언
    int value;

    // 연산 결과를 변수 result의 초기값으로 대입.
    int result = value + 10;

    // 변수 result 값을 읽고 콘솔에 출력.
    System.out.println(result);
  }
}
```

```java
// 2. VariableUseExample.java
package ch02.sec01;

public class VariableUseExample {
  public static void main(String[] args) {
    int hour = 3;
    int minute = 5;
    System.out.println(hour + "시간" + minute + "분");

    int totalMinute = (hour*60) + minute;
    System.out.println("총 " + totalMinute + "분");
  }
}
```

```java
package ch02.sec01;

public class VariableExchangeExample {
  public static void main(String[] args) {
    // 변수 초기화
    int x = 3;
    int y = 5;
    System.out.println("x:" + x + ", y:" + y);

    // temp에 x 값을 복사
    int temp = x;
    // x에는 y의 값을 복사
    x = y;
    y = temp;
    System.out.println("x:" + x + ", y:" + y);
  }
}
```

<br><br>

<h1>2. 정수 타입</h1>
<ul>
  <li>
    Java는 정수, 실수 그리고 논리값을 저장할 수 있는 기본(primitive) 타입 8개를 제공한다.
  </li>
  <li>
    타입에 저장되는 값의 허용 범위를 외울 필요 없지만 <strong>메모리의 할당 크기</strong> 정도는 알고 있으면 좋다.
  </li>
    <ul>
      <li>
        <strong>byte</strong>: 8
      </li>
      <li>
        <strong>short</strong>: 16
      </li>
      <li>
        <strong>int</strong>: 32
      </li>
      <li>
        <strong>long</strong>: 64
      </li>
    </ul>
  <li>
    최상위 비트는 <strong>부호 bit</strong>로 사용하고 나머지 bit는 <strong>값의 범위</strong>를 결정한다.
  </li>
  <li>
    최상위 bit가 1인 경우는 <strong>음수</strong>를 의미한다.
  </li>
    <ul>
      <li>
        음수의 경우 부호 bit를 제외한 나머지 부분을 <strong>1의 보수</strong>로 바꾸고 <strong>1을 더한 값</strong>에 <strong>-</strong>을 붙이면 10 진수가 된다.
      </li>
    </ul>
  <li>
    코드에서 프로그래머가 직접 입력한 값을 <strong>리터럴(literal)</strong>이라 하며 변수에 대입할 <strong>정수 리터럴</strong>은 <strong>진수</strong>에 따라 작성법이 다르다. (하단의 코드 참고).
  </li>
  <li>
    기본적으로 컴파일러는 정수 리터럴을 int로 간주하기에 int 허용범위를 초과하는 리터럴은 뒤에 <strong>'l'</strong> 혹은 <strong>'L'</strong>을 붙여 long 임을 알려야 한다.
  </li>
  <li>
    char 타입 변수에 어떤 문자도 대입하지 않고 단순히 초기화를 할 목적이라면 <strong>공백(유니코드: 32)</strong> 하나를 포함해서 초기화 한다.
  </li>
</ul>

```java
// 1. IntegerLiteralExample.java
package ch02.sec02;

public class IntegerLiteralExample {
  public static void main(String[] args) {
    int var1 = 0b1011;    // 2 진수: 0b 혹은 0B로 시작하며 0과 1로 작성.
    int var2 = 0206;      // 8 진수: 0으로 시작하며 0 ~ 7의 숫자로 작성.
    int var3 = 365;       // 10 진수: 소수점이 없는 0 ~ 9의 숫자로 작성.
    int var4 = 0xB3;      // 16진수: 0x 혹은 0X로 시작하며 0 ~ 9 숫자와 A
                          //        (a) ~ F(f)로 작성.

    System.out.println("var1:" + var1);
    System.out.println("var2:" + var2);
    System.out.println("var3:" + var3);
    System.out.println("var4:" + var4);
  }
}
```

```java
// 2. ByteExample.java
//   - byte 타입 변수 허용 범위 초과 시 오류를 발생한다.
package ch02.sec02;

public class ByteExample {
  public static void main(String[] args) {
    byte var1 = -128;
    byte var2 = -30;
    byte var3 = 0;
    byte var4 = 30;
    byte var5 = 127;
    // 범위 초과로 컴파일 에러 Type mismatch: cannot convert from int to byte 발생.
    byte var6 = 128;

    System.out.println(var1);
    System.out.println(var2);
    System.out.println(var3);
    System.out.println(var4);
    System.out.println(var5);
  }
}
```

```java
// 3. LongExample.java
//   - 수치가 큰 데이터는 long 타입으로 관리.
package ch02.sec02;

public class LongExample {
  public static void main(String[] args) {
    long var1 = 10;
    // L을 붙여 long 임을 알림.
    long var2 = 20L;
    // int 범위를 초과하였으나 long임을 알리지 않아 오류가 발생한다.
    long var3 = 1000000000000;
    long var4 = 1000000000000L;

    System.out.println(var2);
    System.out.println(var2);
    System.out.println(var4);
  }
}
```

<br><br>

<h1>3. 문자 타입</h1>
<ul>
  <li>
    하나의 문자를 <strong>작은따옴표(')</strong>로 감싼 것을 문자열이라 한다.
  </li>
  <li>
    문자열은 <strong>유니코드</strong>로 변환되어 저장되며 유니코드란 세계 각국의 문자를 <strong>0 ~ 65535 숫자</strong>로 매핑한 국제 표준 규약이다.
  </li>
  <li>
    자바는 유니코드를 저장할 수 있도록 <strong>char 타입</strong>을 제공한다.
  </li>
    <ul>
      <li>
        유니코드가 정수이기에 <strong>char 타입도 정수</strong>에 속한다. 따라서 char에는 문자 뿐만 아니라 <strong>숫자를 직접 대입</strong>할 수도 있다.
      </li>
    </ul>
</ul>

```java
// 1. CharExample.java
package ch02.sec03;

public class CharExample {
  public static void main (String[] args) {
    // 문자로 초기화
    char c1 = 'A';
    // 유니코드 숫자로 초기화
    char c2 = 65;

    char c3 = '가';
    char c4 = 44032;

    System.out.println(c1);
    System.out.println(c2);
    System.out.println(c3);
    System.out.println(c4);
  }
}
```

<br><br>

<h1>4. 실수 타입</h1>
<ul>
  <li>
    실수 타입에는 <strong>float</strong>과 <strong>double</strong>이 있다.
  </li>
    <ul>
      <li>
        <strong>double</strong>이 float 보다 차지하는 메모리는 크지만 값의 허용 범위와 유효 소수 이하 자리가 더 넓어 <strong>정밀도</strong>가 더 높다.
      </li>
    </ul>
  <li>
    자바는 IEEE 754 표준에 근거해 float 타입과 double 타입의 값을 <strong>부동 소수점(floating-point)</strong> 방식으로 메모리에 저장한다.
  </li>
    <ul>
      <li>
        즉, <strong>부호 + 가수(mantissa) + 지수(exponent)</strong>
      </li>
    </ul>
  <li>
    컴파일러는 실수 리터럴을 <strong>기본적으로 double 타입</strong>으로 해석하기 때문에 double 타입 변수에 대입해야 한다.
  </li>
    <ul>
      <li>
        float 타입에 대입하고 싶다면 리터럴 뒤에 소문자 <strong>'f'</strong> 혹은 대문자 <strong>'F'</strong>붙여 컴파일러가 float 타입임을 알게 한다.
      </li>
    </ul>
</ul>

```java
// 1. FloatDoubleExample.java
package ch02.sec04;

public class FloatDoubleExample {
  public static void main(String[] args) {
    // 정밀도 확인.
    float var1 = 0.1234567890123456789f;
    double var2 = 0.1234567890123456789;
    System.out.println("var1:" + var1);
    System.out.println("var2:" + var2);

    // 10의 거듭제곱 리터럴
    double var3 = 3e6;
    float var4 = 3e6F;
    double var5 = 2e-3;
    System.out.println("var3:" + var3);
    System.out.println("var4:" + var4);
    System.out.println("var5:" + var5);
  }
}
```

<br><br>

<h1>5. 논리 타입</h1>
<ul>
  <li>
    논리 리터럴은 true와 false이며 <strong>boolean 타입 변수</strong>에 대입할 수 있다.
  </li>
  <li>
    <strong>비교 및 논리 연산</strong>의 산출값은 true 혹은 false 이기에 boolean 타입의 변수에 대입할 수 있다.
  </li>
</ul>

```java
// 1. BooleanExample.java
package ch02.sec05;

public class BooleanExample {
  public static void main(String[] args) {
    boolean stop = true;
    if(stop) {
      System.out.println("중지합니다.");
    } else {
      System.out.println("시작합니다.");
    }

    int x = 10;
    boolean result1 = (x == 20);
    boolean result2 = (x != 20);
    System.out.println("result1: " + result1);
    System.out.println("result2: " + result2);
  }
}
```

<br><br>

<h1>6. 문자열 타입</h1>
<ul>
  <li>
    <strong>큰따옴표(")</strong>로 감싼 여러 개의 문자들은 <strong>문자열</strong>로 <strong>유니코드로 변환되지 않는다</strong>.
  </li>
  <li>
    문자열을 변수에 저장하고 싶다면 <strong>String 타입</strong>을 사용한다.
  </li>
  <li>
    문자열 내부에 <strong>역슬래쉬(\)</strong>가 붙은 문자는 <strong>이스케이프(escape) 문자</strong>라하며 <strong>특정 문자를 포함</strong>하거나 <strong>출력 설정을 조정</strong>할 때 사용한다.
  </li>
  <li>
    <strong>큰따옴표 세 개(""")</strong>로 감싸면 이스케이프문 혹은 라인피드를 할 필요 없이 <strong>그대로 문자열로 저장</strong>된다.
  </li>
</ul>

```java
// 1. StringExample.java
package ch02.sec06;

public class StringExample {
  public static void main(String[] args) {
    String name = "홍길동";
    String job = "프로그래머";
    System.out.println(name);
    System.out.println(job);

    String str = "나는 \"자바\"를 배웁니다.";
    System.out.println(str);

    str = "번호\t이름\t직업 ";
    System.out.println(str);

    System.out.println("나는\n");
    System.out.println("자바를\n");
    System.out.println("배웁니다.");
  }
}
```

```java
// 2. TextBlockExample.java
package ch02.sec06;

public class TextBlockExample {
  public static void main(String[] args) {
    String str1 = "" + 
    "{\n" +
    "\t\"id\":\"winter\",\n" +
    "\t\"name\":\"눈송이\"\n" +
    "}";

    String str2 = """
    {
      "id":"winter",
      "name":"눈송이"
    }
    """;

    System.out.println(str1);
    System.out.println("--------------------------------");
    System.out.println(str2);
    System.out.println("--------------------------------");
    String str = """
    나는 자바를 \
    학습합니다.
    나는 자바 고수가 될 겁니다.
    """;
    System.out.println(str);
  }
}
```
<br><br>

<h1>7. 자동 타입 변환</h1>
<ul>
  <li>
    자동 타입 변환(promotion)은 자동으로 타입 변환이 일어나는 것을 의미하며 값의 <strong>허용 범위가 작은 타입이 허용 범위가 큰 타입으로 대입</strong>될 때 발생한다.
  </li>
    <ul>
      <li>
        byte < short, char < int < long < float < double
      </li>
    </ul>
  <li>
    정수 타입이 실수 타입으로 대입될 경우 실수 타입이 정수 타입보다 크기에 무조건 <strong>실수 타입으로 자동 타입 변환</strong>된다.
  </li>
  <li>
    char 또한 int로 자동 변환된다. 단, <strong>byte</strong>는 <strong>부호를 포함</strong>하기에 <strong>char로 자동 타입 변환이 일어나지 않는다</strong>.
  </li>
</ul>

```java
// 1. PromotionExample.java
package ch02.sec07;

public class PromotionExample {
  public static void main(String[] args) {
    // 자동 타입 변환.
    byte byteValue = 10;
    int intValue = byteValue;
    System.out.println("intValue: " +  intValue);

    char charValue = '가';
    intValue = charValue;
    System.out.println("가의 유니코드: " + intValue);

    intValue = 50;
    long longValue = intValue;
    System.out.println("longValue: " + longValue);

    longValue = 100;
    float floatValue = longValue;

    System.out.println("floatValue: " + floatValue);

    floatValue = 100.5F;
    double doubleValue = floatValue;
    System.out.println("doubleValue: " + doubleValue);
  }
}
```

<br><br>

<h1>8. 강제 타입 변환</h1>
<ul>
  <li>
    큰 허용 범위 타입은 작은 허용 범위 타입으로 변환될 수 없는데 이때 큰 허용 범위 타입을 작은 허용 범위 타입으로 <strong>쪼개어서 저장</strong>하는 것을 <strong>강제 타입 변환(casting)</strong>이라 한다.
  </li>
    <ul>
      <li>
        강제 타입 변환은 캐스팅 연산자로 <strong>괄호()</strong>를 사용하며 괄호 안에 들어가는 타입은 <strong>쪼개는 단위</strong>이다.
      </li>
    </ul>
  <li>
    단, 강제 타입 변환을 할 때에 큰 타입은 변환되는 <strong>작은 타입의 범위 안</strong>에 있어야 한다.
  </li>
</ul>

```java
// 1. CastingExample.java
package ch02.sec08;

public class CastingExample {
  public static void main(String[] args) {
    // int → byte
    int var1 = 10;
    byte var2 = (byte) var1;
    System.out.println(var2);

    // long → int
    long var3 = 300;
    int var4 = (int) var3;
    System.out.println(var4);

    // int → char
    int var5 = 65;
    char var6 = (char) var5;
    System.out.println(var6);

    // double → int
    double var7 = 3.14;
    int var8 = (int) var7;
    System.out.println(var8);
  }
}
```

<br><br>

<h1>9. 연산식에서 자동 타입 변환</h1>
<ul>
  <li>
    Java는 <strong>컴파일 단계</strong>에서 <strong>연산을 수행</strong>하여 바이트코드를 생성한다. 따라서 실행 시 연산을 하지 않기에 실행 성능은 좋아진다.
  </li>
  <li>
    <strong>변수</strong>가 피연산자로 사용되면 <strong>실행 시</strong> 연산을 수행하며 int 타입보다 작은 byte, short 타입의 변수는 <strong>int로 자동 변횐</strong>된다.
  </li>
    <ul>
      <li>
        int 타입으로 변환 되기에 애초에 <strong>변수로 연산</strong>을 한다면 <strong>int 타입으로 변수를 초기화</strong>하는 것이 좋다.
      </li>
      <li>
        int 타입보다 허용 범위가 큰 <strong>long 타입이 피연산자</strong>로 사용되면 다른 피연산자는 <strong>long 타입으로 변환</strong>되어 연산이 수행되며 따라서 <strong>결과 또한 long 타입 변수</strong>에 저장해야 한다.
      </li>
    </ul>
  <li>
    실수
  </li>
    <ul>
      <li>
        <strong>float</strong>과 double이라면 <strong>double 타입</strong>으로 변환되어 연산을 수행하며 double 타입을 반환한다.
      </li>
      <li>
        <strong>int</strong> 타입과 double 타입을 연산할 때에도 <strong>double 타입</strong>으로 변환되어 연산이 수행된다.
      </li>
        <ul>
          <li>
            따라서 int 타입의 연산이 필요한 경우 강제로 int 타입으로 변환한 뒤 연산을 수행한다.
          </li>
        </ul>
    </ul>
  <li>
    Java는 int 타입의 연산 결과는 <strong>항상 int</strong>이기에 <strong>소수점</strong>이 포함된 결과를 반환받고자 한다면 <strong>실수형</strong>으로 변환하여 연산을 수행해야 한다.
  </li>
    <ul>
      <li>
        int와 double 연산은 double로 수행되기에 <strong>하나의 int 타입 변수</strong>만 double로 타입을 변환하여 연산을 수행할 수도 있다.
      </li>
    </ul>
  <li>
    Java에서 <strong>+ 연산자</strong>는 피연산자가 모두 <strong>숫자</strong>일 경우 <strong>덧셈 연산</strong>을 수행하고, 피연산자 중 <strong>하나가 문자열</strong>일 경우 <strong>문자열 결합 연산</strong>을 수행한다.
  </li>
    <ul>
      <li>
        연산식은 앞에서부터 <strong>순차적</strong>으로 + 연산을 수행한다.
      </li>
      <li>
        먼저 수행된 연산이 숫자인 경우 덧셈 연산을 수행하지만 만약 먼저 수행된 연산이 <strong>결합 연산</strong>이라면 <strong>이후 + 연산은 결합연산</strong>이 된다.
      </li>
      <li>
        앞에서부터 순차적으로 + 연산을 수행하지 않고 <strong>특정 부분을 우선 연산</strong>하고 싶다면 해당 부분을 <strong>괄호()</strong>로 감싼다.
      </li>
    </ul>
</ul>

```java
// 1. OperationPromotionExample.java
package ch02.sec09;

public class OperationPromotionExample {
  public static void main(String[] args) {
    // 컴파일 단계에서 연산
    byte result1 = 10 + 20;
    System.out.println("result1: " + result1);

    byte v1 = 10;
    byte v2 = 20;
    // int 타입으로 변환 후 연산
    int result2 = v1 + v2;
    System.out.println("result2: " + result2);

    byte v3 = 10;
    int v4 = 100;
    long v5 = 1000L;
    // long 타입으로 변환 후 연산
    long result3 = v3 + v4 + v5;
    System.out.println("result3: " + result3);

    char v6 = 'A';
    char v7 = 1;
    // int 타입으로 변환 후 연산
    int result4 = v6 + v7;
    System.out.println("result4: " + result4);
    // char로 타입 변환하여 출력.
    System.out.println("result4: " + (char)result4);

    int v8 = 10;
    int result5 = v8 / 4;
    System.out.println("result5: " + result5);

    int v9 = 10;
    // double 타입 변환 후 연산
    double result6 = v9 / 4.0;
    System.out.println("result6: " + result6);

    int v10 = 1;
    int v11 = 2;
    // double 타입으로 변환 후 연산
    double result7 = (double) v10 / v11;
    System.out.println("result7: " + result7);
  }
}
```

```java
// 2. StringConcatExmaple.java
package ch02.sec09;

public class StringConcatExample {
  public static void main(String[] args) {
    // 숫자 연산
    int result1 = 10 + 2 + 8;
    System.out.println("result1: " + result1);

    // 결합 연산
    String result2 = 10 + 2 + "8";
    System.out.println("result2: " + result2);

    String result3 = 10 + "2" + 8;
    System.out.println("result3: " + result3);

    String result4 = "10" + 2 + 8;
    System.out.println("result4: " + result4);

    String result5 = "10" + (2 + 8);
    System.out.println("result5: " + result5);
  }
}
```

<br><br>

<h1>10. 문자열을 기본 타입으로 변환</h1>
<ul>
  <li>
    문자열을 각종 타입으로 변환할 떄에는 <strong>[Type].parse[Type]</strong>을 사용한다. 예를들어 int라면 <strong>Integer.parseInt</strong>이다.
  </li>
  <li>
    반대로 기본 타입을 <strong>문자열로 변경</strong>하는 경우 <strong>String.valueOf() 메소드</strong>를 사용한다. 즉, <strong>String.valueOf(기본타입값);</strong> 이다.
  </li>
</ul>

```java
// 1. PrimitiveAndStringConversionExample.java
package ch02.sec10;

public class PrimitiveAndStringConversionExample {
  public static void main(String[] args) {
    int value1 = Integer.parseInt("10");
    double value2 = Double.parseDouble("3.14");
    boolean value3 = Boolean.parseBoolean("true");

    System.out.println("value1: " + value1);
    System.out.println("value2: " + value2);
    System.out.println("value3: " + value3);

    String str1 = String.valueOf(10);
    String str2 = String.valueOf(3.14);
    String str3 = String.valueOf(true);

    System.out.println("str1: " + str1);
    System.out.println("str2: " + str2);
    System.out.println("str3: " + str3);
  }
}
```

<br><br>

<h1>11. 변수 사용 범위</h1>
<ul>
  <li>
    <strong>main() 메소드</strong>에는 <strong>조건문</strong>인 if와 <strong>반복문</strong>인 for, while 등이 <strong>{} 블록</strong>을 갖을 수 있다.
  </li>
    <ul>
      <li>
        중괄호 {} 블록 내에 선언된 변수들은 해당 <strong>중괄호 {} 블록 내에서만</strong> 사용이 가능하다.
      </li>
      <li>
        <strong>메소드 블록 전체</strong>에서 사용하고 싶다면 메소드 블록 <strong>첫 머리</strong>에 선언을 하는 것이 좋고, <strong>특정 블록 내부</strong>에서만 사용한다면 <strong>해당 블록 내</strong>에서 선언하는 것이 좋다.
      </li>
    </ul>
</ul>

```java
// 1. VariableScopeExample.java
package ch02.sec11;

public class VariableScopeExample {
  public static void main(String[] args) {
    int v1 = 15;
    if(v1 > 10) {
      int v2 = v1 - 10;
    }
    // if 블록 외부에서 v2 변수를 사용하기에 컴파일 에러가 발생한다.
    int v3 = v1 + v2 + v2 + 5
  }
}
```

<br><br>

<h1>12. 콘솔로 변수값 출력</h1>
<ul>
  <li>
    Java에서 출력을 할 때에는 일반적으로 세 가지 방법이 가능하다.
  </li>
    <ul>
      <li>
        <strong>println(내용);</strong>: 괄호 안의 내용을 출력하고 행을 바꾼다.
      </li>
      <li>
        <strong>print(내용);</strong>: 괄호 안의 내용을 출력하되 행은 바꾸지 않는다.
      </li>
      <li>
        <strong>printf("형식문자열", 값1, 값2, ...);</strong>: 형식 문자열에 맞추어 값을 출력한다.
      </li>
    </ul>
</ul>

```java
// 1. printf
// [argument_index$] [flags] [width] [.precision] conversion
//   - [argument_index$]: 값의 순번
//     - 형식 문자열이 두 개 이상일 경우 순서를 정해주기 위해 사용한다.
//   - [flags]: -, 0
//   - [width]: 전체 자릿수
//   - [.precision]: 소수 자릿수
//   - conversion: 변환 문자
//     - conversion은 생략할 수 없다 (나머지는 생략 가능)
//     - 제공되는 값에 따라 d(정수), f(실수), s(문자열)가 온다.

// ♨ 이외에도 자주 사용되는 형식화된 문자열이 있는데 p71의 장표 확인.
```

```java
// 2. PrintfExample.java
package ch02.sec12;

public class PrintfExample {
  public static void main(String[] args) {
    int value = 123;
    System.out.printf("상품의 가격:%d원\n", value);
    System.out.printf("상품의 가격:%6d원\n", value);
    System.out.printf("상품의 가격:%-6d원\n", value);
    System.out.printf("상품의 가격:%06d원\n", value);

    double area = 3.14159 * 10 * 10;
    System.out.printf("반지름이 %d인 원의 넓이:%10.2f\n", 10, area);

    String name = "홍길동";
    String job = "도적";
    System.out.printf("%6d | %-10s | %10s\n", 1, name, job);
  }
}
```

<br><br>

<h1>13. 키보드 입력 데이터를 변수에 저장</h1>
<ul>
  <li>
    키보드로부터 입력된 데이터를 읽고 변수에 저장하는 가장 쉬운 방법은 <strong>Scanner</strong>를 사용하는 것이다.
  </li>
  <li>
    <strong>Scanner 타입 변수를 선언</strong>하고, <strong>대입 연산자(=)</strong>를 사용하여 <strong>new 연산자로 생성한 Scanner 객체</strong>를 변수에 대입한다.
  </li>
  <li>
    이후 <strong>scanner.nextLine()</strong>을 실행하여 키보드로 입력된 내용을 문자열로 읽고 좌측 String 변수에 저장한다.
  </li>
  <li>
    Java는 <strong>기본 타입(byte, short, int, long, float, double, boolean) 값</strong>이 동일한지 비교할 때에는 <strong>==</strong>을 사용하고, <strong>String 타입</strong>이 동일한지 비교할 때에는 <strong>equals()</strong>를 사용한다.
  </li>
</ul>

```java
// 1. ScannerExample.java
package ch02.sec13;

// java.util 패키지에 있는 Scanner를 호출한다.
import java.util.Scanner;

public class ScannerExample {
  public static void main(String[] args) throws Exception {
    Scanner scanner = new Scanner(System.in);

    System.out.print("x 값 입력: ");
    String strX = scanner.nextLine();
    int x = Integer.parseInt(strX);

    System.out.print("y 값 입력: ");
    String strY = scanner.nextLine();
    int y = Integer.parseInt(strY);

    int result = x + y;
    System.out.println("x + y: " + result);
    System.out.println();

    while(true) {
      System.out.print("입력 문자열: ");
      String data = scanner.nextLine();
      if(data.equals("q")) {
        break;
      }
      System.out.println("출력 문자열: " + data);
      System.out.println();
    }

  System.out.println("종료");
  }
}
```