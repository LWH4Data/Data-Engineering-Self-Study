<ul>
  <li>
    <strong>그래프</strong>는 <strong>임의의 객체인 노드(또는 정점)</strong>과 이들 간의 <strong>관계를 정의하는 에지</strong>로 구성된 데이터 구조이다.
  </li>
  <li>
    그래프 분석은 이러한 데이터 구조를 분석하는 프로세스이다.
  </li>
  <li>
    <strong>비방향성 그래프(undirected graph)</strong>는 방향성이 없어 에지가 어떤 정점에서 <strong>시작되고 끝나는지 나타나지 않는다</strong>.
  </li>
  <li>
    방향성 그래프(directed graph)는 <strong>시작과 끝을 지정</strong>한 그래프이다.
  </li>
  <li>
    그래프의 에지와 정점은 각각 <strong>속성(attribute)</strong>을 나타내는 데이터를 가질 수 있다.
  </li>
    <ul>
      <li>
        예를 들어 각 <strong>정점은 사람의 이름(name)</strong>으로 하고 <strong>에지는 각 사람간의 친밀도</strong>로 설정할 수 있다.
      </li>
    </ul>
  <li>
    Spark에는 저수준 그래프 처리를 지원하는 GraphX와 DataFrame API에서 사용할 수 있는 <strong>GraphFrame</strong>이 있다. (주로 GraphFrame을 사용).
  </li>
  <li>
    GraphFrame은 별도의 패키지로 지원되며 로드를 해야한다.
  </li>
  <li>
    GraphX 보다 약간의 오버헤드가 있지만 사용자 경험상 GraphFrame이 괜찮으며 GraphX를 호출하여 적절히 처리할 수 있다.
  </li>
  <li>
    GraphFrame은 그래프 데이터베이스(Graph Database)보다 훨씬 더 큰 규모의 작업으로 확장할 수 있고 <strong>분석 작업</strong>은 잘 수행하지만 <strong>트랜잭션 처리 및 검색은 지원하지 않는다</strong>.
  </li>
</ul>

```python
# 1. 실습에 필요한 데이터 불러오기.
bikeStations = spark.read.option("header", "true")\
    .csv("/workspace/Spark-The-Definitive-Guide/data/bike-data/201508_station_data.csv")
tripData = spark.read.option("header", "true")\
    .csv("/workspace/Spark-The-Definitive-Guide/data/bike-data/201508_trip_data.csv")
```

<br>

<h1>1. 그래프 작성하기</h1>
<ul>
  <li>
    정점과 에지는 별도 명명된 컬럼으로 표현되는 <strong>DataFrame</strong>이다.
  </li>
  <li>
    그래프를 정의하기 위해서는 GraphFrame 라이브러리에서 제시하는 <strong>컬럼에 대한 명명규칙</strong>을 사용해야 한다.
  </li>
    <ul>
      <li>
        <strong>정점 테이블</strong>에서 식별자를 <strong>id</strong>로 정의하고(문자열), <strong>에지 테이블</strong>에서는 각 에지의 <strong>시작 정점 ID를 src</strong>로, <strong>도착 정점 ID를 dst</strong>로 표시한다.
      </li>
    </ul>
</ul>

```python
# 1. GraphFrame 컬럼 명명규칙을 준수하며 테이블 생성.
stationVertices = bikeStations.withColumnRenamed("name", "id").distinct()
tripEdges = tripData\
    .withColumnRenamed("Start Station", "src")\
    .withColumnRenamed("End Station", "dst")
```

```python
# 2. GraphFrame을 생성하고 캐싱 기능 적용 (빈번하게 사용하기 때문).
from graphframes import GraphFrame

stationGraph = GraphFrame(stationVertices, tripEdges)
stationGraph.cache()
```

```python
# 3. 기존의 DataFrame을 지의하여 예상된 결과 확인.
print("Total Number of Stations: " + str(stationGraph.vertices.count()))
print("Total Number of Trips in Graph: " + str(stationGraph.edges.count()))
print("Total Number of Trips in Original Data: " + str(tripData.count()))
```

<br><br>

<h1>2. 그래프 쿼리하기</h1>
<ul>
  <li>
    그래프를 활용하는 가장 간단한 방법은 <strong>그래프를 대상으로 쿼리</strong>하는 것이다.
  </li>
  <li>
    GraphFrame은 정점과 에지 모두 <strong>DataFrame</strong>으로 쉽게 접근할 수 있다.(뭔가 이차원 배열 다익스트라 느낌).
  </li>
  <li>
    Graph는 추가되는 컬럼이 계속 유지되기에 <strong>필요할 때 언제든 쿼리</strong>할 수 있다.
  </li>
</ul>

```python
# 1. 그래프 그리기
from pyspark.sql.functions import desc

stationGraph.edges.groupBy("src", "dst").count().orderBy(desc("count")).show(10)
```

```python
# 2. DataFrame 표현식을 활용하여 필터링.
stationGraph.edges\
    .where("src = 'Townsend at 7th' OR dst = 'Townsend at 7th'")\
    .groupBy("src", "dst").count()\
    .orderBy(desc("count"))\
    .show(10)
```

<br>

<h2>2-1. 서브그래프</h2>
<ul>
  <li>
    <strong>서브그래프(subgraph)</strong>는 규모가 큰 그래프 안에서 형성되는 <strong>작은 규모의 그래프</strong>이다.
  </li>
</ul>

```python
# 1. 서브그래프 생성.
townAnd7thEdges = stationGraph.edges\
    .where("src = 'Townsend at 7th' OR dst = 'Townsend at 7th'")
subgraph = GraphFrame(stationGraph.vertices, townAnd7thEdges)
```

<br><br>

<h1>3. 모티프 찾기</h1>
<ul>
  <li>
    모티프는 <strong>구조적 패턴</strong>을 그래프로 표현하는 방법이다.
  </li>
  <li>
    모티프를 지정하면 실제 데이터 대신 <strong>데이터의 패턴을 쿼리</strong>한다.
  </li>
  <li>
    DataFrame은 <strong>도메인 특화 언어</strong>로 쿼리를 지정한다. 예를 들어 주어진 정점 a가 에지 ab를 통해 다른 정점 b에 연결되도록 지정할 때에는 <strong>a-[ab]->b</strong>로 작성하면 된다.
  </li>
  <li>
    쿼리가 <strong>동일한 정점 ID가 여러 개</strong> 있는 경우 하나의 정점으로 통합해서 반환하기를 원한다면 <strong>필터링</strong>을 수행해야 한다.
  </li>
  <li>
    Spark GraphFrame의 가장 강력한 기능 중 하나는 <strong>모티프 찾기를 결과 테이블</strong>을 통해 <strong>DataFrame 쿼리와 결합</strong>하여 <strong>발견된 패턴</strong>을 더욱 간결히 하거나 정렬하거나 집계할 수 있다.
  </li>
</ul>

```python
# 1. 세 도착지 간 삼각형 패턴을 형성하는 모든 자전거 찾기.
motifs = stationGraph.find("(a)-[ab]->(b); (b)-[bc]->(c); (c)-[ca]->(a)")
```

```python
# 2. 기존의 타임스탬프를 Spark 타임스탬프 구문 분석(parsing)한 다음 특정 지점에서 다른 지
#    점으로 이동한 자전거가 동일한지, 각 이동을 시작하려는 시점이 올바른지 비교.
from pyspark.sql.functions import expr

motifs.selectExpr("*",
    "to_timestamp(ab.`Start Date`, 'MM/dd/yyyy HH:mm') as abStart",
    "to_timestamp(bc.`Start Date`, 'MM/dd/yyyy HH:mm') as bcStart",
    "to_timestamp(ca.`Start Date`, 'MM/dd/yyyy HH:mm') as caStart")\
  .where("ca.`Bike #` = bc.`Bike #`").where("ab.`Bike #` = bc.`Bike #`")\
  .where("a.id != b.id").where("b.id != c.id")\
  .where("abStart < bcStart").where("bcStart < caStart")\
  .orderBy(expr("cast(caStart as long) - cast(abStart as long)"))\
  .selectExpr("a.id", "b.id", "c.id", "ab.`Start Date`", "ca.`End Date`")
  .limit(1).show(1, False)
```

<br><br>

<h1>4. 그래프 알고리즘</h1>
<ul>
  <li>
    그래프는 데이터의 논리적 표현에 불과하며 GraphFrame의 여러 알고리즘을 통해 분석을 수행할 수 있다.
  </li>
</ul>

<br>

<h2>4-1. 페이지랭크</h2>
<ul>
  <li>
    페이지랭크는 최초 구글의 공동 설립자인 래리 페이지(Lary Page)에 의해 웹 페이지의 순위를 정하는 방법에 대한 연구 프로젝트로 시작되었다. (자세한 내용 생략).
  </li>
  <li>
    페이지랭크는 웹사이트의 중요성을 대략 판단하기 위해 특정 <strong>웹 페이지가 다른 웹 페이지로</strong>부터 받는 <strong>링크 수</strong>와 <strong>품질을 계산</strong>한다.
  </li>
    <ul>
      중요한 웹사이트일수록 <strong>더 많은 링크</strong>를 받을 것이라 가정.
    </ul>
  <li>
    페이지랭크는 <strong>Graphframe을 반환</strong>하며, 신규 생성되는 pagerank 컬럼으부터 <strong>각 정점에 대한 추정된 페이지랭크 값</strong>을 추출할 수 있다.
  </li>
</ul>

```python
# 1. 페이지랭크를 자전거 여행 데이터에 적용하여 어떤 지점이 더 중요한지 파악.
from pyspark.slq.functions import desc

ranks = stationGraph.pageRank(resetProbability=0.15, maxIter=10)
ranks.vertices.orderBy(desc("pagerank")).select("id", "pagerank").show(10)
```

<br>

<h2>4-2. In-Degree와 Out-Degree 지표</h2>
<ul>
  <li>
    <strong>방향성이 있는 그래프</strong>를 대상으로 주로 하는 작업은 주어진 지점을 기준으로 <strong>도착하는 여행자 수</strong>와 <strong>출발하는 여행자 수</strong>를 계산하는 것이다.
  </li>
    <ul>
      <li>
        각 지점의 출입을 측정하기 위해 각각의 <strong>in-degree</strong>와 <strong>out-degree</strong> 지표를 사용한다. 
      </li>
    </ul>
  <li>
    아웃 바운드보다 인바운드 연결이 많은 소셜 네트워크 분석에 주로 사용된다.
  </li>
</ul>

```python
# 1. GraphFrame을 통해 inDegree 구현.
inDeg = stationGraph.inDegrees
inDeg.orderBy(desc("inDegree")).show(5, False)
```

```python
# 2. outDegrees 구현.
outDeg = stationGraph.outDegrees
outDeg.orderBy(desc("outDegree")).show(5, False)
```

```python
# 3. 비율 확인을 통해 분석 수행.
degreeRatio = inDeg.join(outDeg, "id")\
    .selectExpr("id", "double(inDegree)/double(outDegree) as degreeRatio")
degreeRatio.orderBy(desc("degreeRatio")).show(10, False)
degreeRatio.orderBy("degreeRatio").show(10, False)
```

<br>

<h2>4-3. 너비 우선 탐색</h2>
<ul>
  <li>
    <strong>너비 우선 탐색</strong>은 그래프상의 연결 관계(edge)를 기준으로 두 개의 노드를 <strong>연결하는 방법</strong>을 탐색하는 알고리즘이다.
  </li>
  <li>
    <strong>SQL 표현식</strong>으로 지정된 노드 집합에 적용 가능하며 <strong>maxPathLength</strong>로 최대 에지 수를, <strong>edgeFilter</strong>로 조건에 맞지 않는 에지를 필터링 할 수도 있다.
  </li>
</ul>

```python
# 1. 두 개의 비교적 가까운 역을 선택하여 너비 우선 탐색 수행.
stationGraph.bfs(fromExpr="id = 'Townsend at 7th'",
    toExpr="id = 'Spear at Folsom'", maxPathLength=2).show(10)
```

<br>

<h2>4-4. 연결 요소</h2>
<ul>
  <li>
    <strong>연결 요소(connected component)</strong>는 자체적인 연결을 갖고 있지만 <strong>큰 그래프에는 연결되지 않는(방향성이 없는) 서브 그래프</strong>이다.
  </li>
  <li>
    <strong>반복 수행</strong>마다 작업 상태를 저장하는 <strong>체크포인트 디렉터리</strong>를 설정해야 한다.
  </li>
</ul>

```python
# 1. 데이터를 샘플링하여 가비지 컬렉션 이슈와 같은 Spark 앱 충돌을 방지하여 결과를 얻을 수 
#    있다.
spark.sparkContext.setCheckpointDir("/tmp/checkpoints")

minGraph = GraphFrame(stationVertices, tripEdges.sample(False, 0.1))
cc = minGraph.connectedComponents()
```

```python
# 2. 연결 요소 확인.
cc.where("component != 0").show()
```

<br>

<h2>4-5. 강한 연결 요소</h2>
<ul>
  <li>
    <strong>강한 연결 요소(strongly connected component)</strong>는 <strong>방향성이 고려된 상태</strong>로 강하게 연결된 구성 요소, 즉 <strong>내부의 모든 정점 쌍 사이에 경로</strong>가 존재하는 서브 그래프이다.
  </li>
</ul>

```python
# 1. 강한 연결 요소 적용
scc = minGraph.stronglyConnectedComponents(maxIter=3)
scc.groupBy("component").count().show()
```

<br>

<h2>4-6. 고급 작업</h2>
<ul>
  <li>
    GraphFrame의 기능 중 일부를 선택하여 직접 알고리즘을 정의하는 등 작접을 수행할 수 있다.
  </li>
</ul>