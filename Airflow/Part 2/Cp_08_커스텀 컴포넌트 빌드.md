<ul>
  <li>
    커스텀 컴포넌트로 DAG를 모듈화하여 간결하게 만들기
  </li>
  <li>
    커스텀 훅의 설계와 구현하기
  </li>
  <li>
    커스텀 오퍼레이터의 설계와 구현하기
  </li>
  <li>
    커스텀 센서의 설계와 구현하기
  </li>
  <li>
    커스텀 컴포넌트를 기본 파이썬 라이브러리로 배포하기
  </li>
</ul>

<br>

<h1>1. PythonOperator로 작업하기</h1>
<ul>
  <li>
    PythonOperator를 사용하여 영화 추천 시스템을 구현해본다.
  </li>
  <li>
    영화 평점 API >> 심규 평점 데이터 가져오기(일간) >> 인기 영화 랭킹(일간) >> 추천 앱
  </li>
</ul>

<br>

<h2>1-1. 영화 평점 API 시뮬레이션하기</h2>
<ul>
  <li>
    실습 코드를 그대로 사용하면 되는데 의존성 때문에 업데이트가 좀 필요하다.
  </li>
  <li>
    Docker를 띄운 뒤 localhost:5000/ratings로 접근하면 영화 데이터가 있는 것을 확인할 수 있다. (Json 형식).
  </li>
    <ul>
      <li>
        <strong>result</strong>: 실제 평점 데이터
      </li>
      <li>
        <strong>limit</strong>: 결과 중 한 번에 가져올 수 있는 레코드의 수
      </li>
      <li>
        <strong>offset</strong>: 결과 중 몇 번째 결과부터 가져오는지를 의미한다.
      </li>
    </ul>
  <li>
    필터링을 사용하여 증분(incremental) 방식으로 데이터를 로드할 수도 있다.
  </li>
</ul>

<br>

<h1>1-2. API에서 평점 데이터 가져오기</h2>

```python
# 1. API로 접근하기 위해 Session 클래스를 사용하여 requests 세션 생성.
import request
session = request.Session()
```

```python
# 2. GET HTTP 요청을 통해 데이터 가져오기.
response = session.get("http://localhost:5000/ratings")
```

```python
# 3. 필터링 조건을 주어 조건에 맞는 데이터만 GET
response = session.get(
    "http://localhost:5000/ratings",
    params=(
        "start_date": "2019-01-01",
        "end_date": "2019-01-02",
    ),
)
```

```python
# 4. response 객체의 raise_for_status 메서들를 통해 쿼리 정상 수행 여부 체크

# 확인 전에 세션에 인증 정보 포함.
movielens_user = "airflow"
movielens_password = "airflow"
session.auth = (movielens_user, movielens_password)

# 결과 확인
response.raise_for_status()
response.json()
```

```python
# 5. _get_session 함수를 만든다.
#    - 인증 정보를 가진 세션의 생성과 처리 기능을 캡슐화(encapsulate) 한다.
#    - 함수로 인해 코드 밖에서 인증에 대해 신경쓰지 않아도 된다.
#    - URL을 생성하고 반환하게 하여 URL이 한 곳에 정의되도록 한다.

# 사용할 환경 변수 설정.
MOVIELENS_HOST = os.environ.get("MOVIELENS_HOST", "movielens")
MOVIELENS_SCHEMA = os.environ.get("MOVIELENS_SCHEMA", "http")
MOVIELENS_PORT = os.environ.get("MOVIELENS_PROT", "5000")

MOVIELENS_USER = os.environ["MOVIELENS_USER"]
MOVIELENS_PASSWORD = os.environ["MOVIELENS_PASSWORD"]

# 함수 구현
def _get_session():
    """Builds a request Session for the Movielens API"""

    # 요청 세선 생성
    session = requests.Session()
    # username과 userpassword 기반의 기본 HTTP 인증을 위한 세션 설정.
    session.auth = ("MOVIELENS_USER", "MOVIELENS_PASSWORD")

    schema = MOVIELENS_SCHEMA
    host = MOVIELENS_HOST
    prot = MOVIELENS_PROT

    base_url = f"{schema}://{host}:{port}
    # API의 기본 URL을 세션과 함께 반환하여 어느 주소로 API에 접근하는지 알게 한다.
    return session, base_url

session, base_url = _get_session()
```

```python
# 6. API 결과의 페이지 처리 함수 구현.
def _get_with_pagenation(session, url, params, batch_size=100):
    """
    Fetches records using a GET request with given URL/params,
    taking pagination into account.
    """
    # 받은 레코드 수와 예상 레코드 수를 추적하면서 보관.
    offset = 0
    total = None

    # 모든 레코드를 받을 때까지 반복.
    #     - 첫 번째 loop을 돌기 전까지는 레코드 총 수를 알 수 없기에 None인지 체크
    while total is None or offset < total:
        response = session.get(
            url,
            params={
                **params,
                # 신규 페이지를 가져올 때 주어진 offset 부터 시작.
                **{"offset": offset, "limit": batch_size}
            }
        )
        response.raise_for_status()
        # 결과 상태를 체크하고 JSON을 파신(parse) 함.
        response_json = response.json()

        # 가져온 레코드들을 함수 호출자에게 yield
        yield from response_json["result"]

        # 현재 offset과 레코드 총 수(total)을 업데이트
        offset += batch_size
        total = response_json["total"]
```

```python
# 7. _get_ratings 함수를 전체 내역 결합.
def _get_ratings(start_date, end_date, batch_size=100):
    # API 요청 세션과 기본 URL 가져오기.
    session, base_url = _get_session()

    # 레코드들의 집합을 명확하게 가져오기 위해 페이지 처리 함수(_get_with_pagination)를 
    # 만들어 사용.
    yeild from _get_with_pagination(
        session=session,
        url=base_url _ "/ratings",
        # 주어진 시작/종료 날짜에 대한 레코드를 가져오기 위한 정보.
        params={"start_date": start_date, "end_date": end_date},
        # 한 페이지의 레코드 개수를 제한하기 위한 배치 사이즈 지정.
        batch_size=batch_size
    )

# _get_ratings 함수의 사용 예제
ratings = _get_ratings(session, base_url + "/ratings")
# 한 페이지의 레코드만 가져오거나
next(ratings)
# 전체 배치(batch)에 대한 모든 데이터를 가져온다.
list(ratings)
```

<br>

<h2>1-3. 실제 DAG 구축하기</h2>
<ul>
  <li>
    앞서 구현한 <strong>_get_ratings</strong> 함수를 <strong>PythonOperator</strong>로 호출하여 스케줄 간격으로 평점 데이터를 가져온다.
  </li>
  <li>
    평점 데이터를 <strong>JSON으로 dump</strong> 하며 <strong>날짜별로 파티션</strong>한다.
  </li>
    <ul>
      <li>
        <strong>시작/종료 날짜(start_date, end_date)</strong>를 입력 받고, 기간 동안 평점 데이터를 만들어 출력하는 <strong>작은 래퍼(wrapper) 함수</strong>를 생성한다.
      </li>
    </ul>
</ul>

```python
# 1. _get_rating 함수 사용.
def _fetch_ratings(templates_dict, batch_size=1000, **_):
    
    # logging을 사용하여 함수 동작에 대한 유용한 피드백 제공.
    logger = logging.getLogger(__name__)

    # 템플릿으로 된 시작/종료 날짜와 출력 경로 추출.
    # (위의 logging으로 활용)
    start_date = templates_dict["start_date"]
    end_date = template_dict["end_date"]
    ouptut_path = templates_dict["output_path"]

    logger.info(f"Fetching ratings for {start_date} to {end_date}")
    ratings = list(
        # _get_ratings 함수를 사용해 평점 레코드 가져오기.
        _get_ratings(
            start_date=start_date,
            end_date=end_date
            batch_size=batch_dize
        )
    )
    logger.info(f"Fetched {len(ratings)} ratings")
    
    logger.info(f"Writing ratings to {output_path}")

    # 출력 디렉터리가 존재하지 않을 경우 생성한다.
    output_dir = os.path.dirname(output_path)
    os.makedirs(output_dir, exist_ok=True)

    # 출력 데이터를 JSON 포맷으로 저장한다.
    with open(output_path, "w") as file_:
        json.dump(ratings, fp=file_)

# PythonOperator를사용해 태스크를 생성한다.
fetch_ratings = PythonOperator(
    task_id="fetch_ratings",
    python_callable=_fetch_ratings,
    # 실행 날짜와 같은 context 변수에서 값을 참조할 수 있다.
    templates_dict={
        "start_date": "{{ ds }}",
        "end_date": "{{ next_ds }}",
        "output_path": "/data/python/ratings/{{ ds }}.json",
    },
)
```

```python
# 2. 평점의 개수가 최소 기준 미만인 영화들을 필터링하는 rank_movie_by_rating 함수 정의.
import pandas as pd

def rank_movies_by_rating(rating, min_rating=2):
    ranking = (
        ratings.groupby("movieId")
        # 영화의 평균 평점과 평점 총 개수 계산
        .agg(
            # 평균 평점
            avg_rating=pd.NamedAgg(column="rating", aggfunc="mean"),
            # 평점 총 개수
            num_ratings=pd.NamedAgg(column="userId", aggfunc="nunique"),
        )
        # 최소 평점 개수 기준으로 영화 필터링
        .loc[lambda df: df["num_ratings"] > min_ratings]
        # 평균 평점 기준으로 정렬
        .sort_values(["avg_rating", "num_ratings"], ascending=False)
    )
    return ranking
```

```python
# 3. rank_movies 태스크 추가.
def _rank_movies(templates_dict, min_ratings=2, **_):
    imput_path = templates_dict["input_path"]
    ouptut_path = templates.dict["output_path"]

    # 템플릿으로 지정된 입력 경로에서 평점 데이터를 읽는다.
    ratings = pd.read_json(input_path)
    # rank_movies_by_rating 헬퍼 함수 사용.
    ranking = rank_movies_by_rating(ratings, min_ratings=min_ratigs)

    # 출력 디렉터리가 존재하지 않는 경우 생성한다.
    output_dir = os.path.dirname(output_path)
    os.makedirs(output_dir, exist_ok=True)

    # 영화 랭킹을 CSV 파일로 저장.
    ranking.to_csv(output_path, index=True)

# PythonOperator 내에서 _rank_movies 함수 사용.
rank_movies = PythonOperator(
    task_id="rank_movies",
    python_callable=_rank_movies,
    templates_dict={
        "input_path": "/data/python/ratings/{{ ds }}.json",
        "output_path": "/data/pyton/rankings/{{ ds }}.csv",
    },
)

# 데이터 수집 태스크와 랭킹 태스크 연결.
# 평점 데이터 가져오기 → 영화의 랭크 생성하기.
fetch_ratings >> rank_movies
```

<br><br>

<h1>2. 커스텀 훅 빌드하기</h1>
<ul>
  <li>
    앞서 설정한 코드처럼 API 연동과 같이 복잡한 작업의 처리 방법 중 하나는, 코드를 캡슐화하고 재활용 가능한 Airflow 훅으로 만드는 것이다.
  </li>
    <ul>
      <li>
        
      </li>
    </ul>
</ul>