<ul>
  <li>
    커스텀 컴포넌트로 DAG를 모듈화하여 간결하게 만들기
  </li>
  <li>
    커스텀 훅의 설계와 구현하기
  </li>
  <li>
    커스텀 오퍼레이터의 설계와 구현하기
  </li>
  <li>
    커스텀 센서의 설계와 구현하기
  </li>
  <li>
    커스텀 컴포넌트를 기본 파이썬 라이브러리로 배포하기
  </li>
</ul>

<br>

<h1>1. PythonOperator로 작업하기</h1>
<ul>
  <li>
    PythonOperator를 사용하여 영화 추천 시스템을 구현해본다.
  </li>
  <li>
    영화 평점 API >> 심규 평점 데이터 가져오기(일간) >> 인기 영화 랭킹(일간) >> 추천 앱
  </li>
</ul>

<br>

<h2>1-1. 영화 평점 API 시뮬레이션하기</h2>
<ul>
  <li>
    실습 코드를 그대로 사용하면 되는데 의존성 때문에 업데이트가 좀 필요하다.
  </li>
  <li>
    Docker를 띄운 뒤 localhost:5000/ratings로 접근하면 영화 데이터가 있는 것을 확인할 수 있다. (Json 형식).
  </li>
    <ul>
      <li>
        <strong>result</strong>: 실제 평점 데이터
      </li>
      <li>
        <strong>limit</strong>: 결과 중 한 번에 가져올 수 있는 레코드의 수
      </li>
      <li>
        <strong>offset</strong>: 결과 중 몇 번째 결과부터 가져오는지를 의미한다.
      </li>
    </ul>
  <li>
    필터링을 사용하여 증분(incremental) 방식으로 데이터를 로드할 수도 있다.
  </li>
</ul>

<br>

<h1>1-2. API에서 평점 데이터 가져오기</h2>

```python
# 1. API로 접근하기 위해 Session 클래스를 사용하여 requests 세션 생성.
import request
session = request.Session()
```

```python
# 2. GET HTTP 요청을 통해 데이터 가져오기.
response = session.get("http://localhost:5000/ratings")
```

```python
# 3. 필터링 조건을 주어 조건에 맞는 데이터만 GET
response = session.get(
    "http://localhost:5000/ratings",
    params=(
        "start_date": "2019-01-01",
        "end_date": "2019-01-02",
    ),
)
```

```python
# 4. response 객체의 raise_for_status 메서들를 통해 쿼리 정상 수행 여부 체크

# 확인 전에 세션에 인증 정보 포함.
movielens_user = "airflow"
movielens_password = "airflow"
session.auth = (movielens_user, movielens_password)

# 결과 확인
response.raise_for_status()
response.json()
```

```python
# 5. _get_session 함수를 만든다.
#    - 인증 정보를 가진 세션의 생성과 처리 기능을 캡슐화(encapsulate) 한다.
#    - 함수로 인해 코드 밖에서 인증에 대해 신경쓰지 않아도 된다.
#    - URL을 생성하고 반환하게 하여 URL이 한 곳에 정의되도록 한다.

# 사용할 환경 변수 설정.
MOVIELENS_HOST = os.environ.get("MOVIELENS_HOST", "movielens")
MOVIELENS_SCHEMA = os.environ.get("MOVIELENS_SCHEMA", "http")
MOVIELENS_PORT = os.environ.get("MOVIELENS_PROT", "5000")

MOVIELENS_USER = os.environ["MOVIELENS_USER"]
MOVIELENS_PASSWORD = os.environ["MOVIELENS_PASSWORD"]

# 함수 구현
def _get_session():
    """Builds a request Session for the Movielens API"""

    # 요청 세선 생성
    session = requests.Session()
    # username과 userpassword 기반의 기본 HTTP 인증을 위한 세션 설정.
    session.auth = ("MOVIELENS_USER", "MOVIELENS_PASSWORD")

    schema = MOVIELENS_SCHEMA
    host = MOVIELENS_HOST
    prot = MOVIELENS_PROT

    base_url = f"{schema}://{host}:{port}
    # API의 기본 URL을 세션과 함께 반환하여 어느 주소로 API에 접근하는지 알게 한다.
    return session, base_url

session, base_url = _get_session()
```

```python
# 6. API 결과의 페이지 처리 함수 구현.
def _get_with_pagenation(session, url, params, batch_size=100):
    """
    Fetches records using a GET request with given URL/params,
    taking pagination into account.
    """
    # 받은 레코드 수와 예상 레코드 수를 추적하면서 보관.
    offset = 0
    total = None

    # 모든 레코드를 받을 때까지 반복.
    #     - 첫 번째 loop을 돌기 전까지는 레코드 총 수를 알 수 없기에 None인지 체크
    while total is None or offset < total:
        response = session.get(
            url,
            params={
                **params,
                # 신규 페이지를 가져올 때 주어진 offset 부터 시작.
                **{"offset": offset, "limit": batch_size}
            }
        )
        response.raise_for_status()
        # 결과 상태를 체크하고 JSON을 파신(parse) 함.
        response_json = response.json()

        # 가져온 레코드들을 함수 호출자에게 yield
        yield from response_json["result"]

        # 현재 offset과 레코드 총 수(total)을 업데이트
        offset += batch_size
        total = response_json["total"]
```

```python
# 7. _get_ratings 함수를 전체 내역 결합.
def _get_ratings(start_date, end_date, batch_size=100):
    # API 요청 세션과 기본 URL 가져오기.
    session, base_url = _get_session()

    # 레코드들의 집합을 명확하게 가져오기 위해 페이지 처리 함수(_get_with_pagination)를 
    # 만들어 사용.
    yeild from _get_with_pagination(
        session=session,
        url=base_url _ "/ratings",
        # 주어진 시작/종료 날짜에 대한 레코드를 가져오기 위한 정보.
        params={"start_date": start_date, "end_date": end_date},
        # 한 페이지의 레코드 개수를 제한하기 위한 배치 사이즈 지정.
        batch_size=batch_size
    )

# _get_ratings 함수의 사용 예제
ratings = _get_ratings(session, base_url + "/ratings")
# 한 페이지의 레코드만 가져오거나
next(ratings)
# 전체 배치(batch)에 대한 모든 데이터를 가져온다.
list(ratings)
```

<br>

<h2>1-3. 실제 DAG 구축하기</h2>
<ul>
  <li>
    앞서 구현한 <strong>_get_ratings</strong> 함수를 <strong>PythonOperator</strong>로 호출하여 스케줄 간격으로 평점 데이터를 가져온다.
  </li>
  <li>
    평점 데이터를 <strong>JSON으로 dump</strong> 하며 <strong>날짜별로 파티션</strong>한다.
  </li>
    <ul>
      <li>
        <strong>시작/종료 날짜(start_date, end_date)</strong>를 입력 받고, 기간 동안 평점 데이터를 만들어 출력하는 <strong>작은 래퍼(wrapper) 함수</strong>를 생성한다.
      </li>
    </ul>
</ul>

```python
# 1. _get_rating 함수 사용.
def _fetch_ratings(templates_dict, batch_size=1000, **_):
    
    # logging을 사용하여 함수 동작에 대한 유용한 피드백 제공.
    logger = logging.getLogger(__name__)

    # 템플릿으로 된 시작/종료 날짜와 출력 경로 추출.
    # (위의 logging으로 활용)
    start_date = templates_dict["start_date"]
    end_date = template_dict["end_date"]
    ouptut_path = templates_dict["output_path"]

    logger.info(f"Fetching ratings for {start_date} to {end_date}")
    ratings = list(
        # _get_ratings 함수를 사용해 평점 레코드 가져오기.
        _get_ratings(
            start_date=start_date,
            end_date=end_date
            batch_size=batch_dize
        )
    )
    logger.info(f"Fetched {len(ratings)} ratings")
    
    logger.info(f"Writing ratings to {output_path}")

    # 출력 디렉터리가 존재하지 않을 경우 생성한다.
    output_dir = os.path.dirname(output_path)
    os.makedirs(output_dir, exist_ok=True)

    # 출력 데이터를 JSON 포맷으로 저장한다.
    with open(output_path, "w") as file_:
        json.dump(ratings, fp=file_)

# PythonOperator를사용해 태스크를 생성한다.
fetch_ratings = PythonOperator(
    task_id="fetch_ratings",
    python_callable=_fetch_ratings,
    # 실행 날짜와 같은 context 변수에서 값을 참조할 수 있다.
    templates_dict={
        "start_date": "{{ ds }}",
        "end_date": "{{ next_ds }}",
        "output_path": "/data/python/ratings/{{ ds }}.json",
    },
)
```

```python
# 2. 평점의 개수가 최소 기준 미만인 영화들을 필터링하는 rank_movie_by_rating 함수 정의.
import pandas as pd

def rank_movies_by_rating(rating, min_rating=2):
    ranking = (
        ratings.groupby("movieId")
        # 영화의 평균 평점과 평점 총 개수 계산
        .agg(
            # 평균 평점
            avg_rating=pd.NamedAgg(column="rating", aggfunc="mean"),
            # 평점 총 개수
            num_ratings=pd.NamedAgg(column="userId", aggfunc="nunique"),
        )
        # 최소 평점 개수 기준으로 영화 필터링
        .loc[lambda df: df["num_ratings"] > min_ratings]
        # 평균 평점 기준으로 정렬
        .sort_values(["avg_rating", "num_ratings"], ascending=False)
    )
    return ranking
```

```python
# 3. rank_movies 태스크 추가.
def _rank_movies(templates_dict, min_ratings=2, **_):
    imput_path = templates_dict["input_path"]
    ouptut_path = templates.dict["output_path"]

    # 템플릿으로 지정된 입력 경로에서 평점 데이터를 읽는다.
    ratings = pd.read_json(input_path)
    # rank_movies_by_rating 헬퍼 함수 사용.
    ranking = rank_movies_by_rating(ratings, min_ratings=min_ratigs)

    # 출력 디렉터리가 존재하지 않는 경우 생성한다.
    output_dir = os.path.dirname(output_path)
    os.makedirs(output_dir, exist_ok=True)

    # 영화 랭킹을 CSV 파일로 저장.
    ranking.to_csv(output_path, index=True)

# PythonOperator 내에서 _rank_movies 함수 사용.
rank_movies = PythonOperator(
    task_id="rank_movies",
    python_callable=_rank_movies,
    templates_dict={aa
        "input_path": "/data/python/ratings/{{ ds }}.json",
        "output_path": "/data/pyton/rankings/{{ ds }}.csv",
    },
)

# 데이터 수집 태스크와 랭킹 태스크 연결.
# 평점 데이터 가져오기 → 영화의 랭크 생성하기.
fetch_ratings >> rank_movies
```

<br><br>

<h1>2. 커스텀 훅 빌드하기</h1>
<ul>
  <li>
    앞서 설정한 코드처럼 API 연동과 같이 복잡한 작업의 처리 방법 중 하나는, 코드를 <strong>캡슐화</strong>하고 <strong>재활용</strong> 가능한 Airflow 훅으로 만드는 것이다.
  </li>
    <ul>
      <li>
        모든 API 전용 코드를 한 곳에 보관하여 <strong>DAG의 여러 부분</strong>에서 훅은 사용할 수 있다.
      </li>
    </ul>
  <li>
    훅을 사용하면 Airflow의 DB와 UI를 통해 <strong>자격 증명(credentials)과 연결된 관리 기능</strong>을 사용할 수 있다.
  </li>
</ul>

```python
# 1. MovielensHook을 사용하여 평점 가져오기.

# 훅 생성.
hook = MovielensHook(conn_id="movielens")
# 생성된 훅을 사용하여 특정 작업 수행.
ratings = hook.get_ratings(start_date, end_date)
# 훅을 닫고, 사용된 리소스 해제
hook.close()
```

<br>

<h2>2-1. 커스텀 훅 설계하기</h2>
<ul>
  <li>
    Airflow의 모든 훅은 추상 클래스(abstract class)인 <strong>BaseHook 클래스</strong>의 <strong>서브클래스(subclass)</strong>로 생성한다.
  </li>
  <li>
    훅을 구현하기 위해 훅 연결(필요한 경우)과 훅에 필요한 다른 추가적인 인수를 지정하는 <storng>__init__ 메서드</storng>를 정의해야 한다.
  </li>
  <li>
    대부분의 Airflow 훅은 <storng>get_conn 메서드</storng>를 정의하며 <storng>외부 시스템과의 연결 설정</storng>을 책임진다.
  </li>
  <li>
    <storng>자격 증명 정보</storng>를 활용하는 경우 <storng>Airflow 자격 인증 저장소</storng>에서 가져오는 것이 좋다.
  </li>
    <ul>
      <li>
        Airflow 웹 UI의 <storng>Admin > Connection</storng> 항목의 <storng>Create to add a new connection</storng>을 클릭한다.
      </li>
      <li>
        Add Connectiondp API 연결 세부 정보를 넣는다. Conn id: movielens/Conn Type: HTTP, Host: API의 Host(movielens).
      </li>
      <li>
        HTTP 연결을 위한 Schema 지정 및 로그인 정보를 추가한다.
      </li>
      <li>
        마지막으로 API에 접속할 수 있는 Port를 입력한다.
      </li>
    </ul>
  <li>
    훅(Hook)은 Airflow에서 <strong>외부 시스템(DB, API, Kafka 등)과의 연결</strong>을 <strong>표준화</strong>한 <strong>추상 클래스</strong>이다. 
    즉, 기본적으로 <strong>규칙(메서드 시그니처)만</strong> 정의되어 있으며, 실제 <strong>동작은 상속받아 구현</strong>해야 한다.
  </li>
  <li>
    사용자가 필요한 <strong>메서드를 하나씩 추가</strong>해 구현할 수 있고, 이렇게 작성된 훅은 
    <strong>여러 DAG에서 재사용</strong>되어 코드 중복을 줄이고 유지보수를 쉽게 한다.
  </li>
</ul>

```python
# 1. 커스텀 훅의 베이스 코드
from airflow.hooks.base_hook import BaseHook

class MovielensHook(BaseHook):
    """ 중략 """
```

```python
# 2. MovielensHook 클래스의 __init__ 작성.
from airflow.hooks.base_hook import BaseHook

class MovielensHook(BaseHook):
    # conn_id 파라미터는 훅에게 어떤 커넥션을사용하는지 전달.
    def __init__(self, conn_id):
        # BaseHook 클래스의 생성자 호출
        super().__init__()
        # 커넥션 ID를 꼭 저장한다.
        self._conn_id = conn_id
```

```python
# 3. Web UI에서 설정한 세부 정보를 가져온다.
config = self.get_connection(self._conn_id)

# 여러 세부 정보 조회를 위해 각 필드 초기화.
schema = config.schema or self.DEFAULT_SCHEMA
host = config.host or self.DEFAULT_HOST
port = config.prot or self.DEFAULT_PORT

base_url = f"{schema}://{host}:{port}/"

# Web UI에 정의하지 않은 항목은 기본 값을 정의하거나 미입력시 에러가 발생하게 할 수 있다.
```

```python
# 4. Web UI 설정을 기반으로 세선 인증 정보 설정.
if config.login:
    session.auth = (config.login, config.password)

# 편의성을 위해 기본 커넥션 값을 클래스 변수에 저장.
class MovielensHook(BaseHook):
    DEFAULT_HOST = "movielens"
    DEFAULT_SCHEMA = "http"
    DEFAULT_PORT = 5000

    def __init__(self, conn_id):
        super().__init__()
        self._conn_id = conn_id

        # 세션과 기본 URL의 캐싱을 위한 변수 두 개를 추가.
        self._session = None
        self._base_url = None
    
    def get_conn(self):
        """
        Returns the connection used by the hook for querying data.
        Should in principle not be used directly
        """

        # 세션을 생성하기 전에 연결된 세션이 있는지 체크한다.
        if self._session is None:
            config = self.get_connection(self._conn_id)


            # 주어진 ID를 사용해 커넥션 설정 정보를 가져온다.
            config = self.get_connection(self._conn_id)
            schema = config.schema or self.DEFAULT_SCHEMA
            host = config.host or self.DEFAULT_HOST
            prot = config.prot or self.DEFAULT_PORT
        
        # 커넥션 설정 정보와 기본 값을 사용하여 기본 URL을 구성한다.
        base_url = f"{schema}://{host}:{port}"

        # 커넥션 설정 정보의 login/password 정보를 사용해 요청 세션을 생성한다.
        session = requests.Session()

        if config.login:
            session.auth = (config.login, config.password)

        # 요청 세션과 기본 URL 반환
        return session, base_url
```

```python
# 5. 설정한 get_conn을기반으로 get_ratings 메서드를 재정의 한다.
class MovielensHook(BaseHook):
    """ 중략 """

    # 훅 사용자가 호출할 퍼블릭 메서드
    def get_ratings(self, start_date=None, end_dateNone, batch_size=100):
        """
        Fetches ratings between the given start/end date.
        Parameters
        ___
        start_date: str
            Start date to start fetching ratings from (inclusive). Expected 
            format is YYYY-MM-DD (equal to Airflow's ds formats).
        end_date: str
            End date to fetching ratings up to (exclusive). Expected format is 
            YYYY-MM-DD (equal to Airflow's ds formats).
        batch_size: int
            Size of the batches (pages) to fetch from the API, Larger values 
            mean less requests, but data transferred per request.
        """

        yield from self._get_with_pagination(
            endpoint="/ratings",
            params={"start_date": start_date, "end_date": end_date},
            batch_size=batch_size,
        )

    # 페이지를 처리하는 내부 헬퍼 메서드
    def _get_with_pagination(self, endpoint, params, batch_size=100):
        """
        Fetches records using a get request with given url/params,
        taking pagination into account.
        """

        session, base_url = self.get_conn()

        offset = 0
        total = None
        while total is None or offset < total:
            response = session.get(
                url, params=(
                    **params,
                    **{"offset": offset, "limit": batch_size}
                )
            )
            response.raise_for_status()
            response_json = response.json()

            yield from response_json["result"]

            offset += batch_size
            total = response_json["total"]
```

<br>

<h2>2-2. MovielensHook로 DAG 빌드하기</h2>
<ul>
  <li>
    혹은 <strong>DAG 폴더와 같은 디렉터리</strong> 안에 <strong>패키지를 생성</strong>하고, 패키지 안의 <strong>hook.py라는 모듈</strong>에 훅을 저장한다.
  </li>
</ul>

```python
# 1. 커스터 훅을 포함하는 새로운 커스텀 패키지를 생성 후 훅 불러오기.
from custom.hooks import MovielensHook
```

```python
# 2. MoivelensHook을 사용하여 영화 평점 데이터 가져오기.
hook = MovielensHook(conn_id=conn_id)
ratings = hook.get_ratings(
    start_date=start_date,
    end_date=end_date,
    batch_size=batch_size
)

# 결과로 영화 평점 레코드의 제너레이터(generator)를 반환한다.
# → 제너레이터를 사용하여 영화 평점 데이터를 출력 파일(JSON)으로 저장한다.
```

```python
# 3. DAG에 혹을 사용하기 위해 혹 호출 코드를 PythonOperator에 래핑한다.
def _fetch_ratings(conn_id, templates_dict, batch_size=1000, **_):
    logger = loggin.getLogger(__name__)

    start_date = templates_dict["start_date"]
    end_date = templates_dict["end_date"]
    output_path = templates_dict["output_path"]

    logger.info(f"Fetching ratings for {start_date} to {end_date}")
    # 적절한 커넥션 ID로 MovielensHook 인스턴스 생성.
    # 이후 훅을 사용하여 API에서 평점 데이터를 가져온다.
    hook = MovielensHook(conn_id=conn_id)
    ratings = list(
        hook.get_ratings(
            start_date=start_date, end_date=end_date, batch_size=batch_size
        )
    )
    logger.info(f"Fetched {len(ratings)} ratings")

    logger.info(f"Writing ratings to {output_path}")

    # 이전과 유사하게 가져온 평점 데이터를 저장한다.
    output_dir = os.path.dirname(output_path)
    os.makedirs(output_dir, exist_ok=True)

    with open(output_path, "w") as file_:
        json.dump(ratings, fp=file_)

PythonOperator(
    task_id="fetch_ratings",
    python_callable=_fetch_ratings,
    # 사용할 커넥션을 지정한다.
    op_kwargs={"conn_id": "movielens"},\
    templates_dict={
        "start_date": "{{ ds }}",
        "end_date": "{{ next_ds }}",
        "output_path": "/data/custom_hook/{{ ds }}.json",
    },
)
```

<br>

<h1>3. 커스텀 오퍼레이터 빌드하기</h1>
<ul>
  <li>
    훅을 작성하여도 여러 개의 DAG에 기능을 재사용하려면 많은 코드 중복이 발생한다. <strong>커스텀 오퍼레이터</strong>를 직접 구현하면(e.g. MovielensFetchratingsOperator) 전용 오퍼레이터를 사용하여 코드 재사용을 줄일 수 있다.
  </li>
</ul>

<br>

<h2>3-1. 커스텀 오퍼레이터 정의하기</h2>
<ul>
  <li>
    Airflow의 모든 오퍼레이터는 <strong>BashOperator 클래스</strong>의 <strong>서브 클래스</strong>로 만들어야 한다.
  </li>
  <li>
    커스텀 오퍼레이터에만 사용되는 인수들을 생성자 메서드인 <strong>__init__</strong>에 명시적으로 지정할 수 있다. 
  </li>
    <ul>
      <li>
        오퍼레이터 전용 인수들은 오퍼레이터마다 다르지만, 일반적으로 <strong>커넥션 ID</strong>와 작업에 필요한 <strong>세부사항</strong>이 포함된다.
      </li>
    </ul>
  <li>
    BaseOperator 클래스는 오퍼레이터의 일반적인 동작을 정의하는 <strong>제네릭(generic) 인수</strong>들을 많이 갖는다.
  </li>
    <ul>
      <li>
        Generic 인수들을 모두 나열하지 않도록 BaseOperator 클래스의 __init__에 인수를 전달할 때에는 파이썬의 <strong>**kwargs 구문</strong>을 사용한다.
      </li>
    </ul>
  <li>
    DAG 객체 자체에 <strong>default_args 파라미터</strong>를 사용하면 Airflow에 사용되는 특정 인수를 <strong>전체 DAG의 기본 인수</strong>로 정의할 수 있다.
  </li>
  <li>
    커스텀 오퍼레이터의 기본 인수들이 정상적으로 적용되었는지 확인하기 위해 <strong>apply_defaults 데커레이터</strong>를 사용할 수 있다.
  </li>
    <ul>
      <li>
        apply_defaults는 커스텀 오퍼레이터의 <strong>__init__ 메서드</strong>에 적용된다.
      </li>
      <li>
        실제로 커스텀 오퍼레이터를 정의할 때에는 apply_defautls를 <strong>항상 포함</strong>해야 한다.
      </li>
    </ul>
  <li>
    오퍼레이터가 실제로 작업해야 하는 사항은 <strong>execute 메서드</strong>에 구현한다.
  </li>
    <ul>
      <li>
        execute 메서드는 Airflow가 DAG를 실행할 때 DAG 안에서 실행되는 <strong>오퍼레이터의 메인 메서드</strong>가 된다.
      </li>
      <li>
        execute 메서드는 <strong>context 라는 하나의 파라미터만</strong>을 받는다. context는 Airflow의 <strong>모든 context 변수</strong>를 담고 있는 <strong>dict 객체</strong>이다.
      </li>
    </ul>
</ul>

```python
# 1. 커스텀 오퍼레이터의 베이스 코드
from airflow.models import BaseOperator
from airflow.utils.decorators import apply_defaults

class MyCustomOperator(BaseOperator):
    @apply_defaults
    def __init__(self, conn_id, **kwargs):
        super.__init__(self, **kwargs)
        self._conn_id = conn_id

        """ 중략 """
```

```python
# 2. 오퍼레이터에 기본 인수 적용.
default_args = {
    "retries": 1,
    "retry_delay": timedelta(minutes=5),
}

with DAG(
    """ 중략 """
    default_args=default_args
) as dag:
    MyCustomOperator(
        """ 중략 """
    )
```

```python
# 3. 오퍼레이터의 execute 메서드
class MyCustomOperator(BaseOperator):
    """ 중략 """
    def execute(self, context):
        """ 중략 """
```

<br>

<h2>3-2. 평점 데이터를 가져오기 위한 오퍼레이터 빌드하기</h2>
<ul>
  <li>
    이전 DAG의 _fetch_ratings 함수와 유사하며, 주어진 시작/종료 날짜 사이의 평점 데이터를 MovieLens PAI에서 가져와 JSON 파일로 저장하는 오퍼레이터이다.
  </li>
</ul>

```python
# 1. 코드를 커스텀 오퍼레이터로 이식.
#   - 오퍼레이터 
class MovielensFetchRatingOperator(BaseOperator):
    """
    Operator that fetches ratings from the Movielens API.

    Parameters
    ___
    conn_id: str
        ID of the connections to use to connect to the Movielens
        API. Connection is expected to include authentication
        details (login/password) and the host that is serving the API.
    output_path: str
        Path to wrtie the fetched ratings to.
    start_date: str
        (Templated) start date to start fetching ratings from (inclusive).
        Expected format is YYYY-MM-DD (equal to Airflow's df formats).
    end_date: str
        (Templated) end date to fetching ratings up to (exclusive).
        Expected format is YYYY-MM-DD (equal to Airflow's df formats).
    """

    @apply_defaults
    def __init__(
        self, conn_id, output_path, start_date, end_date, **kwargs,
    ):
        super(MovielensFetchRatingsOperator, self).__init__(**kwargs)

        self._conn_id = conn_id
        self._output_path = output_path
        self._start_date = start_date
        self._end._date = end_date
```

```python
# 2. execute 메서드 추가하기.
class MovielensFetchRatingsOperator(BaseOperator):
    """ 중략 """

    def execute(self, context):
        # 인스턴스 생성
        hook = MovielensHook(self._conn_id)

        try:
            self.log.info(
                f"Fetching ratings for {self._start_date} to {self._end_date}"
            )
            # 훅을 사용하여 평점 데이터 가져오기
            ratings = list(
                hook.get_ratings(
                    start_date=self._start_date,
                    end_date=self._end_date,
                )
            )
            self.log.info(f"Fetched {len(ratings)} ratings")
        finally:
            # 훅을 닫아 사용된 리소스 해제
            hook.close()

        self.log.info(f"Writing ratings to {self._output_path}")

        # 출력 디렉터리가 없을 경우 생성한다.
        output_dir = os.path.dirname(self._output_path)
        os.makedirs(output_dir, exist_ok=True)

        # 가져온 결과 데이터를 파일로 저장한다.
        with open(self._output_path, "w") as file_:
            json.dump(ratings, fp=file_)
```

```python
# 3. 생성한 MovielensFetchRatingsOperator 사용.
fetch_ratings = MovielensFetchRatingsOperator(
    task_id="fetch_ratings",
    conn_id="movielens",
    start_date="2020-01-01",
    end_date="2020-01-02",
    output_path="/data/2020-01-01.json"
)
```

```python
# 4. 커스텀 오퍼레이터에서 템플릿화할 인스턴스 변수들을 Airflow에게 알려준다.
class MovielensFetchRatingsOperator(BaseOperator):
    '''
    template_fields = {"_start_date", "_end_date", "_output_path"}
    
    - 전달된 변수들은 __init__ 안에 생성된다.
    - 문자열 파라미터에 Jinja 템플릿을 사용하면 Airflow는 execute 메서드를 
      호출하기 전에 값들을 템플릿화한다.
    - 템플릿화된 인수를 사용하는 오퍼레이터를 사용할 수 있다.
    '''

    @apply_defaults
    def __init__(
        self,
        conn_id,
        output_path,
        start_date="{{ ds }}",
        end_date="{{ next_ds }}",
        **kwargs
    ):
        super(MovielensFetchRatingsOperator, self).__init__(**kwargs)

        self._conn_id = conn_id
        self._output_path = output_path
        self._start_date = start_date
        self._end_date = end_date
```

```python
# 5. 오퍼레이터에서 템플릿 사용하기.
from custom.operators import MovielensFetchRatingsOperator

fetch_ratings = MovielensFetchRatingsOperator(
    fetch_id="fetch_ratings",
    conn_id="movielens",
    start_date="{{ ds }}",
    end_date="{{ next_ds }}",
    output_path="/data/custom_operator/{{ ds }}.json"
)
```

<br><br>

<h1>4. 커스텀 센서 빌드하기</h1>
<ul>
  <li>
    Sensor는 특별한 유형의 오퍼레이터이며 DAG 안에서 다운스트림 태스크를 실행하기 전에 특정 조건이 충족될 때까지 <strong>대기</strong>하기 위해 사용된다.
  </li>
  <li>
    BaseOperator 대신에 <strong>BaseSensorOperator 클래스</strong>를 상속한다는 차이만 있다.
  </li>
  <li>
    Sensor는 오퍼레이터의 한 유형이며 BaseSensorOperator는 센서에 대한 기본 기능을 제공하고, 오퍼레이터의 execute 메서드 대신 <strong>poke 메서드</strong>를 구현한다.
  </li>
  <li>
    poke는 execute와 다르게 <strong>True/False 불리언 값</strong>을 반환한다.
  </li>
</ul>

```python
# 1. 커스텀 센서의 베이스 코드.
from airflow.sensors.base import BaseSensorOperator

class MyCustomSensor(BaseSensorOperator):
    """ 중략 """
```

```python
# 2. 센서의 poke 메서드
class MyCustomSensor(BaseSensorOperator):

    def poke(self, context):
        """ 중략 """
```

```python
# 3. 센서 클래스의 기본 구현
#   - 평점 데이터를 체크할 시작/종료 날짜의 범위를 입력으로 받는다.
from airflow.sensors.base import BaseSensorOperator
from airflow.utils.decorators import apply_defaults

class MovielensRatingsSensor(BaseSensorOperator):
    """
    Sensor that waits for the Movielens API to have
    ratings for as time period.
    
    start_date: str
        (Templated) start date of the time period to check for (inclusive).
        Expected format is YYYY-MM-DD (equal to Airflow's df formats).
    end_date: str
        (Templated) end date of the time period to check for (exclusive).
        Expected format is YYYY-MM-DD (equal to Airflow's ds formats).
    """

    # 센서가 오퍼레이터의 특정 유형이기 때문에 오퍼레이터를 구현할 때 사용했던 것과 같은 
    # 설정을 사용한다.
    template_fields = ("_start_date", "_end_date")

    # 같은 설정
    @apply_defaults

    def __init__(self, conn_id, start_date="{{ ds }}", \
                end_date="{{ next_ds }}", **kwargs):
        # 같은 설정
        super().__init__(**kwargs)
        self._conn_id = conn_id
        self._start_date = start_date
        self._end_date = end_date
```

```python
# 4. poke 메서드 구현하기
class MovielensRatingsSensor(BaseSensorOperator):
    def poke(self, context):
        hook = Movielenshook(self._conn_id)

        try:
            # 훅에서 레코드 하나를 가져오는 것을 시도.
            # (첫 번째 레코드를 가져오도록 next를 사용한다).
            next(
                hook.get_ratings(
                    start_date=self._start_date,
                    end_date=self._end_date,
                    batch_size-1
                )
            )
            self.log.info(
                f"Found ratings for {self._start_date} to {self._end_date}"
            )
            # next가 성공이면 적어도 하나의 레코드가 있기에 true를 반환한다.
            return True
        
        # next의 수행이 StopIteration 예외로 실패한다면 레코드 콜렉션이 비어 있는 
        # 것이기에 false를 반환한다.
        except StopIteration:
            self.log.info(
                f"Didn't find any ratings for {self._start_date}"
                f"to {self._end_date}, watiting..."
            )
            return False
        # 훅을 close하여 사용한 리소스를 해제한다.
        finally:
            hook.close()
```

```python
# 5. MovielensHook을 재사용하여 새로 들어온 평점 데이터가 있는지 체크한다.
""" 중략 """

from custom.operators import MovielensFetchRatingsOperator
from custom.sensors import MovielensRatingSensor

with DAG(
    dag_id="04_sensor",
    description="Fetches ratings with a custom sensor.",
    start_date=airflow_utils.dates.days_ago(7),
    schedule_interval="@daily",
) as dag:
    # 사용 가능한 레코드를 기다리는 센서
    wait_for_ratings = MovielensRatingsSensor(
        task_id="wait_for_ratings",
        conn_id="movielens",
        start_date="{{ ds }}"
        end_date="{{ next_ds }}",
        output_path="/data/custom_sensor/{{ ds }}.json"
    )

    # 센서 실행이 완료된 후에 레코드를 가져오는 오퍼레이터
    fetch_ratings = MovielensFetchRatingsOperator(
        task_id="fetch_ratings",
        conn_id="movielens",
        start_date="{{ ds }}",
        end_date="{{ next_ds }}",
        output_path="/data/custom_sensor/{{ ds }}.json"
    )

    """ 중략 """

    wait_for_ratings >> fetch_ratings >> rank_movies
```

<br><br>

<h1>5. 컴포넌트 패키징하기</h1>
<ul>
  <li>
    컴포넌트를 배포하는 더 나은 방법은 <strong>파이썬 패키지</strong>에 코드를 넣어 다른 프로젝트나 사용자까지 사용할 수 있게 하는 것이다.
  </li>
  <li>
    커스텀 컴포넌트를 <strong>설치</strong>할 때에는 다른 패키지와 비슷한 방법으로 작업할 수 있다.
  </li>
  <li>
    <strong>DAG와는 별도로 코드를 유지</strong>하며 커스텀 <strong>코드에 대한 CI/CD 프로세스</strong>를 구성할 수 있고, 다른 사람과 코드를 쉽게 <strong>공유하고 협업</strong>할 수 있다.
  </li>
</ul>

<br>

<h2>5-1. 파이썬 패키지 부트스트랩 작업하기</h2>
<ul>
  <li>
    <strong>setuptools</strong>를 사용하여 파이썬 패키지를 생성하는 실습을 다룬다.
  </li>
</ul>

```bash
# 1. 패키지를 빌드하기 위해 패키지의 디렉터리를 생성한다.
mkdir -p airflow-movielens
cd airflow-movielens
```

```bash
# 2. 소스 코드를 보관할 패키지의 기본 구조를 생성한다.
mkdir -p src/airflow_movielens
touch src/airflow_movielens/__init__.py

# 이후 src/airflow_movielens 디렉터리에 앞서 작성한 hooks.py, sensors.py, 
# operators.py를 복사해서 넣는다.
```

```python
# 2. setup.py를 생성한 뒤 src와 같은 경로에 추가한다.
#   - setup.py 파일은 setuptools가 패키지를 어떻게 설치할지 지시하는 파일이다.

#!/usr/bin/env python
import setuptools

# 이 패키지에 필요한 파이썬 패키지 리스트
requirements = ["apache-airflow", "request"]

setuptools.setup(
    # 패키지 이름
    name="airflow_movielens",

    # 버전
    version="0.1.0",

    # 설명
    description="Hooks, sensors and operators for the Movielens API.",

    # 개발 저자의 세부 사항
    author="Anonymous",
    author_email="anonymous@example.com",

    # 패키지 종속성
    install_requires=requirements,

    # setuptools에게 패키지의 파이썬 파일들의 위치 제공
    packages=setuptools.find_packages("src"),
    package_dir={"": "src"},

    # 패키지 홈페이지
    url="https://github.com/example-repo/airflow_movielens",

    # 개발 코드의 라이선스 정보
    license="MIT license",
)
```

<br>

<h2>5-2. 패키지 설치하기</h2>
<ul>
  <li>
    작업 환경에 따라 Airflow에서 사용하는 모든 환경(스케줄러, 웹 서버 및 워커의 환경)에 설치 되어야 할 수 있다.
  </li>
</ul>

```bash
# 1. pip을 통한 패키지 설치
python -m pip install ./airflow-movielens
```

```bash
# 2. 클래스 중 하나를 불러 오류 유무를 확인한다.
python
from airflow_movielens.hooks import MovielensHook
MovielensHook
```

```bash
# 3. 깃헙 저장소에서 다운.
python -m pip install git+https://github.com/..
```

```bash
# 4. PyPI와 같이 pip 패키지 피드를 사용해 설치
python -m pip install airflow_movielen
```